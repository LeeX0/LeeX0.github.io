<!DOCTYPE html><html lang="en" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="LeeX0"><meta name="keywords" content=""><title>Python3-Cookbook第一章:数据结构和算法(2) - LeeX0&#39;s blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/themes/prism.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"leex0.top",root:"/",version:"1.8.9-a",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>LeeX0's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> Archives</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/Royal_BluePetrol.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Python3-Cookbook第一章:数据结构和算法(2)"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> LeeX0 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-11-07 16:45" pubdate>November 7, 2020 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 44 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Python3-Cookbook第一章:数据结构和算法(2)</h1><div class="markdown-body"><h4 id="1-11-命名切片"><a href="#1-11-命名切片" class="headerlink" title="1.11 命名切片"></a>1.11 命名切片</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 命名切片
# 假定你要从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段

# 与其
record &#x3D; &#39;....................100 .......513.25 ..........&#39;
cost &#x3D; int(record[20:23]) * float(record[31:37])

# 不如
SHARES &#x3D; slice(20, 23)
PRICE &#x3D; slice(31, 37)
cost &#x3D; int(record[SHARES]) * float(record[PRICE])
</code></pre></div><h4 id="1-12-序列中出现次数最多的元素"><a href="#1-12-序列中出现次数最多的元素" class="headerlink" title="1.12 序列中出现次数最多的元素"></a>1.12 序列中出现次数最多的元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 序列中出现次数最多的元素

&quot;&quot;&quot; 
collections.Counter 类就是专门为这类问题而设计的， 它甚至有一个有用的 most_common() 方法直接给了你答案。
&quot;&quot;&quot;
# 取出出现频率最高的单词
from collections import Counter
words &#x3D; [
    &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;,
    &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;not&#39;, &#39;around&#39;, &#39;the&#39;,
    &#39;eyes&#39;, &quot;don&#39;t&quot;, &#39;look&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;,
    &#39;my&#39;, &#39;eyes&#39;, &quot;you&#39;re&quot;, &#39;under&#39;
]
word_counts &#x3D; Counter(words)
# 出现频率最高的3个单词
top_three &#x3D; word_counts.most_common(3)
print(top_three)
# Outputs [(&#39;eyes&#39;, 8), (&#39;the&#39;, 5), (&#39;look&#39;, 4)]

&quot;&quot;&quot; 
collections.Counter底层实际上是一个元素作为key，出现次数作为value的dict。
神奇的是还能进行数学运算操作结合。
&quot;&quot;&quot;
morewords &#x3D; [&#39;why&#39;,&#39;are&#39;,&#39;you&#39;,&#39;not&#39;,&#39;looking&#39;,&#39;in&#39;,&#39;my&#39;,&#39;eyes&#39;]
a &#x3D; Counter(words)
b &#x3D; Counter(morewords)
a
# Outputs
# Counter(&#123;&#39;eyes&#39;: 8, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;into&#39;: 3, &#39;my&#39;: 3, &#39;around&#39;: 2,&quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;under&#39;: 1, &#39;not&#39;: 1&#125;)
b
# Outputs
# Counter(&#123;&#39;eyes&#39;: 1, &#39;looking&#39;: 1, &#39;are&#39;: 1, &#39;in&#39;: 1, &#39;not&#39;: 1, &#39;you&#39;: 1,&#39;my&#39;: 1, &#39;why&#39;: 1&#125;)

# Combine counts
c &#x3D; a + b
c
# Outputs
# Counter(&#123;&#39;eyes&#39;: 9, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;my&#39;: 4, &#39;into&#39;: 3, &#39;not&#39;: 2,&#39;around&#39;: 2, &quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;in&#39;: 1, &#39;why&#39;: 1,&#39;looking&#39;: 1, &#39;are&#39;: 1, &#39;under&#39;: 1,&#39;you&#39;: 1&#125;)

# Subtract counts
d &#x3D; a - b
d
# Outputs
# Counter(&#123;&#39;eyes&#39;: 7, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;into&#39;: 3, &#39;my&#39;: 2, &#39;around&#39;: 2,&quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;under&#39;: 1&#125;)
</code></pre></div><h4 id="1-13-通过某个关键字排序一个字典列表"><a href="#1-13-通过某个关键字排序一个字典列表" class="headerlink" title="1.13 通过某个关键字排序一个字典列表"></a>1.13 通过某个关键字排序一个字典列表</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过某个关键字排序一个字典列表

&quot;&quot;&quot; 
使用 operator 模块的 itemgetter 函数。
排序过程中，相当于key使用的itemgetter获取到了dict中对应key的value进行排序。
itemgetter同时支持多个keys。
&quot;&quot;&quot;
from operator import itemgetter
rows &#x3D; [
    &#123;&#39;fname&#39;: &#39;Brian&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1003&#125;,
    &#123;&#39;fname&#39;: &#39;David&#39;, &#39;lname&#39;: &#39;Beazley&#39;, &#39;uid&#39;: 1002&#125;,
    &#123;&#39;fname&#39;: &#39;John&#39;, &#39;lname&#39;: &#39;Cleese&#39;, &#39;uid&#39;: 1001&#125;,
    &#123;&#39;fname&#39;: &#39;Big&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1004&#125;
]
rows_by_fname &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;fname&#39;))
rows_by_uid &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;uid&#39;))
print(rows_by_fname)
print(rows_by_uid)

rows_by_lfname &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;lname&#39;, &#39;fname&#39;))
print(rows_by_lfname)

&quot;&quot;&quot; 
在上面例子中， rows 被传递给接受一个关键字参数的 sorted() 内置函数。 
这个参数是 callable 类型，并且从 rows 中接受一个单一元素，然后返回被用来排序的值。
itemgetter() 函数就是负责创建这个 callable 对象的。
本例中的操作基本等同于key中使用lambda定义，但是效率更高。同样适用于max，min等。
&quot;&quot;&quot;
rows_by_fname &#x3D; sorted(rows, key&#x3D;lambda r: r[&#39;fname&#39;])
rows_by_lfname &#x3D; sorted(rows, key&#x3D;lambda r: (r[&#39;lname&#39;], r[&#39;fname&#39;]))
</code></pre></div><h4 id="1-14-排序不支持原生比较的对象"><a href="#1-14-排序不支持原生比较的对象" class="headerlink" title="1.14 排序不支持原生比较的对象"></a>1.14 排序不支持原生比较的对象</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 排序不支持原生比较的对象

&quot;&quot;&quot; 
关键在于传入callable的key参数时，获取到非原生对象的具体变量。
可以通过lambda或者operator中的attrgetter。
&quot;&quot;&quot;
from operator import attrgetter


class User:
    def __init__(self, user_id):
        self.user_id &#x3D; user_id

    def __repr__(self):
        return &#39;User(&#123;&#125;)&#39;.format(self.user_id)


users &#x3D; [User(23), User(3), User(99)]
# Method 1
print(sorted(users, key&#x3D;lambda u: u.user_id))

# Method 2
print(sorted(users, key&#x3D;attrgetter(&#39;user_id&#39;)))
</code></pre></div><h4 id="1-15-通过某个字段将记录分组"><a href="#1-15-通过某个字段将记录分组" class="headerlink" title="1.15 通过某个字段将记录分组"></a>1.15 通过某个字段将记录分组</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过某个字段将记录分组

&quot;&quot;&quot; 
使用itertools.groupby()函数，务必记得需要先排序
&quot;&quot;&quot;
from collections import defaultdict
from itertools import groupby
from operator import itemgetter
rows &#x3D; [
    &#123;&#39;address&#39;: &#39;5412 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;&#125;,
    &#123;&#39;address&#39;: &#39;5148 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;&#125;,
    &#123;&#39;address&#39;: &#39;5800 E 58TH&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,
    &#123;&#39;address&#39;: &#39;2122 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;03&#x2F;2012&#39;&#125;,
    &#123;&#39;address&#39;: &#39;5645 N RAVENSWOOD&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,
    &#123;&#39;address&#39;: &#39;1060 W ADDISON&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,
    &#123;&#39;address&#39;: &#39;4801 N BROADWAY&#39;, &#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;&#125;,
    &#123;&#39;address&#39;: &#39;1039 W GRANVILLE&#39;, &#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;&#125;,
]

# 需要预先按照想要分组的item排序
rows.sort(key&#x3D;itemgetter(&#39;date&#39;))
# 分组
for date, items in groupby(rows, key&#x3D;itemgetter(&#39;date&#39;)):
    print(date)
    for i in items:
        print(&#39; &#39;, i)
&quot;&quot;&quot; 输出结果
07&#x2F;01&#x2F;2012
  &#123;&#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;, &#39;address&#39;: &#39;5412 N CLARK&#39;&#125;
  &#123;&#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;, &#39;address&#39;: &#39;4801 N BROADWAY&#39;&#125;
07&#x2F;02&#x2F;2012
  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;5800 E 58TH&#39;&#125;
  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;5645 N RAVENSWOOD&#39;&#125;
  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;1060 W ADDISON&#39;&#125;
07&#x2F;03&#x2F;2012
  &#123;&#39;date&#39;: &#39;07&#x2F;03&#x2F;2012&#39;, &#39;address&#39;: &#39;2122 N CLARK&#39;&#125;
07&#x2F;04&#x2F;2012
  &#123;&#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;, &#39;address&#39;: &#39;5148 N CLARK&#39;&#125;
  &#123;&#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;, &#39;address&#39;: &#39;1039 W GRANVILLE&#39;&#125;
&quot;&quot;&quot;

&quot;&quot;&quot; 
如果需要保持序列顺序，则可以通过1-6中的defaultdict，将想要分组的item作为其中的key，然后将整条记录append到对应item的组别中。
&quot;&quot;&quot;
rows_by_date &#x3D; defaultdict(list)
for row in rows:
    rows_by_date[row[&#39;date&#39;]].append(row)
</code></pre></div><h4 id="1-16-过滤序列元素"><a href="#1-16-过滤序列元素" class="headerlink" title="1.16 过滤序列元素"></a>1.16 过滤序列元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 过滤序列元素

&quot;&quot;&quot; 
可通过列表推导式达到目的，好处是同时还能充当简单的数据住转换。但是当元素结果集很大时则很占内存。
可以将过滤代码放到一个函数中， 然后使用内建的 filter() 函数。
&quot;&quot;&quot;
# filter得到的是一个迭代器，如果想得到列表还需要进行list()转换
values &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;-3&#39;, &#39;-&#39;, &#39;4&#39;, &#39;N&#x2F;A&#39;, &#39;5&#39;]

def is_int(val):
    try:
        x &#x3D; int(val)
        return True
    except ValueError:
        return False

ivals &#x3D; list(filter(is_int, values))
print(ivals)
# Outputs [&#39;1&#39;, &#39;2&#39;, &#39;-3&#39;, &#39;4&#39;, &#39;5&#39;]

&quot;&quot;&quot; 
列表推导式
1. [i for i in range(k) if condition]：此时if起条件判断作用，满足条件的，将被返回成为最终生成的列表的一员。
2. [i if condition else exp for exp]：此时if...else被用来赋值，满足条件的i以及else被用来生成最终的列表。
&quot;&quot;&quot;
print([i for i in range(10) if i % 2 &#x3D;&#x3D; 0])
print([i if i &#x3D;&#x3D; 0 else 100 for i in range(10)])
# Outputs
[0, 2, 4, 6, 8]
[0, 100, 100, 100, 100, 100, 100, 100, 100, 100]
</code></pre></div><h4 id="1-17-从字典中提取子集"><a href="#1-17-从字典中提取子集" class="headerlink" title="1.17 从字典中提取子集"></a>1.17 从字典中提取子集</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 从字典中提取子集

# 使用字典推导
prices &#x3D; &#123;
    &#39;ACME&#39;: 45.23,
    &#39;AAPL&#39;: 612.78,
    &#39;IBM&#39;: 205.55,
    &#39;HPQ&#39;: 37.20,
    &#39;FB&#39;: 10.75
&#125;
# 取出value大于200的
p1 &#x3D; &#123;key: value for key, value in prices.items() if value &gt; 200&#125;
# 取出在name列表中的键值对
tech_names &#x3D; &#123;&#39;AAPL&#39;, &#39;IBM&#39;, &#39;HPQ&#39;, &#39;MSFT&#39;&#125;
p2 &#x3D; &#123;key: value for key, value in prices.items() if key in tech_names&#125;
</code></pre></div><h4 id="1-18-映射名称到序列元素"><a href="#1-18-映射名称到序列元素" class="headerlink" title="1.18 映射名称到序列元素"></a>1.18 映射名称到序列元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 映射名称到序列元素

&quot;&quot;&quot; 
使用collections.namedtuple()，函数使用即在初始化的时候传入一个类型名与需要的下标字段。
通过使用下标对元组中的内容进行组合操作会表意不清晰。
命名元组与字典功能很接近，但是要更节省内存。
&quot;&quot;&quot;
from collections import namedtuple
Subscriber &#x3D; namedtuple(&#39;Subscriber&#39;, [&#39;addr&#39;, &#39;joined&#39;])
sub &#x3D; Subscriber(&#39;jonesy@example.com&#39;, &#39;2012-10-19&#39;)
print(sub)  # Subscriber(addr&#x3D;&#39;jonesy@example.com&#39;, joined&#x3D;&#39;2012-10-19&#39;)
print(sub.addr)  # jonesy@example.com
print(sub.joined)  # 2012-10-19

# 举例使用，在命名元组中使用下标。
# 实际上本身对records中的每条记录内容都知道是什么，只是为了表意清楚，使用有名字的下标进行计算。
Stock &#x3D; namedtuple(&#39;Stock&#39;, [&#39;name&#39;, &#39;shares&#39;, &#39;price&#39;])

def compute_cost(records):
    total &#x3D; 0.0
    for rec in records:
        s &#x3D; Stock(*rec)
        total +&#x3D; s.shares * s.price
    return total
</code></pre></div><h4 id="1-19-转换并同时计算数据"><a href="#1-19-转换并同时计算数据" class="headerlink" title="1.19 转换并同时计算数据"></a>1.19 转换并同时计算数据</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 转换并同时计算数据

&quot;&quot;&quot; 
练习使用生成器表达式参数
&quot;&quot;&quot;
# 计算平方和
import os
nums &#x3D; [1, 2, 3, 4, 5]
s &#x3D; sum(x * x for x in nums)

# 查看文件夹中是否包含.py后缀文件
files &#x3D; os.listdir(&#39;dirname&#39;)
if any(name.endswith(&#39;.py&#39;) for name in files):
    print(&#39;There be python!&#39;)
else:
    print(&#39;Sorry, no python.&#39;)
# 计算字典列表中某个key最小的value
portfolio &#x3D; [
    &#123;&#39;name&#39;: &#39;GOOG&#39;, &#39;shares&#39;: 50&#125;,
    &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 75&#125;,
    &#123;&#39;name&#39;: &#39;AOL&#39;, &#39;shares&#39;: 20&#125;,
    &#123;&#39;name&#39;: &#39;SCOX&#39;, &#39;shares&#39;: 65&#125;
]
min_shares &#x3D; min(s[&#39;shares&#39;] for s in portfolio)

# 对于min() 和 max() 它们接受的一个 key 关键字参数或许对你很有帮助
</code></pre></div><h4 id="1-20-合并多个字典或映射"><a href="#1-20-合并多个字典或映射" class="headerlink" title="1.20 合并多个字典或映射"></a>1.20 合并多个字典或映射</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 合并多个字典或映射

&quot;&quot;&quot; 
使用collections 模块中的 ChainMap 类
&quot;&quot;&quot;
from collections import ChainMap
a &#x3D; &#123;&#39;x&#39;: 1, &#39;z&#39;: 3&#125;
b &#x3D; &#123;&#39;y&#39;: 2, &#39;z&#39;: 4&#125;
c &#x3D; ChainMap(a, b)  # 先从a找，再从b找
print(c[&#39;x&#39;])  # Outputs 1 (from a)
print(c[&#39;y&#39;])  # Outputs 2 (from b)
print(c[&#39;z&#39;])  # Outputs 3 (from a)

&quot;&quot;&quot; 
通过这种操作的字典并不是真正的合并了，只是内部创建了容纳这些字典的列表，大部分字典操作可以正常使用。
对于新字典的更新与删除会影响列表中的第一个字典。而使用update()方法，原字典的更新不会影响到新的合并字典。
&quot;&quot;&quot;
a &#x3D; &#123;&#39;x&#39;: 1, &#39;z&#39;: 3&#125;
b &#x3D; &#123;&#39;y&#39;: 2, &#39;z&#39;: 4&#125;
merged &#x3D; dict(b)
merged.update(a)
merged[&#39;x&#39;]  # 1
merged[&#39;y&#39;]  # 2
merged[&#39;z&#39;]  # 3

a[&#39;x&#39;] &#x3D; 13
merged[&#39;x&#39;]  # 1
</code></pre></div><hr><blockquote><p>参考：</p><p><a target="_blank" rel="noopener" href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a target="_blank" rel="noopener" href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python/">Python</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Python/">Python</a> <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="hover-with-bg" href="/tags/Cookbook/">Cookbook</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/posts/f1c5e49e/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Python3-Cookbook第二章:字符串和文本(1)</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/posts/26745e6d/"><span class="hidden-mobile">Python3-Cookbook第一章:数据结构和算法(1)</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-core.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><script src="/js/boot.js"></script></body></html>