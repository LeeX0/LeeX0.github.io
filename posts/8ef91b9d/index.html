<!DOCTYPE html><html lang="en" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="LeeX0"><meta name="keywords" content=""><title>Docker实践——Dockerfile指令 - LeeX0&#39;s blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/themes/prism.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"leex0.top",root:"/",version:"1.8.9-a",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>LeeX0's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> Archives</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/Royal_BluePetrol.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Docker实践——Dockerfile指令"></span><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> LeeX0 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-24 15:28" pubdate>March 24, 2021 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 35 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Docker实践——Dockerfile指令</h1><div class="markdown-body"><blockquote><p><code>FROM</code>与<code>RUN</code>命令不再介绍，见<a href="https://leex0.top/2021/03/24/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">链接</a>。</p></blockquote><h2 id="COPY复制文件"><a href="#COPY复制文件" class="headerlink" title="COPY复制文件"></a>COPY复制文件</h2><p>格式：</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</code></pre></div><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a target="_blank" rel="noopener" href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则，如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY hom* &#x2F;mydir&#x2F;
COPY hom?.txt &#x2F;mydir&#x2F;</code></pre></div><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY --chown&#x3D;55:mygroup files* &#x2F;mydir&#x2F;
COPY --chown&#x3D;bin files* &#x2F;mydir&#x2F;
COPY --chown&#x3D;1 files* &#x2F;mydir&#x2F;
COPY --chown&#x3D;10:11 files* &#x2F;mydir&#x2F;</code></pre></div><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p><h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><blockquote><p><strong>结论：此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</strong></p></blockquote><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM scratch
ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;
...</code></pre></div><h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p><strong>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</strong></p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">CMD echo $HOME</code></pre></div><p>在实际执行中，会将其变更为：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></pre></div><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>exec</code>形式下<code>ENTRYPOINT</code>与<code>CMD</code>组成的完整命令：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">executable CMD</code></pre></div><p><code>shell</code>形式下<code>ENTRYPOINT</code>与<code>CMD</code>组成的完整命令（不建议使用）：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh -c &quot;executable&quot; CMD</code></pre></div><p><code>ENTRYPOINT</code>作为目标入口。例：在<code>ubuntu</code>中默认的<code>ENTRYPOINT</code>其实就是<code>/bin/bash</code>。</p><p><code>ENTRYPOINT + CMD</code>加起来组成了容器起动时的指令。当我们想把目标镜像作为一个一次性运行的程序时，则在<code>ENTRYPOINT</code>中设置可执行命令，在<code>CMD</code>中设置参数。</p><p>比如有一个二进制的可执行文件square，需要一个参数，对其求平方值。那么我们可以打一个平方工具的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM baseImage
ADD square &#x2F;usr&#x2F;bin&#x2F;
RUN chmod +x &#x2F;usr&#x2F;bin&#x2F;square
ENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;square&quot;]
CMD [&quot;2&quot;]</code></pre></div><p>那么，打出来镜像后（假设镜像名为squareImage:1.0），我们就可以这样使用镜像，这个命令会直接输出结果4，然后容器退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run squareImage:1.0</code></pre></div><p>当然，我们还可以在docker run的时候覆盖CMD，如下命令会直接输出结果9，然后容器退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run squareImage:1.0 3</code></pre></div><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on NAME&#x3D;&quot;Happy Feet&quot;</code></pre></div><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的是<strong>构建环境的环境变量（参数）</strong>，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">VOLUME &#x2F;data</code></pre></div><h3 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a>EXPOSE 暴露端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。类似于<code>Dockerfile</code>中的<code>cd</code>指令。</p><blockquote><p>一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">RUN cd &#x2F;app
RUN echo &quot;hello&quot; &gt; world.txt</code></pre></div><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p></blockquote><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><code>USER</code> 是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><h2 id="容器中应用前台执行与后台执行问题"><a href="#容器中应用前台执行与后台执行问题" class="headerlink" title="# 容器中应用前台执行与后台执行问题"></a># 容器中应用前台执行与后台执行问题</h2><blockquote><p>注：区别与容器在<code>docker</code>中的前后台运行（<code>docker run -d</code>），是两码事。本处指容器中的应用在容器中前后台运行问题。</p><p><strong>结论：</strong></p><p><strong>容器必须要一个前台进程并且作为<code>pid=1</code>的主进程。（大概等于bash必须始终在占用）</strong></p><p><strong>容器会随着<code>pid=1</code>进程的结束而结束。</strong></p></blockquote><h3 id="情景一"><a href="#情景一" class="headerlink" title="情景一"></a>情景一</h3><blockquote><p>默认<code>nginx</code>镜像启动容器，或<code>FROM nginx</code>但未指定<code>CMD</code>。</p></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，原因是<code>nginx</code>默认镜像中<code>CMD</code>为前台运行：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># docker-nginx&#x2F;Dockerfile-alpine.template
···
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></pre></div><h3 id="情景二"><a href="#情景二" class="headerlink" title="情景二"></a>情景二</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginx
CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre></div></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，且<code>nginx</code>会作为<code>pid=1</code>进程。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 01:29 ?        00:00:00 nginx: master process nginx -g daemon off;
nginx         5      1  0 01:29 ?        00:00:00 nginx: worker process</code></pre></div><h3 id="情景三"><a href="#情景三" class="headerlink" title="情景三"></a>情景三</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginx
CMD [nginx -g daemon off;]</code></pre></div></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，但<code>nginx</code>不会作为<code>pid=1</code>进程。</p><p>因为<code>CMD</code>的<code>shell</code>模式实际会被理解成<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;nginx -g daemon off;&quot;]</code></p><p>其中<code>sh</code>所存在的进程会被作为第一个前台进程，进而<code>sh</code>的<code>pid=1</code>，执行内容为<code>nginx -g daemon off;</code>。</p><p>因为<code>sh</code>（<code>pid=1</code>）进程在启动<code>nginx</code>（<code>pid=5</code>）b这个子进程后会阻塞，直到<code>nginx</code>子进程退出返回，<code>sh</code>父进程才会继续往前走。而<code>nginx</code>是一个循环任务，它不会返回，所以<code>sh</code>进程会一直阻塞，不会结束。既然<code>pid=1</code>的进程一直都在，那么容器也不会退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 01:34 ?        00:00:00 &#x2F;bin&#x2F;sh -c nginx -g &#39;daemon off;&#39;
root          5      1  0 01:34 ?        00:00:00 nginx: master process nginx -g daemon off;
nginx         6      5  0 01:34 ?        00:00:00 nginx: worker process</code></pre></div><h3 id="情景四"><a href="#情景四" class="headerlink" title="情景四"></a>情景四</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginx
CMD [&quot;service&quot;, &quot;nginx&quot;, &quot;start&quot;]</code></pre></div></blockquote><p><code>nginx</code>应用不会正常启动且运行在后台。</p><p>因为<code>bash</code>执行了<code>service nginx start</code>这个瞬时命令后，继续向后。<code>service</code>进程结束，容器结束。</p><h3 id="情景五"><a href="#情景五" class="headerlink" title="情景五"></a>情景五</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginx
CMD [service nginx start]</code></pre></div></blockquote><p><code>nginx</code>应用不会正常启动且运行在后台。</p><p>因为<code>bash</code>执行了<code>sh -c service nginx start</code>这个瞬时命令，<code>sh</code>（<code>pid=1</code>）在执行<code>service</code>后结束。<code>sh</code>进程结束，容器结束。</p><blockquote><p>参考：</p><p><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p><p><a target="_blank" rel="noopener" href="https://github.com/nginxinc/docker-nginx/blob/master/Dockerfile-alpine.template">https://github.com/nginxinc/docker-nginx/blob/master/Dockerfile-alpine.template</a></p><p><a target="_blank" rel="noopener" href="https://pshizhsysu.gitbook.io/docker/dockerfile/qian-tai-yun-xing">https://pshizhsysu.gitbook.io/docker/dockerfile/qian-tai-yun-xing</a></p></blockquote></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">使用手册</a> <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="hover-with-bg" href="/categories/Docker/">Docker</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Docker/">Docker</a> <a class="hover-with-bg" href="/tags/Dockerfile/">Dockerfile</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/posts/f99bebc2/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Parallels虚拟机迁移问题记录</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/posts/9fba094f/"><span class="hidden-mobile">Linux查看公网IP</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-core.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/autoloader/prism-autoloader.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><script src="/js/boot.js"></script></body></html>