<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MacOS中Dock栏使用空白分隔</title>
    <link href="/2020/12/05/MacOS%E4%B8%ADDock%E6%A0%8F%E4%BD%BF%E7%94%A8%E7%A9%BA%E7%99%BD%E5%88%86%E9%9A%94-0/"/>
    <url>/2020/12/05/MacOS%E4%B8%ADDock%E6%A0%8F%E4%BD%BF%E7%94%A8%E7%A9%BA%E7%99%BD%E5%88%86%E9%9A%94-0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给Mac的Dock栏添加空白的图标用以分隔。</p></blockquote><h2 id="添加空白分割区"><a href="#添加空白分割区" class="headerlink" title="添加空白分割区"></a>添加空白分割区</h2><ul><li><p><strong>打开</strong><code>终端（Terminal.app）</code></p></li><li><p><strong>输入下列指令后，按回车键运行，空白区域就会添加到Dock中：</strong></p><pre><code class="hljs bash">defaults write com.apple.dock persistent-apps -array-add <span class="hljs-string">'&#123;"tile-type"="spacer-tile";&#125;'</span>; killall Dock</code></pre></li></ul><ul><li><strong>空白区域就是个透明图标，可以移动位置或拖离Dock栏，重复上方指令可添加多个</strong></li></ul><h2 id="只显示当前运行的应用"><a href="#只显示当前运行的应用" class="headerlink" title="只显示当前运行的应用"></a>只显示当前运行的应用</h2><ul><li><p><strong>打开</strong><code>终端（Terminal.app）</code></p></li><li><p><strong>输入下列指令后，按回车键运行，Dock栏只显示当前运行中的应用程序：</strong></p><pre><code class="hljs bash">defaults write com.apple.dock static-only -bool TRUE; killall Dock</code></pre></li></ul><ul><li><p><strong>想恢复原来状态，输入下列指令，按回车键运行即可：</strong></p><pre><code class="hljs bash">defaults write com.apple.dock static-only -bool FALSE; killall Dock</code></pre></li></ul><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/190175194" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/190175194</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>Dock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第二章:字符串和文本(2)</title>
    <link href="/2020/11/16/Python3-Cookbook%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC-2/"/>
    <url>/2020/11/16/Python3-Cookbook%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC-2/</url>
    
    <content type="html"><![CDATA[<h4 id="2-10-在正则式中使用Unicode"><a href="#2-10-在正则式中使用Unicode" class="headerlink" title="2.10 在正则式中使用Unicode"></a>2.10 在正则式中使用Unicode</h4><pre><code class="hljs python"><span class="hljs-comment"># 在正则式中使用Unicode</span><span class="hljs-string">""" </span><span class="hljs-string">你可以使用Unicode字符对应的转义序列(比如 \uFFF 或者 \UFFFFFFF )</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> rearabic = re.compile(<span class="hljs-string">'[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]+'</span>)</code></pre><h4 id="2-11-删除字符串中不需要的字符"><a href="#2-11-删除字符串中不需要的字符" class="headerlink" title="2.11 删除字符串中不需要的字符"></a>2.11 删除字符串中不需要的字符</h4><pre><code class="hljs python"><span class="hljs-comment"># 删除字符串中不需要的字符</span><span class="hljs-string">""" </span><span class="hljs-string">strip() 方法能用于删除开始或结尾的字符。 </span><span class="hljs-string">lstrip() 和 rstrip() 分别从左和从右执行删除操作。 </span><span class="hljs-string">默认情况下，这些方法会去除空白字符，但是你也可以指定其他字符。</span><span class="hljs-string">"""</span><span class="hljs-comment"># Whitespace stripping</span>s = <span class="hljs-string">' hello world \n'</span>s.strip()  <span class="hljs-comment"># 'hello world'</span>s.lstrip()  <span class="hljs-comment"># 'hello world \n'</span>s.rstrip()  <span class="hljs-comment"># ' hello world'</span><span class="hljs-comment"># Character stripping</span>t = <span class="hljs-string">'-----hello====='</span>t.lstrip(<span class="hljs-string">'-'</span>)  <span class="hljs-comment"># 'hello====='</span>t.strip(<span class="hljs-string">'-='</span>)  <span class="hljs-comment"># 'hello'</span></code></pre><h4 id="2-12-审查清理文本字符串"><a href="#2-12-审查清理文本字符串" class="headerlink" title="2.12 审查清理文本字符串"></a>2.12 审查清理文本字符串</h4><pre><code class="hljs python"><span class="hljs-comment"># 审查清理文本字符串</span><span class="hljs-string">""" </span><span class="hljs-string">除了使用str.upper() 和 str.lower()变换大小写格式。</span><span class="hljs-string">str.replace() 或者 re.sub() 可以进行简单的替换操作。</span><span class="hljs-string">还可以使用 str.translate() 方法，即自己创造映射之后进行替换。</span><span class="hljs-string">"""</span>s = <span class="hljs-string">'pýtĥöñ\fis\tawesome\r\n'</span>  <span class="hljs-comment"># 'pýtĥöñ\x0cis\tawesome\r\n'</span><span class="hljs-comment"># 映射</span>remap = &#123;ord(<span class="hljs-string">'\t'</span>): <span class="hljs-string">' '</span>, ord(<span class="hljs-string">'\f'</span>): <span class="hljs-string">' '</span>, ord(<span class="hljs-string">'\r'</span>): <span class="hljs-literal">None</span>&#125;<span class="hljs-comment"># 替换</span>a = s.translate(remap)  <span class="hljs-comment"># 'pýtĥöñ is awesome\n'</span></code></pre><h4 id="2-13-字符串对齐"><a href="#2-13-字符串对齐" class="headerlink" title="2.13 字符串对齐"></a>2.13 字符串对齐</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串对齐</span><span class="hljs-string">""" </span><span class="hljs-string">对于基本的字符串对齐操作，可以使用字符串的 ljust() , rjust() 和 center() 方法。</span><span class="hljs-string">所有这些方法都能接受一个可选的填充字符。</span><span class="hljs-string">"""</span>text = <span class="hljs-string">'Hello World'</span>text.ljust(<span class="hljs-number">20</span>)  <span class="hljs-comment"># 'Hello World         '</span>text.rjust(<span class="hljs-number">20</span>)  <span class="hljs-comment"># '         Hello World'</span>text.center(<span class="hljs-number">20</span>)  <span class="hljs-comment"># '    Hello World     '</span><span class="hljs-comment"># 有填充字符</span>text.rjust(<span class="hljs-number">20</span>, <span class="hljs-string">'='</span>)  <span class="hljs-comment"># '=========Hello World'</span>text.center(<span class="hljs-number">20</span>, <span class="hljs-string">'*'</span>)  <span class="hljs-comment"># '****Hello World*****'</span><span class="hljs-string">""" </span><span class="hljs-string">函数 format() 同样可以用来很容易的对齐字符串。 你要做的就是使用 &lt;,&gt; 或者 ^ 字符后面紧跟一个指定的宽度。</span><span class="hljs-string">"""</span>format(text, <span class="hljs-string">'&gt;20'</span>)  <span class="hljs-comment"># '         Hello World'</span>format(text, <span class="hljs-string">'&lt;20'</span>)  <span class="hljs-comment"># 'Hello World         '</span>format(text, <span class="hljs-string">'^20'</span>)  <span class="hljs-comment"># '    Hello World     '</span><span class="hljs-string">'&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;'</span>.format(<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'World'</span>)  <span class="hljs-comment"># '     Hello      World'</span><span class="hljs-comment"># 有填充字符</span>format(text, <span class="hljs-string">'=&gt;20s'</span>)  <span class="hljs-comment"># '=========Hello World'</span>format(text, <span class="hljs-string">'*^20s'</span>)  <span class="hljs-comment"># '****Hello World*****'</span></code></pre><h4 id="2-14-合并拼接字符串"><a href="#2-14-合并拼接字符串" class="headerlink" title="2.14 合并拼接字符串"></a>2.14 合并拼接字符串</h4><pre><code class="hljs python"><span class="hljs-comment"># 合并拼接字符串</span><span class="hljs-string">""" </span><span class="hljs-string">如果字符串在一个list里或者iterable中，使用join()</span><span class="hljs-string">"""</span>parts = [<span class="hljs-string">'Is'</span>, <span class="hljs-string">'Chicago'</span>, <span class="hljs-string">'Not'</span>, <span class="hljs-string">'Chicago?'</span>]<span class="hljs-string">' '</span>.join(parts)  <span class="hljs-comment"># 'Is Chicago Not Chicago?'</span><span class="hljs-string">','</span>.join(parts)  <span class="hljs-comment"># 'Is,Chicago,Not,Chicago?'</span><span class="hljs-string">''</span>.join(parts)  <span class="hljs-comment"># 'IsChicagoNotChicago?'</span><span class="hljs-comment"># 永远都不应该如下写</span>s = <span class="hljs-string">''</span><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> parts:    s += p<span class="hljs-comment"># 适当的时候可以使用生成器表达式</span><span class="hljs-string">','</span>.join(str(d) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data)<span class="hljs-comment"># 输出的时候没必要将字符串连接</span>print(a, b, c, sep=<span class="hljs-string">':'</span>)  <span class="hljs-comment"># Better</span></code></pre><h4 id="2-15-字符串中插入变量"><a href="#2-15-字符串中插入变量" class="headerlink" title="2.15 字符串中插入变量"></a>2.15 字符串中插入变量</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串中插入变量</span><span class="hljs-string">""" </span><span class="hljs-string">可以通过字符串的format()方法来解决。</span><span class="hljs-string">"""</span>s = <span class="hljs-string">'&#123;name&#125; has &#123;n&#125; messages.'</span>s.format(name=<span class="hljs-string">'Guido'</span>, n=<span class="hljs-number">37</span>)  <span class="hljs-comment"># 'Guido has 37 messages.'</span><span class="hljs-string">""" </span><span class="hljs-string">如果要被替换的变量能在变量域中找到， 那么你可以结合使用 format_map() 和 vars()。</span><span class="hljs-string">"""</span>name = <span class="hljs-string">'Guido'</span>n = <span class="hljs-number">37</span>s.format_map(vars())  <span class="hljs-comment"># 'Guido has 37 messages.'</span></code></pre><h4 id="2-16-以指定列宽格式化字符"><a href="#2-16-以指定列宽格式化字符" class="headerlink" title="2.16 以指定列宽格式化字符"></a>2.16 以指定列宽格式化字符</h4><pre><code class="hljs python"><span class="hljs-comment"># 以指定列宽格式化字符</span><span class="hljs-string">""" </span><span class="hljs-string">使用 textwrap 模块来格式化字符串的输出</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> textwraps = <span class="hljs-string">"Look into my eyes, look into my eyes, the eyes, the eyes, \</span><span class="hljs-string">the eyes, not around the eyes, don't look around the eyes, \</span><span class="hljs-string">look into my eyes, you're under."</span><span class="hljs-comment"># 输出以多少字符换行</span>print(textwrap.fill(s, <span class="hljs-number">70</span>))print(textwrap.fill(s, <span class="hljs-number">40</span>))<span class="hljs-comment"># 首行缩进</span>print(textwrap.fill(s, <span class="hljs-number">40</span>, initial_indent=<span class="hljs-string">'    '</span>))<span class="hljs-comment"># 次行及之后缩进</span>print(textwrap.fill(s, <span class="hljs-number">40</span>, subsequent_indent=<span class="hljs-string">'    '</span>))<span class="hljs-comment"># 获取终端大小尺寸</span>os.get_terminal_size().columns</code></pre><h4 id="2-17-在字符串中处理html和xml"><a href="#2-17-在字符串中处理html和xml" class="headerlink" title="2.17 在字符串中处理html和xml"></a>2.17 在字符串中处理html和xml</h4><pre><code class="hljs python"><span class="hljs-comment"># 在字符串中处理html和xml</span><span class="hljs-string">""" </span><span class="hljs-string">使用html模块中的函数</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> htmls = <span class="hljs-string">'Elements are written as "&lt;tag&gt;text&lt;/tag&gt;".'</span><span class="hljs-comment"># 替换字符串中的尖括号</span>print(html.escape(s))<span class="hljs-comment"># Elements are written as &amp;quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&amp;quot;.</span><span class="hljs-comment"># 将非ASCII文本对应的编码实体嵌入进去</span>s = <span class="hljs-string">'Spicy Jalapeño'</span>s.encode(<span class="hljs-string">'ascii'</span>, errors=<span class="hljs-string">'xmlcharrefreplace'</span>)<span class="hljs-comment"># b'Spicy Jalape&amp;#241;o'</span><span class="hljs-comment"># 使用HTML或者XML解析器的一些相关工具函数/方法</span>s = <span class="hljs-string">'Spicy &amp;quot;Jalape&amp;#241;o&amp;quot.'</span><span class="hljs-keyword">from</span> html.parser <span class="hljs-keyword">import</span> HTMLParserp = HTMLParser()p.unescape(s)<span class="hljs-comment"># 'Spicy "Jalapeño".'</span>t = <span class="hljs-string">'The prompt is &amp;gt;&amp;gt;&amp;gt;'</span><span class="hljs-keyword">from</span> xml.sax.saxutils <span class="hljs-keyword">import</span> unescapeunescape(t)<span class="hljs-comment"># 'The prompt is &gt;&gt;&gt;'</span></code></pre><h4 id="2-18-字符串令牌解析"><a href="#2-18-字符串令牌解析" class="headerlink" title="2.18 字符串令牌解析"></a>2.18 字符串令牌解析</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串令牌解析</span><span class="hljs-string">"""  </span><span class="hljs-string">模式对象scanner() 方法。 </span><span class="hljs-string">这个方法会创建一个 scanner 对象， 在这个对象上不断的调用 match() 方法会一步步的扫描目标文本，每步一个匹配。</span><span class="hljs-string">"""</span><span class="hljs-comment"># 想将t转换为tokens</span><span class="hljs-keyword">import</span> ret = <span class="hljs-string">'foo = 23 + 42 * 10'</span>tokens = [(<span class="hljs-string">'NAME'</span>, <span class="hljs-string">'foo'</span>), (<span class="hljs-string">'EQ'</span>, <span class="hljs-string">'='</span>), (<span class="hljs-string">'NUM'</span>, <span class="hljs-string">'23'</span>), (<span class="hljs-string">'PLUS'</span>, <span class="hljs-string">'+'</span>),          (<span class="hljs-string">'NUM'</span>, <span class="hljs-string">'42'</span>), (<span class="hljs-string">'TIMES'</span>, <span class="hljs-string">'*'</span>), (<span class="hljs-string">'NUM'</span>, <span class="hljs-string">'10'</span>)]NAME = <span class="hljs-string">r'(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'</span>NUM = <span class="hljs-string">r'(?P&lt;NUM&gt;\d+)'</span>PLUS = <span class="hljs-string">r'(?P&lt;PLUS&gt;\+)'</span>TIMES = <span class="hljs-string">r'(?P&lt;TIMES&gt;\*)'</span>EQ = <span class="hljs-string">r'(?P&lt;EQ&gt;=)'</span>WS = <span class="hljs-string">r'(?P&lt;WS&gt;\s+)'</span>master_pat = re.compile(<span class="hljs-string">'|'</span>.join([NAME, NUM, PLUS, TIMES, EQ, WS]))scanner = master_pat.scanner(<span class="hljs-string">'foo = 42'</span>)scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('NAME', 'foo')</span>scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('WS', ' ')</span>scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('EQ', '=')</span>scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('WS', ' ')</span>scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('NUM', '42')</span>scanner.match()</code></pre><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>使用手册</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第二章:字符串和文本(1)</title>
    <link href="/2020/11/14/Python3-Cookbook%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC-1/"/>
    <url>/2020/11/14/Python3-Cookbook%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC-1/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-使用多个界定符分割字符串"><a href="#2-1-使用多个界定符分割字符串" class="headerlink" title="2.1 使用多个界定符分割字符串"></a>2.1 使用多个界定符分割字符串</h4><pre><code class="hljs python"><span class="hljs-comment"># 使用多个界定符分割字符串</span><span class="hljs-string">""" </span><span class="hljs-string">string 对象的 split() 方法只适应于非常简单的字符串分割情形。</span><span class="hljs-string">re.split() 方法可以更加灵活的切割字符串。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> reline = <span class="hljs-string">'asdf fjdk; afed, fjek,asdf, foo'</span><span class="hljs-comment"># 表示可以通过;或,或空格或多个空格分隔</span>re.split(<span class="hljs-string">r'[;,\s]\s*'</span>, line)<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># ['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']</span></code></pre><h4 id="2-2-字符串开头或结尾匹配"><a href="#2-2-字符串开头或结尾匹配" class="headerlink" title="2.2 字符串开头或结尾匹配"></a>2.2 字符串开头或结尾匹配</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串开头或结尾匹配</span><span class="hljs-string">""" </span><span class="hljs-string">简单使用可以通过str.startswith() 或者是 str.endswith() 方法。</span><span class="hljs-string">如果需要多种匹配可以将匹配项作为元组（且必须是元组tuple()）传入上述方法。</span><span class="hljs-string">切片实现不优雅，正则实现较复杂，这种方式简单使用较方便。</span><span class="hljs-string">"""</span>filename = <span class="hljs-string">'spam.txt'</span>filename.endswith(<span class="hljs-string">'.txt'</span>)  <span class="hljs-comment"># True</span>filename.startswith(<span class="hljs-string">'file:'</span>)  <span class="hljs-comment"># False</span>url = <span class="hljs-string">'http://www.python.org'</span>url.startswith(<span class="hljs-string">'http:'</span>)  <span class="hljs-comment"># True</span>[name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> filenames <span class="hljs-keyword">if</span> name.endswith((<span class="hljs-string">'.c'</span>, <span class="hljs-string">'.h'</span>))]</code></pre><h4 id="2-3-用Shell通配符匹配字符串"><a href="#2-3-用Shell通配符匹配字符串" class="headerlink" title="2.3 用Shell通配符匹配字符串"></a>2.3 用Shell通配符匹配字符串</h4><pre><code class="hljs python"><span class="hljs-comment"># 用Shell通配符匹配字符串</span><span class="hljs-string">""" </span><span class="hljs-string">fnmatch 模块提供了两个函数—— fnmatch() 和 fnmatchcase() ，可以用来实现这样的匹配。</span><span class="hljs-string">fnmatch()大小写敏感根据系统不同而不尽相同。fnmatchcase()大小写敏感。</span><span class="hljs-string">功能强度介于字符串与正则之间。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> fnmatch <span class="hljs-keyword">import</span> fnmatch, fnmatchcasefnmatch(<span class="hljs-string">'foo.txt'</span>, <span class="hljs-string">'*.txt'</span>)  <span class="hljs-comment"># True</span>fnmatch(<span class="hljs-string">'foo.txt'</span>, <span class="hljs-string">'?oo.txt'</span>)  <span class="hljs-comment"># True</span>fnmatch(<span class="hljs-string">'Dat45.csv'</span>, <span class="hljs-string">'Dat[0-9]*'</span>)  <span class="hljs-comment"># True</span></code></pre><h4 id="2-4-字符串匹配和搜索"><a href="#2-4-字符串匹配和搜索" class="headerlink" title="2.4 字符串匹配和搜索"></a>2.4 字符串匹配和搜索</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串匹配和搜索</span><span class="hljs-string">""" </span><span class="hljs-string">str.find() , str.endswith() , str.startswith() 或者类似的方法可做简单匹配。</span><span class="hljs-string">复杂匹配可以使用re模块与正则表达式。表达式多次使用可以预编译为模式对象。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> retext1 = <span class="hljs-string">'11/27/2012'</span>text2 = <span class="hljs-string">'Nov 27, 2012'</span><span class="hljs-keyword">if</span> re.match(<span class="hljs-string">r'\d+/\d+/\d+'</span>, text1):    print(<span class="hljs-string">'yes'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'no'</span>)<span class="hljs-keyword">if</span> re.match(<span class="hljs-string">r'\d+/\d+/\d+'</span>, text2):    print(<span class="hljs-string">'yes'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'no'</span>)<span class="hljs-comment"># 预编译为模式对象</span><span class="hljs-comment"># 字符串前的r表示字符串为raw string，即不会转义。如果此处没有r需要双反斜杠阅读性差。</span>datepat = re.compile(<span class="hljs-string">r'\d+/\d+/\d+'</span>)<span class="hljs-keyword">if</span> datepat.match(text1):    print(<span class="hljs-string">'yes'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'no'</span>)<span class="hljs-string">""" </span><span class="hljs-string">match() 总是从字符串开始去匹配，如果你想查找字符串任意部分的模式出现位置， 使用 findall() 方法去代替。</span><span class="hljs-string">如果你想以迭代方式返回匹配，可以使用 finditer() 方法来代替。</span><span class="hljs-string">"""</span>text = <span class="hljs-string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span>datepat.findall(text)<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># ['11/27/2012', '3/13/2013']</span><span class="hljs-string">""" </span><span class="hljs-string">使用括号去捕获分组，分别将每个组的内容提取出来。</span><span class="hljs-string">"""</span>datepat = re.compile(<span class="hljs-string">r'(\d+)/(\d+)/(\d+)'</span>)m = datepat.match(<span class="hljs-string">'11/27/2012'</span>)<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x1005d2750&gt;</span>m.group(<span class="hljs-number">0</span>)  <span class="hljs-comment"># '11/27/2012'</span>m.group(<span class="hljs-number">1</span>)  <span class="hljs-comment"># '11'</span>m.group(<span class="hljs-number">2</span>)  <span class="hljs-comment"># '27'</span>m.group(<span class="hljs-number">3</span>)  <span class="hljs-comment"># '2012'</span>m.groups()  <span class="hljs-comment"># ('11', '27', '2012')</span><span class="hljs-comment"># Find all matches (notice splitting into tuples)</span>text = <span class="hljs-string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span>datepat.findall(text)[(<span class="hljs-string">'11'</span>, <span class="hljs-string">'27'</span>, <span class="hljs-string">'2012'</span>), (<span class="hljs-string">'3'</span>, <span class="hljs-string">'13'</span>, <span class="hljs-string">'2013'</span>)]<span class="hljs-keyword">for</span> month, day, year <span class="hljs-keyword">in</span> datepat.findall(text):    print(<span class="hljs-string">'&#123;&#125;-&#123;&#125;-&#123;&#125;'</span>.format(year, month, day))</code></pre><h4 id="2-5-字符串搜索和替换"><a href="#2-5-字符串搜索和替换" class="headerlink" title="2.5 字符串搜索和替换"></a>2.5 字符串搜索和替换</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串搜索和替换</span><span class="hljs-string">""" </span><span class="hljs-string">简单字面模式可以使用str.replace()。</span><span class="hljs-string">对于复杂的模式，请使用 re 模块中的 sub() 函数。</span><span class="hljs-string">"""</span><span class="hljs-comment"># str.replace()</span><span class="hljs-keyword">import</span> retext = <span class="hljs-string">'yeah, but no, but yeah, but no, but yeah'</span>text.replace(<span class="hljs-string">'yeah'</span>, <span class="hljs-string">'yep'</span>)<span class="hljs-comment"># 'yep, but no, but yep, but no, but yep'</span><span class="hljs-comment"># re.sub()</span>text = <span class="hljs-string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span>re.sub(<span class="hljs-string">r'(\d+)/(\d+)/(\d+)'</span>, <span class="hljs-string">r'\3-\1-\2'</span>, text)<span class="hljs-comment"># 'Today is 2012-11-27. PyCon starts 2013-3-13.'</span><span class="hljs-comment"># sub() 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \3 指向前面模式的捕获组号。</span><span class="hljs-comment"># 预编译</span>datepat = re.compile(<span class="hljs-string">r'(\d+)/(\d+)/(\d+)'</span>)datepat.sub(<span class="hljs-string">r'\3-\1-\2'</span>, text)</code></pre><h4 id="2-6-字符串忽略大小写的搜索替换"><a href="#2-6-字符串忽略大小写的搜索替换" class="headerlink" title="2.6 字符串忽略大小写的搜索替换"></a>2.6 字符串忽略大小写的搜索替换</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串忽略大小写的搜索替换</span><span class="hljs-string">""" </span><span class="hljs-string">为了在文本操作时忽略大小写，你需要在使用 re 模块的时候给这些操作提供 re.IGNORECASE 标志参数。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> retext = <span class="hljs-string">'UPPER PYTHON, lower python, Mixed Python'</span>re.findall(<span class="hljs-string">'python'</span>, text, flags=re.IGNORECASE)<span class="hljs-comment"># ['PYTHON', 'python', 'Python']</span>re.sub(<span class="hljs-string">'python'</span>, <span class="hljs-string">'snake'</span>, text, flags=re.IGNORECASE)<span class="hljs-comment"># 'UPPER snake, lower snake, Mixed snake'</span></code></pre><h4 id="2-7-最短模式匹配"><a href="#2-7-最短模式匹配" class="headerlink" title="2.7 最短模式匹配"></a>2.7 最短模式匹配</h4><pre><code class="hljs python"><span class="hljs-comment"># 最短模式匹配</span><span class="hljs-string">""" </span><span class="hljs-string">通过正则表达式的限定符?改变匹配的模式为最短匹配。</span><span class="hljs-string">"(.*)"表示最长匹配双引号内的内容。</span><span class="hljs-string">"(.*?)"表示最短匹配双引号内的内容。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> restr_pat = re.compile(<span class="hljs-string">r'"(.*)"'</span>)text1 = <span class="hljs-string">'Computer says "no."'</span>str_pat.findall(text1)<span class="hljs-comment"># ['no.']</span>text2 = <span class="hljs-string">'Computer says "no." Phone says "yes."'</span>str_pat.findall(text2)<span class="hljs-comment"># ['no." Phone says "yes.']</span>str_pat = re.compile(<span class="hljs-string">r'"(.*?)"'</span>)str_pat.findall(text2)<span class="hljs-comment"># ['no.', 'yes.']</span></code></pre><h4 id="2-8-多行匹配模式"><a href="#2-8-多行匹配模式" class="headerlink" title="2.8 多行匹配模式"></a>2.8 多行匹配模式</h4><pre><code class="hljs python"><span class="hljs-comment"># 多行匹配模式</span><span class="hljs-string">""" </span><span class="hljs-string">当你用点(.)去匹配任意字符的时候，发现点(.)不能匹配换行符的事实。</span><span class="hljs-string">其中一种场景就是匹配C语言的跨行注释。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> re<span class="hljs-comment"># 该模式对象只能匹配未换行的注释</span>comment = re.compile(<span class="hljs-string">r'/\*(.*?)\*/'</span>)<span class="hljs-comment"># 修改模式增加对换行的支持</span><span class="hljs-comment"># (?:.|*?)中，?:表示匹配但不获取(非捕获组)，|表示或关系，*？表示任意数量但最短匹配</span>comment = re.compile(<span class="hljs-string">r'/\*((?:.|\n)*?)\*/'</span>)</code></pre><h4 id="2-9-将Unicode文本标准化"><a href="#2-9-将Unicode文本标准化" class="headerlink" title="2.9 将Unicode文本标准化"></a>2.9 将Unicode文本标准化</h4><pre><code class="hljs python"><span class="hljs-comment"># 将Unicode文本标准化</span><span class="hljs-string">""" </span><span class="hljs-string">使用unicodedata模块将文本标准化</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> unicodedatas1 = <span class="hljs-string">'Spicy Jalape\u00f1o'</span>  <span class="hljs-comment"># 'Spicy Jalapeño'</span>s2 = <span class="hljs-string">'Spicy Jalapen\u0303o'</span>  <span class="hljs-comment"># 'Spicy Jalapeño'</span>s1 == s2  <span class="hljs-comment"># False</span>t1 = unicodedata.normalize(<span class="hljs-string">'NFC'</span>, s1)t2 = unicodedata.normalize(<span class="hljs-string">'NFC'</span>, s2)t1 == t2  <span class="hljs-comment"># True</span></code></pre><h4><a href="#" class="headerlink"></a></h4><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>使用手册</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第一章:数据结构和算法(2)</title>
    <link href="/2020/11/07/Python3-Cookbook%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-2/"/>
    <url>/2020/11/07/Python3-Cookbook%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-2/</url>
    
    <content type="html"><![CDATA[<h4 id="1-11-命名切片"><a href="#1-11-命名切片" class="headerlink" title="1.11 命名切片"></a>1.11 命名切片</h4><pre><code class="hljs python"><span class="hljs-comment"># 命名切片</span><span class="hljs-comment"># 假定你要从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段</span><span class="hljs-comment"># 与其</span>record = <span class="hljs-string">'....................100 .......513.25 ..........'</span>cost = int(record[<span class="hljs-number">20</span>:<span class="hljs-number">23</span>]) * float(record[<span class="hljs-number">31</span>:<span class="hljs-number">37</span>])<span class="hljs-comment"># 不如</span>SHARES = slice(<span class="hljs-number">20</span>, <span class="hljs-number">23</span>)PRICE = slice(<span class="hljs-number">31</span>, <span class="hljs-number">37</span>)cost = int(record[SHARES]) * float(record[PRICE])</code></pre><h4 id="1-12-序列中出现次数最多的元素"><a href="#1-12-序列中出现次数最多的元素" class="headerlink" title="1.12 序列中出现次数最多的元素"></a>1.12 序列中出现次数最多的元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 序列中出现次数最多的元素</span><span class="hljs-string">""" </span><span class="hljs-string">collections.Counter 类就是专门为这类问题而设计的， 它甚至有一个有用的 most_common() 方法直接给了你答案。</span><span class="hljs-string">"""</span><span class="hljs-comment"># 取出出现频率最高的单词</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counterwords = [    <span class="hljs-string">'look'</span>, <span class="hljs-string">'into'</span>, <span class="hljs-string">'my'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'look'</span>, <span class="hljs-string">'into'</span>, <span class="hljs-string">'my'</span>, <span class="hljs-string">'eyes'</span>,    <span class="hljs-string">'the'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'not'</span>, <span class="hljs-string">'around'</span>, <span class="hljs-string">'the'</span>,    <span class="hljs-string">'eyes'</span>, <span class="hljs-string">"don't"</span>, <span class="hljs-string">'look'</span>, <span class="hljs-string">'around'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'look'</span>, <span class="hljs-string">'into'</span>,    <span class="hljs-string">'my'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">"you're"</span>, <span class="hljs-string">'under'</span>]word_counts = Counter(words)<span class="hljs-comment"># 出现频率最高的3个单词</span>top_three = word_counts.most_common(<span class="hljs-number">3</span>)print(top_three)<span class="hljs-comment"># Outputs [('eyes', 8), ('the', 5), ('look', 4)]</span><span class="hljs-string">""" </span><span class="hljs-string">collections.Counter底层实际上是一个元素作为key，出现次数作为value的dict。</span><span class="hljs-string">神奇的是还能进行数学运算操作结合。</span><span class="hljs-string">"""</span>morewords = [<span class="hljs-string">'why'</span>,<span class="hljs-string">'are'</span>,<span class="hljs-string">'you'</span>,<span class="hljs-string">'not'</span>,<span class="hljs-string">'looking'</span>,<span class="hljs-string">'in'</span>,<span class="hljs-string">'my'</span>,<span class="hljs-string">'eyes'</span>]a = Counter(words)b = Counter(morewords)a<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># Counter(&#123;'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,"you're": 1, "don't": 1, 'under': 1, 'not': 1&#125;)</span>b<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># Counter(&#123;'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,'my': 1, 'why': 1&#125;)</span><span class="hljs-comment"># Combine counts</span>c = a + bc<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># Counter(&#123;'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,'around': 2, "you're": 1, "don't": 1, 'in': 1, 'why': 1,'looking': 1, 'are': 1, 'under': 1,'you': 1&#125;)</span><span class="hljs-comment"># Subtract counts</span>d = a - bd<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># Counter(&#123;'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,"you're": 1, "don't": 1, 'under': 1&#125;)</span></code></pre><h4 id="1-13-通过某个关键字排序一个字典列表"><a href="#1-13-通过某个关键字排序一个字典列表" class="headerlink" title="1.13 通过某个关键字排序一个字典列表"></a>1.13 通过某个关键字排序一个字典列表</h4><pre><code class="hljs python"><span class="hljs-comment"># 通过某个关键字排序一个字典列表</span><span class="hljs-string">""" </span><span class="hljs-string">使用 operator 模块的 itemgetter 函数。</span><span class="hljs-string">排序过程中，相当于key使用的itemgetter获取到了dict中对应key的value进行排序。</span><span class="hljs-string">itemgetter同时支持多个keys。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetterrows = [    &#123;<span class="hljs-string">'fname'</span>: <span class="hljs-string">'Brian'</span>, <span class="hljs-string">'lname'</span>: <span class="hljs-string">'Jones'</span>, <span class="hljs-string">'uid'</span>: <span class="hljs-number">1003</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>: <span class="hljs-string">'David'</span>, <span class="hljs-string">'lname'</span>: <span class="hljs-string">'Beazley'</span>, <span class="hljs-string">'uid'</span>: <span class="hljs-number">1002</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>: <span class="hljs-string">'John'</span>, <span class="hljs-string">'lname'</span>: <span class="hljs-string">'Cleese'</span>, <span class="hljs-string">'uid'</span>: <span class="hljs-number">1001</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>: <span class="hljs-string">'Big'</span>, <span class="hljs-string">'lname'</span>: <span class="hljs-string">'Jones'</span>, <span class="hljs-string">'uid'</span>: <span class="hljs-number">1004</span>&#125;]rows_by_fname = sorted(rows, key=itemgetter(<span class="hljs-string">'fname'</span>))rows_by_uid = sorted(rows, key=itemgetter(<span class="hljs-string">'uid'</span>))print(rows_by_fname)print(rows_by_uid)rows_by_lfname = sorted(rows, key=itemgetter(<span class="hljs-string">'lname'</span>, <span class="hljs-string">'fname'</span>))print(rows_by_lfname)<span class="hljs-string">""" </span><span class="hljs-string">在上面例子中， rows 被传递给接受一个关键字参数的 sorted() 内置函数。 </span><span class="hljs-string">这个参数是 callable 类型，并且从 rows 中接受一个单一元素，然后返回被用来排序的值。</span><span class="hljs-string">itemgetter() 函数就是负责创建这个 callable 对象的。</span><span class="hljs-string">本例中的操作基本等同于key中使用lambda定义，但是效率更高。同样适用于max，min等。</span><span class="hljs-string">"""</span>rows_by_fname = sorted(rows, key=<span class="hljs-keyword">lambda</span> r: r[<span class="hljs-string">'fname'</span>])rows_by_lfname = sorted(rows, key=<span class="hljs-keyword">lambda</span> r: (r[<span class="hljs-string">'lname'</span>], r[<span class="hljs-string">'fname'</span>]))</code></pre><h4 id="1-14-排序不支持原生比较的对象"><a href="#1-14-排序不支持原生比较的对象" class="headerlink" title="1.14 排序不支持原生比较的对象"></a>1.14 排序不支持原生比较的对象</h4><pre><code class="hljs python"><span class="hljs-comment"># 排序不支持原生比较的对象</span><span class="hljs-string">""" </span><span class="hljs-string">关键在于传入callable的key参数时，获取到非原生对象的具体变量。</span><span class="hljs-string">可以通过lambda或者operator中的attrgetter。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> attrgetter<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, user_id)</span>:</span>        self.user_id = user_id    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'User(&#123;&#125;)'</span>.format(self.user_id)users = [User(<span class="hljs-number">23</span>), User(<span class="hljs-number">3</span>), User(<span class="hljs-number">99</span>)]<span class="hljs-comment"># Method 1</span>print(sorted(users, key=<span class="hljs-keyword">lambda</span> u: u.user_id))<span class="hljs-comment"># Method 2</span>print(sorted(users, key=attrgetter(<span class="hljs-string">'user_id'</span>)))</code></pre><h4 id="1-15-通过某个字段将记录分组"><a href="#1-15-通过某个字段将记录分组" class="headerlink" title="1.15 通过某个字段将记录分组"></a>1.15 通过某个字段将记录分组</h4><pre><code class="hljs python"><span class="hljs-comment"># 通过某个字段将记录分组</span><span class="hljs-string">""" </span><span class="hljs-string">使用itertools.groupby()函数，务必记得需要先排序</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> groupby<span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetterrows = [    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'5412 N CLARK'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/01/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'5148 N CLARK'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/04/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'5800 E 58TH'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'2122 N CLARK'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/03/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'5645 N RAVENSWOOD'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'1060 W ADDISON'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'4801 N BROADWAY'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/01/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'1039 W GRANVILLE'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/04/2012'</span>&#125;,]<span class="hljs-comment"># 需要预先按照想要分组的item排序</span>rows.sort(key=itemgetter(<span class="hljs-string">'date'</span>))<span class="hljs-comment"># 分组</span><span class="hljs-keyword">for</span> date, items <span class="hljs-keyword">in</span> groupby(rows, key=itemgetter(<span class="hljs-string">'date'</span>)):    print(date)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items:        print(<span class="hljs-string">' '</span>, i)<span class="hljs-string">""" 输出结果</span><span class="hljs-string">07/01/2012</span><span class="hljs-string">  &#123;'date': '07/01/2012', 'address': '5412 N CLARK'&#125;</span><span class="hljs-string">  &#123;'date': '07/01/2012', 'address': '4801 N BROADWAY'&#125;</span><span class="hljs-string">07/02/2012</span><span class="hljs-string">  &#123;'date': '07/02/2012', 'address': '5800 E 58TH'&#125;</span><span class="hljs-string">  &#123;'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'&#125;</span><span class="hljs-string">  &#123;'date': '07/02/2012', 'address': '1060 W ADDISON'&#125;</span><span class="hljs-string">07/03/2012</span><span class="hljs-string">  &#123;'date': '07/03/2012', 'address': '2122 N CLARK'&#125;</span><span class="hljs-string">07/04/2012</span><span class="hljs-string">  &#123;'date': '07/04/2012', 'address': '5148 N CLARK'&#125;</span><span class="hljs-string">  &#123;'date': '07/04/2012', 'address': '1039 W GRANVILLE'&#125;</span><span class="hljs-string">"""</span><span class="hljs-string">""" </span><span class="hljs-string">如果需要保持序列顺序，则可以通过1-6中的defaultdict，将想要分组的item作为其中的key，然后将整条记录append到对应item的组别中。</span><span class="hljs-string">"""</span>rows_by_date = defaultdict(list)<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    rows_by_date[row[<span class="hljs-string">'date'</span>]].append(row)</code></pre><h4 id="1-16-过滤序列元素"><a href="#1-16-过滤序列元素" class="headerlink" title="1.16 过滤序列元素"></a>1.16 过滤序列元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 过滤序列元素</span><span class="hljs-string">""" </span><span class="hljs-string">可通过列表推导式达到目的，好处是同时还能充当简单的数据住转换。但是当元素结果集很大时则很占内存。</span><span class="hljs-string">可以将过滤代码放到一个函数中， 然后使用内建的 filter() 函数。</span><span class="hljs-string">"""</span><span class="hljs-comment"># filter得到的是一个迭代器，如果想得到列表还需要进行list()转换</span>values = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'-3'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'N/A'</span>, <span class="hljs-string">'5'</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_int</span><span class="hljs-params">(val)</span>:</span>    <span class="hljs-keyword">try</span>:        x = int(val)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">except</span> ValueError:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>ivals = list(filter(is_int, values))print(ivals)<span class="hljs-comment"># Outputs ['1', '2', '-3', '4', '5']</span><span class="hljs-string">""" </span><span class="hljs-string">列表推导式</span><span class="hljs-string">1. [i for i in range(k) if condition]：此时if起条件判断作用，满足条件的，将被返回成为最终生成的列表的一员。</span><span class="hljs-string">2. [i if condition else exp for exp]：此时if...else被用来赋值，满足条件的i以及else被用来生成最终的列表。</span><span class="hljs-string">"""</span>print([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>])print([i <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)])<span class="hljs-comment"># Outputs</span>[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>][<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>]</code></pre><h4 id="1-17-从字典中提取子集"><a href="#1-17-从字典中提取子集" class="headerlink" title="1.17 从字典中提取子集"></a>1.17 从字典中提取子集</h4><pre><code class="hljs python"><span class="hljs-comment"># 从字典中提取子集</span><span class="hljs-comment"># 使用字典推导</span>prices = &#123;    <span class="hljs-string">'ACME'</span>: <span class="hljs-number">45.23</span>,    <span class="hljs-string">'AAPL'</span>: <span class="hljs-number">612.78</span>,    <span class="hljs-string">'IBM'</span>: <span class="hljs-number">205.55</span>,    <span class="hljs-string">'HPQ'</span>: <span class="hljs-number">37.20</span>,    <span class="hljs-string">'FB'</span>: <span class="hljs-number">10.75</span>&#125;<span class="hljs-comment"># 取出value大于200的</span>p1 = &#123;key: value <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> prices.items() <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">200</span>&#125;<span class="hljs-comment"># 取出在name列表中的键值对</span>tech_names = &#123;<span class="hljs-string">'AAPL'</span>, <span class="hljs-string">'IBM'</span>, <span class="hljs-string">'HPQ'</span>, <span class="hljs-string">'MSFT'</span>&#125;p2 = &#123;key: value <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> prices.items() <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> tech_names&#125;</code></pre><h4 id="1-18-映射名称到序列元素"><a href="#1-18-映射名称到序列元素" class="headerlink" title="1.18 映射名称到序列元素"></a>1.18 映射名称到序列元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 映射名称到序列元素</span><span class="hljs-string">""" </span><span class="hljs-string">使用collections.namedtuple()，函数使用即在初始化的时候传入一个类型名与需要的下标字段。</span><span class="hljs-string">通过使用下标对元组中的内容进行组合操作会表意不清晰。</span><span class="hljs-string">命名元组与字典功能很接近，但是要更节省内存。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtupleSubscriber = namedtuple(<span class="hljs-string">'Subscriber'</span>, [<span class="hljs-string">'addr'</span>, <span class="hljs-string">'joined'</span>])sub = Subscriber(<span class="hljs-string">'jonesy@example.com'</span>, <span class="hljs-string">'2012-10-19'</span>)print(sub)  <span class="hljs-comment"># Subscriber(addr='jonesy@example.com', joined='2012-10-19')</span>print(sub.addr)  <span class="hljs-comment"># jonesy@example.com</span>print(sub.joined)  <span class="hljs-comment"># 2012-10-19</span><span class="hljs-comment"># 举例使用，在命名元组中使用下标。</span><span class="hljs-comment"># 实际上本身对records中的每条记录内容都知道是什么，只是为了表意清楚，使用有名字的下标进行计算。</span>Stock = namedtuple(<span class="hljs-string">'Stock'</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>])<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_cost</span><span class="hljs-params">(records)</span>:</span>    total = <span class="hljs-number">0.0</span>    <span class="hljs-keyword">for</span> rec <span class="hljs-keyword">in</span> records:        s = Stock(*rec)        total += s.shares * s.price    <span class="hljs-keyword">return</span> total</code></pre><h4 id="1-19-转换并同时计算数据"><a href="#1-19-转换并同时计算数据" class="headerlink" title="1.19 转换并同时计算数据"></a>1.19 转换并同时计算数据</h4><pre><code class="hljs python"><span class="hljs-comment"># 转换并同时计算数据</span><span class="hljs-string">""" </span><span class="hljs-string">练习使用生成器表达式参数</span><span class="hljs-string">"""</span><span class="hljs-comment"># 计算平方和</span><span class="hljs-keyword">import</span> osnums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]s = sum(x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums)<span class="hljs-comment"># 查看文件夹中是否包含.py后缀文件</span>files = os.listdir(<span class="hljs-string">'dirname'</span>)<span class="hljs-keyword">if</span> any(name.endswith(<span class="hljs-string">'.py'</span>) <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> files):    print(<span class="hljs-string">'There be python!'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'Sorry, no python.'</span>)<span class="hljs-comment"># 计算字典列表中某个key最小的value</span>portfolio = [    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'GOOG'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">50</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'YHOO'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">75</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'AOL'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">20</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'SCOX'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">65</span>&#125;]min_shares = min(s[<span class="hljs-string">'shares'</span>] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> portfolio)<span class="hljs-comment"># 对于min() 和 max() 它们接受的一个 key 关键字参数或许对你很有帮助</span></code></pre><h4 id="1-20-合并多个字典或映射"><a href="#1-20-合并多个字典或映射" class="headerlink" title="1.20 合并多个字典或映射"></a>1.20 合并多个字典或映射</h4><pre><code class="hljs python"><span class="hljs-comment"># 合并多个字典或映射</span><span class="hljs-string">""" </span><span class="hljs-string">使用collections 模块中的 ChainMap 类</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMapa = &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">3</span>&#125;b = &#123;<span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">4</span>&#125;c = ChainMap(a, b)  <span class="hljs-comment"># 先从a找，再从b找</span>print(c[<span class="hljs-string">'x'</span>])  <span class="hljs-comment"># Outputs 1 (from a)</span>print(c[<span class="hljs-string">'y'</span>])  <span class="hljs-comment"># Outputs 2 (from b)</span>print(c[<span class="hljs-string">'z'</span>])  <span class="hljs-comment"># Outputs 3 (from a)</span><span class="hljs-string">""" </span><span class="hljs-string">通过这种操作的字典并不是真正的合并了，只是内部创建了容纳这些字典的列表，大部分字典操作可以正常使用。</span><span class="hljs-string">对于新字典的更新与删除会影响列表中的第一个字典。而使用update()方法，原字典的更新不会影响到新的合并字典。</span><span class="hljs-string">"""</span>a = &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">3</span>&#125;b = &#123;<span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">4</span>&#125;merged = dict(b)merged.update(a)merged[<span class="hljs-string">'x'</span>]  <span class="hljs-comment"># 1</span>merged[<span class="hljs-string">'y'</span>]  <span class="hljs-comment"># 2</span>merged[<span class="hljs-string">'z'</span>]  <span class="hljs-comment"># 3</span>a[<span class="hljs-string">'x'</span>] = <span class="hljs-number">13</span>merged[<span class="hljs-string">'x'</span>]  <span class="hljs-comment"># 1</span></code></pre><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>使用手册</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第一章:数据结构和算法(1)</title>
    <link href="/2020/11/05/Python3-Cookbook%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-1/"/>
    <url>/2020/11/05/Python3-Cookbook%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于<strong>《Python Cookbook》</strong>一书进行学习，通过书中部分代码注释与自己的理解写成笔记方便学习与回忆。</p></blockquote><h4 id="1-1-解压序列赋值给多个变量"><a href="#1-1-解压序列赋值给多个变量" class="headerlink" title="1.1 解压序列赋值给多个变量"></a>1.1 解压序列赋值给多个变量</h4><pre><code class="hljs python"><span class="hljs-comment"># 解压序列赋值给多个变量</span>data = [<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>, (<span class="hljs-number">2012</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>)]name, shares, price, date = dataprint(<span class="hljs-string">"name: &#123;&#125;"</span>.format(name))  <span class="hljs-comment"># Prints name: ACME</span>print(<span class="hljs-string">"shares: &#123;&#125;"</span>.format(shares))  <span class="hljs-comment"># Prints shares: 50</span>print(<span class="hljs-string">"price: &#123;&#125;"</span>.format(price))  <span class="hljs-comment"># Prints price: 91.1</span>print(<span class="hljs-string">"data: &#123;&#125;"</span>.format(data))  <span class="hljs-comment"># Prints data: ['ACME', 50, 91.1, (2012, 12, 21)]</span><span class="hljs-comment"># 不需要的变量用占位符取代，最后丢弃即可</span>name, _, _, date = data<span class="hljs-comment"># 字符串也可通过此种方式取值</span>s = <span class="hljs-string">"hello"</span>a, b, c, d, e = sprint(<span class="hljs-string">"c: &#123;&#125;"</span>.format(c))  <span class="hljs-comment"># Prints c: l</span></code></pre><h4 id="1-2-解压可迭代对象赋值给多个变量"><a href="#1-2-解压可迭代对象赋值给多个变量" class="headerlink" title="1.2 解压可迭代对象赋值给多个变量"></a>1.2 解压可迭代对象赋值给多个变量</h4><pre><code class="hljs python"><span class="hljs-comment"># 解压可迭代对象赋值给多个变量</span><span class="hljs-comment"># 1-1中如果item数量需要确定的去取</span><span class="hljs-string">""" </span><span class="hljs-string">Python中的星号键不是指针，代表取一个不定长的list；同样两个星号代表取一个不定长的dict </span><span class="hljs-string">"""</span>record = (<span class="hljs-string">'Dave'</span>, <span class="hljs-string">'dave@example.com'</span>, <span class="hljs-string">'773-555-1212'</span>, <span class="hljs-string">'847-555-1212'</span>)name, email, *number = recordprint(<span class="hljs-string">"name: &#123;&#125;"</span>.format(name))  <span class="hljs-comment"># Prints name: Dave</span>print(<span class="hljs-string">"email: &#123;&#125;"</span>.format(email))  <span class="hljs-comment"># Prints email: dave@example.com</span>print(<span class="hljs-string">"number: &#123;&#125;"</span>.format(number))  <span class="hljs-comment"># Prints number: ['773-555-1212', '847-555-1212']</span><span class="hljs-comment"># 用此种方法可以轻易取list中的第一个元素与最后一个元素</span>record = (<span class="hljs-string">'Dave'</span>, <span class="hljs-string">'dave@example.com'</span>, <span class="hljs-string">'773-555-1212'</span>, <span class="hljs-string">'847-555-1212'</span>, <span class="hljs-string">'boss11'</span>)name, *_ = record*_, stuff = record<span class="hljs-comment"># 同样此方法可以用来获取不确定的参数，用以函数传参等</span>records = [(<span class="hljs-string">'foo'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">'bar'</span>, <span class="hljs-string">'hello'</span>), (<span class="hljs-string">'foo'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), ]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_foo</span><span class="hljs-params">(x, y)</span>:</span>    print(<span class="hljs-string">'foo'</span>, x, y)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_bar</span><span class="hljs-params">(s)</span>:</span>    print(<span class="hljs-string">'bar'</span>, s)<span class="hljs-keyword">for</span> tag, *args <span class="hljs-keyword">in</span> records:    <span class="hljs-keyword">if</span> tag == <span class="hljs-string">'foo'</span>:        do_foo(*args)    <span class="hljs-keyword">elif</span> tag == <span class="hljs-string">'bar'</span>:        do_bar(*args)<span class="hljs-comment"># Prints </span><span class="hljs-comment"># foo 1 2</span><span class="hljs-comment"># bar hello</span><span class="hljs-comment"># foo 3 4</span></code></pre><h4 id="1-3-保留最后N个元素"><a href="#1-3-保留最后N个元素" class="headerlink" title="1.3 保留最后N个元素"></a>1.3 保留最后N个元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 保留最后N个元素</span><span class="hljs-string">""" </span><span class="hljs-string">使用collections.deque即可完成该操作，deque是一个可以设置长度的双端队列。</span><span class="hljs-string">具有append(),appendleft(),pop(),popleft()。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> dequeq = deque(maxlen=<span class="hljs-number">3</span>)q.append(<span class="hljs-number">1</span>)q.append(<span class="hljs-number">2</span>)q.append(<span class="hljs-number">3</span>)print(q)  <span class="hljs-comment"># Prints deque([1, 2, 3], maxlen=3)</span>q.append(<span class="hljs-number">4</span>)print(q)  <span class="hljs-comment"># Prints deque([2, 3, 4], maxlen=3)</span><span class="hljs-comment"># 不指定大小则获得一个无限长度的双端队列</span>q = deque()q.append(<span class="hljs-number">1</span>)q.append(<span class="hljs-number">2</span>)q.append(<span class="hljs-number">3</span>)print(q)  <span class="hljs-comment"># Prints deque([1, 2, 3])</span>q.appendleft(<span class="hljs-number">4</span>)print(q)  <span class="hljs-comment"># Prints deque([4, 1, 2, 3])</span>print(q.pop())  <span class="hljs-comment"># Prints 3</span>print(q.popleft())  <span class="hljs-comment"># Prints 4</span><span class="hljs-comment"># 举例：保留文件中包含python字样的最后五行数据</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(lines, pattern, history=<span class="hljs-number">5</span>)</span>:</span>    previous_lines = deque(maxlen=history)    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:        <span class="hljs-keyword">if</span> pattern <span class="hljs-keyword">in</span> line:            <span class="hljs-keyword">yield</span> line, previous_lines        previous_lines.append(line)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    <span class="hljs-keyword">with</span> open(<span class="hljs-string">r'./somefile.txt'</span>) <span class="hljs-keyword">as</span> f:        <span class="hljs-keyword">for</span> line, prevlines <span class="hljs-keyword">in</span> search(f, <span class="hljs-string">'python'</span>, <span class="hljs-number">5</span>):            <span class="hljs-keyword">for</span> pline <span class="hljs-keyword">in</span> prevlines:                print(pline, end=<span class="hljs-string">''</span>)                print(line, end=<span class="hljs-string">''</span>)                print(<span class="hljs-string">'-'</span> * <span class="hljs-number">20</span>)</code></pre><h4 id="1-4-查找最大最小的N个元素"><a href="#1-4-查找最大最小的N个元素" class="headerlink" title="1.4 查找最大最小的N个元素"></a>1.4 查找最大最小的N个元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 查找最大最小的N个元素</span><span class="hljs-string">""" </span><span class="hljs-string">heapq 模块有两个函数：nlargest() 和 nsmallest() 可以进行输出</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> heapqnums = [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">23</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">18</span>, <span class="hljs-number">23</span>, <span class="hljs-number">42</span>, <span class="hljs-number">37</span>, <span class="hljs-number">2</span>]print(heapq.nlargest(<span class="hljs-number">3</span>, nums))  <span class="hljs-comment"># Prints [42, 37, 23]</span>print(heapq.nsmallest(<span class="hljs-number">3</span>, nums))  <span class="hljs-comment"># Prints [-4, 1, 2]</span><span class="hljs-comment"># 同时支持复杂的数据结构的排序,需要传入一个key函数</span>portfolio = [    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'IBM'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">100</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">91.1</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'AAPL'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">50</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">543.22</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'FB'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">200</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">21.09</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'HPQ'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">35</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">31.75</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'YHOO'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">45</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">16.35</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'ACME'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">75</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">115.65</span>&#125;]cheap = heapq.nsmallest(<span class="hljs-number">3</span>, portfolio, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-string">'price'</span>])expensive = heapq.nlargest(<span class="hljs-number">3</span>, portfolio, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-string">'price'</span>])<span class="hljs-comment"># 使用heapq.heapify对list进行处理</span>heap = list(nums)heapq.heapify(heap)  <span class="hljs-comment"># 对heap进行排序</span>heapq.heappop(heap)  <span class="hljs-comment"># 弹出heap最下的元素，根据堆的性质每次都会弹出最小</span></code></pre><h4 id="1-5-优先级队列"><a href="#1-5-优先级队列" class="headerlink" title="1.5 优先级队列"></a>1.5 优先级队列</h4><pre><code class="hljs python"><span class="hljs-comment"># 优先级队列，与一个元组顺序比较的小问题</span><span class="hljs-string">""" </span><span class="hljs-string">利用1-4中的heapq堆，将优先级的负数传入，根据heapq每次会pop最小值的属性，从而每次pop出优先级最高的item（同样优先级的元素按照插入顺序输出）</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> heapq<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self._queue = []        self._index = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, item, priority)</span>:</span>        heapq.heappush(self._queue, (-priority, self._index, item))        self._index += <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> heapq.heappop(self._queue)[<span class="hljs-number">-1</span>]<span class="hljs-string">""" </span><span class="hljs-string">其中index变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的index下标变量，可以确保元素按照它们插入的顺序排序。 </span><span class="hljs-string">而且index变量也在相同优先级元素比较的时候起到重要作用。 </span><span class="hljs-string">"""</span><span class="hljs-comment"># 展示另一个多元组大小比较的问题，多元组是依次比较同位置的元素，上例中的index就是避免了对比错误</span>a = (<span class="hljs-number">1</span>, Item(<span class="hljs-string">'foo'</span>))b = (<span class="hljs-number">5</span>, Item(<span class="hljs-string">'bar'</span>))a &lt; b  <span class="hljs-comment"># Print True</span>c = (<span class="hljs-number">1</span>, Item(<span class="hljs-string">'grok'</span>))a &lt; c  <span class="hljs-comment"># Print TypeError</span></code></pre><h4 id="1-6-字典中的键映射多个值"><a href="#1-6-字典中的键映射多个值" class="headerlink" title="1.6 字典中的键映射多个值"></a>1.6 字典中的键映射多个值</h4><pre><code class="hljs python"><span class="hljs-comment"># 字典中的键映射多个值</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdictd = defaultdict(list)d[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">1</span>)d[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">2</span>)d[<span class="hljs-string">'b'</span>].append(<span class="hljs-number">4</span>)d = defaultdict(set)d[<span class="hljs-string">'a'</span>].add(<span class="hljs-number">1</span>)d[<span class="hljs-string">'a'</span>].add(<span class="hljs-number">2</span>)d[<span class="hljs-string">'b'</span>].add(<span class="hljs-number">4</span>)<span class="hljs-string">""" </span><span class="hljs-string">元组tuple(),不可变有序</span><span class="hljs-string">列表list[],可变有序</span><span class="hljs-string">字典dict&#123;key:value&#125;,存键值对无序</span><span class="hljs-string">集合set&#123;&#125;,无重复无序</span><span class="hljs-string">"""</span></code></pre><h4 id="1-7-字典排序"><a href="#1-7-字典排序" class="headerlink" title="1.7 字典排序"></a>1.7 字典排序</h4><pre><code class="hljs python"><span class="hljs-comment"># 字典排序</span><span class="hljs-string">""" </span><span class="hljs-string">collections中的OrderedDict可以按照键值对插入字典的顺序存储dict</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDictd = OrderedDict()d[<span class="hljs-string">'foo'</span>] = <span class="hljs-number">1</span>d[<span class="hljs-string">'bar'</span>] = <span class="hljs-number">2</span>d[<span class="hljs-string">'spam'</span>] = <span class="hljs-number">3</span>d[<span class="hljs-string">'grok'</span>] = <span class="hljs-number">4</span><span class="hljs-comment"># Outputs "foo 1", "bar 2", "spam 3", "grok 4"</span><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:    print(key, d[key])<span class="hljs-string">""" </span><span class="hljs-string">Python sorted() 函数</span><span class="hljs-string">"""</span>a = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]b = sorted(a)<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [1, 2, 3, 4, 5, 6, 7]</span> L=[(<span class="hljs-string">'b'</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">'a'</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">'c'</span>,<span class="hljs-number">3</span>),(<span class="hljs-string">'d'</span>,<span class="hljs-number">4</span>)]sorted(L, cmp=<span class="hljs-keyword">lambda</span> x,y:cmp(x[<span class="hljs-number">1</span>],y[<span class="hljs-number">1</span>]))   <span class="hljs-comment"># 利用cmp函数</span><span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [('a', 1), ('b', 2), ('c', 3), ('d', 4)]</span>sorted(L, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])               <span class="hljs-comment"># 利用key</span><span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [('a', 1), ('b', 2), ('c', 3), ('d', 4)]</span> students = [(<span class="hljs-string">'john'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-number">15</span>), (<span class="hljs-string">'jane'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-number">12</span>), (<span class="hljs-string">'dave'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-number">10</span>)]sorted(students, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-number">2</span>])            <span class="hljs-comment"># 按年龄排序</span><span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</span>sorted(students, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-number">2</span>], reverse=<span class="hljs-literal">True</span>)       <span class="hljs-comment"># 按降序</span><span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]</span></code></pre><h4 id="1-8-字典的运算"><a href="#1-8-字典的运算" class="headerlink" title="1.8 字典的运算"></a>1.8 字典的运算</h4><pre><code class="hljs python"><span class="hljs-comment"># 字典的运算</span><span class="hljs-string">"""</span><span class="hljs-string">zip()，可以将两个数量相同的list一一对应组合。</span><span class="hljs-string">通过取出dict中的key，values，将其颠倒组合，就能对value进行排序最大最小等操作。</span><span class="hljs-string">注：Python3中的zip之后是一个对象而不是list，需要通过list()转成list。</span><span class="hljs-string">"""</span>prices = &#123;    <span class="hljs-string">'ACME'</span>: <span class="hljs-number">45.23</span>,    <span class="hljs-string">'AAPL'</span>: <span class="hljs-number">612.78</span>,    <span class="hljs-string">'IBM'</span>: <span class="hljs-number">205.55</span>,    <span class="hljs-string">'HPQ'</span>: <span class="hljs-number">37.20</span>,    <span class="hljs-string">'FB'</span>: <span class="hljs-number">10.75</span>&#125;<span class="hljs-comment"># prices.values()可以取出value所有值作为list。为了对字典值执行计算操作，通常需要使用 zip() 函数先将键和值反转过来。</span>min_price = min(zip(prices.values(), prices.keys()))<span class="hljs-comment"># min_price is (10.75, 'FB')</span>max_price = max(zip(prices.values(), prices.keys()))<span class="hljs-comment"># max_price is (612.78, 'AAPL')</span><span class="hljs-comment"># 类似的，可以使用 zip() 和 sorted() 函数来排列字典数据：</span>prices_sorted = sorted(zip(prices.values(), prices.keys()))<span class="hljs-comment"># prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),</span><span class="hljs-comment">#                   (45.23, 'ACME'), (205.55, 'IBM'),</span><span class="hljs-comment">#                   (612.78, 'AAPL')]</span><span class="hljs-comment"># 执行这些计算的时候，需要注意的是 zip() 函数创建的是一个只能访问一次的迭代器。 如果需要可以将zip后的list取出。</span>vtok = list(zip(prices.values(), prices.keys())))</code></pre><h4 id="1-9-查找两字典的相同点"><a href="#1-9-查找两字典的相同点" class="headerlink" title="1.9 查找两字典的相同点"></a>1.9 查找两字典的相同点</h4><pre><code class="hljs python"><span class="hljs-comment"># 查找两字典的相同点</span><span class="hljs-string">""" </span><span class="hljs-string">字典中的key是可以进行集合操作的。而a.values不可以，需要转成set后操作。</span><span class="hljs-string">"""</span>a = &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">3</span>&#125;b = &#123;<span class="hljs-string">'w'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'x'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>&#125;<span class="hljs-comment"># Find keys in common</span>a.keys() &amp; b.keys()  <span class="hljs-comment"># &#123; 'x', 'y' &#125;</span><span class="hljs-comment"># Find keys in a that are not in b</span>a.keys() - b.keys()  <span class="hljs-comment"># &#123; 'z' &#125;</span><span class="hljs-comment"># Find (key,value) pairs in common</span>a.items() &amp; b.items()  <span class="hljs-comment"># &#123; ('y', 2) &#125;</span></code></pre><h4 id="1-10-删除序列相同元素并保持顺序"><a href="#1-10-删除序列相同元素并保持顺序" class="headerlink" title="1.10 删除序列相同元素并保持顺序"></a>1.10 删除序列相同元素并保持顺序</h4><pre><code class="hljs python"><span class="hljs-comment"># 删除序列相同元素并保持顺序</span><span class="hljs-string">""" </span><span class="hljs-string">如果序列上的值为hashable类型，则可以通过集合与生成器解决这个问题。</span><span class="hljs-string">其中集合是为了解决元素重复问题，yield则是依次返回元素到list。</span><span class="hljs-string">"""</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dedupe</span><span class="hljs-params">(items)</span>:</span>    seen = set()    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:        <span class="hljs-keyword">if</span> item <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:            <span class="hljs-keyword">yield</span> item            seen.add(item)a = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>]list(dedupe(a))<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [1, 5, 2, 9, 10]</span><span class="hljs-string">""" </span><span class="hljs-string">如果你想消除元素不可哈希（比如 dict 类型）的序列中重复元素的话，需改动代码，将序列元素转换成hashable类型，其实即是选取需要对比的value。</span><span class="hljs-string">"""</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dedupe2</span><span class="hljs-params">(items, key=None)</span>:</span>    seen = set()    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:        val = item <span class="hljs-keyword">if</span> key <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> key(item)        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:            <span class="hljs-keyword">yield</span> item            seen.add(val)a = [&#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">4</span>&#125;]list(dedupe2(a, key=<span class="hljs-keyword">lambda</span> d: (d[<span class="hljs-string">'x'</span>], d[<span class="hljs-string">'y'</span>])))<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [&#123;'x': 1, 'y': 2&#125;, &#123;'x': 1, 'y': 3&#125;, &#123;'x': 2, 'y': 4&#125;]</span>list(dedupe2(a, key=<span class="hljs-keyword">lambda</span> d: d[<span class="hljs-string">'x'</span>]))<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [&#123;'x': 1, 'y': 2&#125;, &#123;'x': 2, 'y': 4&#125;]</span><span class="hljs-string">""" </span><span class="hljs-string">仅仅消除元素的话用set就足够。</span><span class="hljs-string">对文件操作的话仅需进行如下变化，可以消除重复行：</span><span class="hljs-string">with open(somefile,'r') as f:</span><span class="hljs-string">for line in dedupe(f):</span><span class="hljs-string">    ...</span><span class="hljs-string">"""</span></code></pre><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>使用手册</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试使用fuzzowski框架</title>
    <link href="/2020/11/01/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8fuzzowski%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/11/01/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8fuzzowski%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>fuzzowski是一个模糊测试器，目前主要支持LPD、IPP、BACnet、Modbus协议。本次测试使用的Modbus部分内容进行修改测试，实际上是通过测定规则生成数据通过tcp不断进行发包。</p><h3 id="Socket脚本"><a href="#Socket脚本" class="headerlink" title="Socket脚本"></a>Socket脚本</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> socketHOST = <span class="hljs-string">'0.0.0.0'</span>PORT = <span class="hljs-number">6678</span>count = <span class="hljs-number">1</span>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((HOST, PORT))s.listen(<span class="hljs-number">10</span>)print(<span class="hljs-string">'Server start at: %s:%s'</span> %(HOST, PORT))print(<span class="hljs-string">'wait for connection...'</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    conn, addr = s.accept()    data = conn.recv(<span class="hljs-number">1024</span>)    f = open(<span class="hljs-string">"test1.txt"</span>,<span class="hljs-string">'a'</span>)    f.write(<span class="hljs-string">"&#123;:&lt;5d&#125;:"</span>.format(count))    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> data:        f.write(<span class="hljs-string">'%02X'</span> % ord(c))        f.write(<span class="hljs-string">' '</span>)    f.write(<span class="hljs-string">'\n'</span>)    f.close()    print(<span class="hljs-string">"&#123;:&lt;5d&#125;:Connected by&#123;&#125;"</span>.format(count, addr))    count+=<span class="hljs-number">1</span>    conn.send(data)    conn.close()</code></pre><h3 id="Fuzzowski设置"><a href="#Fuzzowski设置" class="headerlink" title="Fuzzowski设置"></a>Fuzzowski设置</h3><p>先使用简单的<code>python3 -m fuzzowski 127.0.0.1 6789 -f modbus</code></p><p>经过输出测试，发现变动一个<code>word</code>型会产生<strong>140</strong>种十六进制数据，变动一个<code>byte</code>型会产生<strong>116</strong>种十六进制数据，为固定产生非随机生成。</p><p>通过测试modbus的read_coil模块，主要为<code>/fuzzowski-master/fuzzowski/fuzzers/modbus/modbus.py</code>中如下代码：</p><pre><code class="hljs python">s_initialize(<span class="hljs-string">"modbus_read_coil"</span>)<span class="hljs-keyword">with</span> s_block(<span class="hljs-string">"modbus_head"</span>):    s_word(<span class="hljs-number">0x0001</span>,name=<span class="hljs-string">'transId'</span>,fuzzable=<span class="hljs-literal">True</span>)    s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'protoId'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_word(<span class="hljs-number">0x06</span>,name=<span class="hljs-string">'length'</span>)    s_byte(<span class="hljs-number">0xff</span>,name=<span class="hljs-string">'unit Identifier'</span>,fuzzable=<span class="hljs-literal">False</span>)    <span class="hljs-keyword">with</span> s_block(<span class="hljs-string">'pdu'</span>):        s_byte(<span class="hljs-number">0x01</span>,name=<span class="hljs-string">'funcCode read coil memory'</span>,fuzzable=<span class="hljs-literal">False</span>)        s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'start address'</span>)        s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'quantity'</span>)s_initialize(<span class="hljs-string">'read_holding_registers'</span>)<span class="hljs-keyword">with</span> s_block(<span class="hljs-string">"modbus_head"</span>):    s_word(<span class="hljs-number">0x0001</span>,name=<span class="hljs-string">'transId'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_word(<span class="hljs-number">0x0002</span>,name=<span class="hljs-string">'protoId'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_word(<span class="hljs-number">0x06</span>,name=<span class="hljs-string">'length'</span>)    s_byte(<span class="hljs-number">0xff</span>,name=<span class="hljs-string">'unit Identifier'</span>,fuzzable=<span class="hljs-literal">False</span>)    <span class="hljs-keyword">with</span> s_block(<span class="hljs-string">'read_holding_registers_block'</span>):        s_byte(<span class="hljs-number">0x01</span>,name=<span class="hljs-string">'read_holding_registers'</span>)        s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'start address'</span>)        s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'quantity'</span>)</code></pre><p>其中，fuzzable默认为True。设定为True的字段会依次产生变动生成数据，而非交叉产生，即一个数据包仅会有一个字段被fuzz。</p><p>举例修改上述模块为：</p><pre><code class="hljs python">s_initialize(<span class="hljs-string">"modbus_read_coil"</span>)<span class="hljs-keyword">with</span> s_block(<span class="hljs-string">"modbus_head"</span>):    s_byte(<span class="hljs-number">0x68</span>,name=<span class="hljs-string">'funcCode read coil memory1'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_byte(<span class="hljs-number">0x04</span>,name=<span class="hljs-string">'funcCode read coil memory2'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_byte(<span class="hljs-number">0x07</span>,name=<span class="hljs-string">'funcCode read coil memory3'</span>,fuzzable=<span class="hljs-literal">True</span>)    s_byte(<span class="hljs-number">0x00</span>,name=<span class="hljs-string">'funcCode read coil memory4'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_byte(<span class="hljs-number">0x00</span>,name=<span class="hljs-string">'funcCode read coil memory5'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_byte(<span class="hljs-number">0x00</span>,name=<span class="hljs-string">'funcCode read coil memory6'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_initialize(<span class="hljs-string">'read_holding_registers'</span>)<span class="hljs-keyword">with</span> s_block(<span class="hljs-string">"modbus_head"</span>):    s_word(<span class="hljs-number">0x0001</span>,name=<span class="hljs-string">'transId'</span>,fuzzable=<span class="hljs-literal">False</span>)    <span class="hljs-comment"># s_word(0x0002,name='protoId',fuzzable=False)</span>    <span class="hljs-comment"># s_word(0x06,name='length')</span>    <span class="hljs-comment"># s_byte(0xff,name='unit Identifier',fuzzable=False)</span>    <span class="hljs-comment"># with s_block('read_holding_registers_block'):</span>    <span class="hljs-comment">#     s_byte(0x01,name='read_holding_registers')</span>    <span class="hljs-comment">#     s_word(0x0000,name='start address')</span>    <span class="hljs-comment">#     s_word(0x0000,name='quantity')</span></code></pre><p>即只会生成<code>68 04 07 [00] 00 00</code>其中会对第4字节的fuzz数据，共112条。</p><p>通过<code>python3 -m fuzzowski 127.0.0.1 6789 -f modbus -tn -rt 1 -r read_coil</code>调用modbus的read_coil模块（实际上只是生成测试数据发送tcp包，设置为不处理响应）。</p><p><img src="/image/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8fuzzowski%E6%A1%86%E6%9E%B6/modbus-fuzz.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用conda管理环境</title>
    <link href="/2020/10/24/%E4%BD%BF%E7%94%A8conda%E7%AE%A1%E7%90%86%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/10/24/%E4%BD%BF%E7%94%A8conda%E7%AE%A1%E7%90%86%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Python中具有数量庞大且功能相对完善的标准库和第三方库。通过对库的引用，能够实现对不同领域业务的开发。然而，正是由于库的数量庞大，对于管理这些库以及对库作及时的维护成为既重要但复杂度又高的事情。</p><p><a href="https://www.anaconda.com/products/individual#macos" target="_blank" rel="noopener">Anaconda</a>就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</p></blockquote><h3 id="1-Anaconda安装"><a href="#1-Anaconda安装" class="headerlink" title="1. Anaconda安装"></a>1. Anaconda安装</h3><p>在<a href="https://www.anaconda.com/products/individual" target="_blank" rel="noopener">Anaconda</a>中下载对应的安装器安装。</p><p>例通过图形化界面安装完MacOS Anaconda，如果成功安装，通过<code>condal list</code>可以看到相关信息。</p><p>在终端中输入<code>python</code>。如果Anaconda被成功安装并且可以运行，则可看到Anaconda字样。</p><pre><code class="hljs python">Python <span class="hljs-number">3.7</span><span class="hljs-number">.6</span> (default, Jan  <span class="hljs-number">8</span> <span class="hljs-number">2020</span>, <span class="hljs-number">13</span>:<span class="hljs-number">42</span>:<span class="hljs-number">34</span>)[Clang <span class="hljs-number">4.0</span><span class="hljs-number">.1</span> (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin</code></pre><h3 id="2-管理conda环境"><a href="#2-管理conda环境" class="headerlink" title="2. 管理conda环境"></a>2. 管理conda环境</h3><blockquote><pre><code class="hljs bash">conda --version <span class="hljs-comment"># 验证conda安装</span></code></pre></blockquote><h4 id="更新conda"><a href="#更新conda" class="headerlink" title="更新conda"></a>更新conda</h4><pre><code class="hljs bash">conda update conda</code></pre><h4 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h4><pre><code class="hljs xml">conda create --name <span class="hljs-tag">&lt;<span class="hljs-name">env_name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">package_names</span>&gt;</span></code></pre><p>注意：</p><ul><li><p><code>&lt;env_name&gt;</code>即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</p></li><li><p><code>&lt;package_names&gt;</code>即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。</p></li><li><p><code>--name</code>同样可以替换为<code>-n</code>。</p><pre><code class="hljs bash"><span class="hljs-comment"># 创建名为python2的环境，python版本为2.7</span>conda create --name python2_test python=2.7<span class="hljs-comment"># 创建名为python3的环境，python版本为3.5，同时创建numpy和pandas包</span>conda create -n python3 python=3.5 numpy pandas</code></pre></li></ul><blockquote><p>注：默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/envs</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</p></blockquote><h4 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h4><pre><code class="hljs bash"><span class="hljs-comment"># 激活环境</span>conda activate &lt;env_name&gt;<span class="hljs-built_in">source</span> activate &lt;env_name&gt;<span class="hljs-comment"># 示例</span>conda activate python2_test<span class="hljs-built_in">source</span> activate python2_test<span class="hljs-comment"># 退出环境</span>conda deactivate<span class="hljs-built_in">source</span> deactivate<span class="hljs-comment"># 显示已创建环境</span>conda env listconda info -econda info --envs</code></pre><h4 id="复制环境"><a href="#复制环境" class="headerlink" title="复制环境"></a>复制环境</h4><pre><code class="hljs csharp">conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt;</code></pre><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><pre><code class="hljs csharp">conda <span class="hljs-keyword">remove</span> --name &lt;env_name&gt; --all</code></pre><h3 id="3-管理包"><a href="#3-管理包" class="headerlink" title="3. 管理包"></a>3. 管理包</h3><pre><code class="hljs bash"><span class="hljs-comment">### 查找包 ###</span><span class="hljs-comment"># 精确查找</span>conda search --full-name &lt;package_full_name&gt;<span class="hljs-comment"># 模糊查找</span>conda search &lt;text&gt;<span class="hljs-comment"># 获取当前环境包信息</span>conda list</code></pre><pre><code class="hljs bash"><span class="hljs-comment">### 安装包 ###</span><span class="hljs-comment"># 在指定环境中安装包</span>conda install --name &lt;env_name&gt; &lt;package_name&gt;<span class="hljs-comment"># 在当前环境中安装包</span>conda install &lt;package_name&gt;</code></pre><pre><code class="hljs bash"><span class="hljs-comment">### 卸载包 ###</span><span class="hljs-comment"># 在指定环境中卸载包</span>conda remove --name &lt;env_name&gt; &lt;package_name&gt;<span class="hljs-comment"># 在当前环境中卸载包</span>conda remove &lt;package_name&gt;</code></pre><pre><code class="hljs bash"><span class="hljs-comment">### 更新包 ### </span>conda update --allconda upgrade --allconda update &lt;package_name&gt;conda upgrade &lt;package_name&gt;<span class="hljs-comment"># 更新多个指定包，空格隔开即可</span>conda update pandas numpy matplotlib</code></pre><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/62f155eb6ac5" target="_blank" rel="noopener">https://www.jianshu.com/p/62f155eb6ac5</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下zsh及Oh-My-Zsh设置</title>
    <link href="/2020/10/14/Ubuntu%E4%B8%8Bzsh%E5%8F%8AOh-My-Zsh%E8%AE%BE%E7%BD%AE/"/>
    <url>/2020/10/14/Ubuntu%E4%B8%8Bzsh%E5%8F%8AOh-My-Zsh%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Z shell（Zsh）是一款可用作交互式登录的shell及脚本编写的命令解释器。内置于Ubuntu与OSX中，功能强大。</p><p>Oh My Zsh是一个开源的的框架，用于管理你的Zsh配置。有很多主题与扩展。</p></blockquote><h2 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h2><pre><code class="hljs bash"><span class="hljs-comment"># 查看系统已有shell</span>cat /etc/shells<span class="hljs-comment"># 查看当前默认的 Shell</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span> <span class="hljs-comment"># 安装zsh（Ubuntu与OSX内置有）</span>sudo apt install zsh<span class="hljs-comment"># 将 Zsh 设置为默认 Shell（chsh-change shell）</span>chsh -s /bin/zsh<span class="hljs-comment"># 如果没有改为 /bin/zsh，那么需要重启 Shell（reboot）。</span></code></pre><h2 id="安装-Oh-My-Zsh"><a href="#安装-Oh-My-Zsh" class="headerlink" title="安装 Oh My Zsh"></a>安装 Oh My Zsh</h2><pre><code class="hljs bash"><span class="hljs-comment"># 安装Oh My Zsh</span>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre><p>出现如下界面则安装成功</p><pre><code class="hljs csharp">__                                     __     ____  / /_     ____ ___  __  __   ____  _____/ /_   / __ \/ __ \   / __ `__ \/ / / /  /_  / / ___/ __ \ / /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / / \____/_/ /_/  /_/ /_/ /_/\__, /    /___/____/_/ /_/                          /____/                       ....<span class="hljs-keyword">is</span> now installed!Please look over the ~/.zshrc file to <span class="hljs-keyword">select</span> plugins, themes, and options.p.s. Follow us at https:<span class="hljs-comment">//twitter.com/ohmyzsh.</span>p.p.s. Get stickers and t-shirts at http:<span class="hljs-comment">//shop.planetargon.com.</span></code></pre><h2 id="Zsh配置"><a href="#Zsh配置" class="headerlink" title="Zsh配置"></a>Zsh配置</h2><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes" target="_blank" rel="noopener">Oh My Zsh主题</a>较多，默认使用的是<em>robbyrussell</em>，<em>agnoster</em>也比较不错。</p><p>使用<em>agnoster</em>主题出现乱码，可通过此<a href="https://blog.csdn.net/ZY_FlyWay/article/details/105379554" target="_blank" rel="noopener">链接</a>解决字体问题。</p><pre><code class="hljs bash"><span class="hljs-comment"># 编辑配置文件修改主题</span>vim ~/.zshrc<span class="hljs-comment"># 修改其中的内容</span>ZSH_THEME=<span class="hljs-string">"agnoster"</span></code></pre><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins" target="_blank" rel="noopener">Oh My Zsh插件</a>，装了几个常用的插件</p><pre><code class="hljs bash"><span class="hljs-comment"># 安装 zsh-autosuggestions</span><span class="hljs-comment"># 命令行命令键入时的历史命令建议插件</span>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions<span class="hljs-comment"># 安装 zsh-syntax-highlighting</span><span class="hljs-comment"># 命令行语法高亮插件</span> git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting<span class="hljs-comment"># 安装 z</span><span class="hljs-comment"># z 是一个相当实用的 cd 命令增强脚本（记录你的cd使用习惯 通过z命令模糊匹配）</span>git <span class="hljs-built_in">clone</span> https://github.com/rupa/z.git<span class="hljs-built_in">echo</span> <span class="hljs-string">'source ~/z/z.sh'</span> &gt;&gt; ~/.zshrc<span class="hljs-built_in">source</span> ~/.zshrc</code></pre><p>修改配置文件<code>vim ~/.zshrc</code></p><pre><code class="hljs c"># 最好把zsh-syntax-highlighting放在最后plugins=(  git zsh-autosuggestions z zsh-syntax-highlighting)</code></pre><blockquote><p>参考：</p><p><a href="https://juejin.im/post/6844903620333289486" target="_blank" rel="noopener">https://juejin.im/post/6844903620333289486</a></p><p><a href="https://www.jianshu.com/p/fa82d932888b" target="_blank" rel="noopener">https://www.jianshu.com/p/fa82d932888b</a></p><p><a href="https://linuxtoy.org/archives/z.html" target="_blank" rel="noopener">https://linuxtoy.org/archives/z.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux SSH免密认证密钥配置及VSCode-SSH配置</title>
    <link href="/2020/10/04/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/10/04/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下Linux的SSH免密配置，以及在VSCode上配置SSH以映射文件，编辑远端文档。</p><p>至于为什么转投VSCode，Ayu Light主题配色实在是太好看了。</p></blockquote><h2 id="SSH公私钥配置"><a href="#SSH公私钥配置" class="headerlink" title="SSH公私钥配置"></a>SSH公私钥配置</h2><blockquote><p>SSH使用方便且安全，公私钥均有本地生成，公钥存放至服务器端即可</p></blockquote><h3 id="生成密钥ssh-keygen"><a href="#生成密钥ssh-keygen" class="headerlink" title="生成密钥ssh-keygen"></a>生成密钥<code>ssh-keygen</code></h3><p>样例：</p><pre><code class="hljs bash">ssh-keygen -t rsa -f aliyun_ssh -C <span class="hljs-string">"备注"</span></code></pre><table><thead><tr><th>参数</th><th align="left">使用</th></tr></thead><tbody><tr><td>-f</td><td align="left">生成文件名</td></tr><tr><td>-t</td><td align="left">采用rsa加密方式,t=type</td></tr><tr><td>-b</td><td align="left">采用长度1024bit的密钥对,b=bits,最长4096</td></tr><tr><td>-C</td><td align="left">备注</td></tr></tbody></table><p>如果该命令是在<code>~/.ssh</code>目录下执行，执行后~/.ssh目录对多出<code>aliyun_ssh</code>和<code>aliyun_ssh.pub</code>两个文件。</p><p>有pub后缀的文件为公钥，没有pub后缀的文件为私钥。</p><h3 id="配置公钥ssh-copy-id"><a href="#配置公钥ssh-copy-id" class="headerlink" title="配置公钥ssh-copy-id"></a>配置公钥<code>ssh-copy-id</code></h3><p>样例：</p><pre><code class="hljs bash">ssh-copy-id -i ~/.ssh/aliyun_ssh.pub root@2.2.2.2</code></pre><p><code>-i</code> (identity_file认证文件)，其实是通过ssh将公钥写入远程服务器的<code>~/ .ssh/authorized_key</code>中（向后添加）。通过文本的复制效果相同。</p><blockquote><p>注：<strong>需要服务器端的~/ .ssh/authorized_key文件具有600权限！</strong></p></blockquote><h3 id="本地SSH配置"><a href="#本地SSH配置" class="headerlink" title="本地SSH配置"></a>本地SSH配置</h3><p>配置格式简单如下：</p><pre><code class="hljs json">Host 10.211.1.1  HostName 10.211.1.1  User rootHost aliyun-2.2.2.2  HostName 2.2.2.2  User root  IdentityFile ~/.ssh/aliyun_ssh</code></pre><p>其中<strong>Host</strong>是自己备注的名字，<strong>HostName</strong>即服务器IP，<strong>User</strong>为登录用户。</p><p>如果使用SSH公私钥登录则需要配置<strong>IdentityFile</strong>指向本地存放的私钥。</p><p>登录时即可备注的名字快速登录(支持tab补全)</p><pre><code class="hljs bash">ssh aliyun-2.2.2.2</code></pre><h2 id="配置VSCode-Remote-SSH"><a href="#配置VSCode-Remote-SSH" class="headerlink" title="配置VSCode Remote - SSH"></a>配置VSCode Remote - SSH</h2><p>直接在VSCode安装Remote - SSH扩展即可。</p><p><img src="/image/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/remotessh.png" srcset="/img/loading.gif" alt=""></p><p>安装完后会在侧边栏和左下角出现相应的扩展栏。</p><p><img src="/image/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/sidebar.png" srcset="/img/loading.gif" alt=""></p><p>可根据系统ssh-config进行连接，即可快速在本地编辑远端文本。</p><h2 id="VSCode快捷键"><a href="#VSCode快捷键" class="headerlink" title="VSCode快捷键"></a>VSCode快捷键</h2><blockquote><p>最后记录一些常用的快捷键</p></blockquote><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><pre><code class="hljs bash">Command + Shift + P / F1 显示命令面板Command + P 快速打开Command + Shift + N 打开新窗口Command + W 关闭窗口</code></pre><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><pre><code class="hljs bash">Command + X 剪切（未选中文本的情况下，剪切光标所在行）Command + C 复制（未选中文本的情况下，复制光标所在行）Option + Up 向上移动行Option + Down 向下移动行Option + Shift + Up 向上复制行Option + Shift + Down 向下复制行Command + Shift + K 删除行Command + Enter 下一行插入Command + Shift + Enter 上一行插入Command + Shift + \ 跳转到匹配的括号Command + [ 减少缩进Command + ] 增加缩进Home 跳转至行首End 跳转到行尾Command + Up 跳转至文件开头Command + Down 跳转至文件结尾Ctrl + PgUp 按行向上滚动Ctrl + PgDown 按行向下滚动Command + PgUp 按屏向上滚动Command + PgDown 按屏向下滚动Command + Shift + [ 折叠代码块Command + Shift + ] 展开代码块Command + K Command + [ 折叠全部子代码块Command + K Command + ] 展开全部子代码块Command + K Command + 0 折叠全部代码块Command + K Command + J 展开全部代码块Command + K Command + C 添加行注释Command + K Command + U 移除行注释Command + / 添加、移除行注释Option + Shift + A 添加、移除块注释Option + Z 自动换行、取消自动换行</code></pre><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><pre><code class="hljs bash">Option + 点击 插入多个光标Command + Option + Up 向上插入光标Command + Option + Down 向下插入光标Command + U 撤销上一个光标操作Option + Shift + I 在所选行的行尾插入光标Command + I 选中当前行Command + Shift + L 选中所有与当前选中内容相同部分Command + F2 选中所有与当前选中单词相同的单词Command + Ctrl + Shift + Left 折叠选中Command + Ctrl + Shift + Right 展开选中Alt + Shift + 拖动鼠标 选中代码块Command + Shift + Option + Up 列选择 向上Command + Shift + Option + Down 列选择 向下Command + Shift + Option + Left 列选择 向左Command + Shift + Option + Right 列选择 向右Command + Shift + Option + PgUp 列选择 向上翻页Command + Shift + Option + PgDown 列选择 向下翻页</code></pre><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><pre><code class="hljs bash">Command + F 查找Command + Option + F 替换Command + G 查找下一个Command + Shift + G 查找上一个Option + Enter 选中所有匹配项Command + D 向下选中相同内容Command + K Command + D 移除前一个向下选中相同内容</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><pre><code class="hljs bash">Ctrl + Space 打开建议Command + Shift + Space 参数提示Tab Emmet插件缩写补全Option + Shift + F 格式化Command + K Command + F 格式化选中内容F12 跳转到声明位置Option + F12 查看具体声明内容Command + K F12 分屏查看具体声明内容Command + . 快速修复Shift + F12 显示引用F2 重命名符号Command + Shift + . 替换为上一个值Command + Shift + , 替换为下一个值Command + K Command + X 删除行尾多余空格Command + K M 更改文件语言</code></pre><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><pre><code class="hljs bash">Command + T 显示所有符号Ctrl + G 跳转至某行Command + P 跳转到某个文件Command + Shift + O 跳转到某个符号Command + Shift + M 打开问题面板F8 下一个错误或警告位置Shift + F8 上一个错误或警告位置Ctrl + Shift + Tab 编辑器历史记录Ctrl + - 后退Ctrl + Shift + - 前进Ctrl + Shift + M Tab 切换焦点</code></pre><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><pre><code class="hljs bash">Command + W 关闭编辑器Command + K F 关闭文件夹Command + \ 编辑器分屏Command + 1 切换到第一分组Command + 2 切换到第二分组Command + 3 切换到第三分组Command + K Command + Left 切换到上一分组Command + K Command + Right 切换到下一分组Command + K Command + Shift + Left 左移编辑器Command + K Command + Shift + Right 右移编辑器Command + K Left 激活左侧编辑组Command + K Right 激活右侧编辑组</code></pre><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><pre><code class="hljs bash">Command + N 新建文件Command + O 打开文件Command + S 保存文件Command + Shift + S 另存为Command + Option + S 全部保存Command + W 关闭Command + K Command + W 全部关闭Command + Shift + T 重新打开被关闭的编辑器Command + K Enter 保持打开Ctrl + Tab 打开下一个Ctrl + Shift + Tab 打开上一个Command + K P 复制当前文件路径Command + K R 在资源管理器中查看当前文件Command + K O 新窗口打开当前文件</code></pre><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><pre><code class="hljs bash">Command + Ctrl + F 全屏、退出全屏Command + Option + 1 切换编辑器分屏方式（横、竖）Command + + 放大Command + - 缩小Command + B 显示、隐藏侧边栏Command + Shift + E 显示资源管理器 或 切换焦点Command + Shift + F 显示搜索框Ctrl + Shift + G 显示Git面板Command + Shift + D 显示调试面板Command + Shift + X 显示插件面板Command + Shift + H 全局搜索替换Command + Shift + J 显示、隐藏高级搜索Command + Shift + C 打开新终端Command + Shift + U 显示输出面板Command + Shift + V Markdown预览窗口Command + K V 分屏显示 Markdown预览窗口</code></pre><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><pre><code class="hljs bash">F9 设置 或 取消断点F5 开始 或 继续F11 进入Shift + F11 跳出F10 跳过Command + K Command + I 显示悬停信息</code></pre><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><pre><code class="hljs bash">Ctrl + ` 显示终端Ctrl + Shift + ` 新建终端Command + Up 向上滚动Command + Down 向下滚动PgUp 向上翻页PgDown 向下翻页Command + Home 滚动到顶部Command + End 滚动到底部</code></pre><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/dd053c18e5ee" target="_blank" rel="noopener">https://www.jianshu.com/p/dd053c18e5ee</a></p><p><a href="https://segmentfault.com/a/1190000012811886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012811886</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hydra开发说明</title>
    <link href="/2020/09/29/Hydra%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/09/29/Hydra%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hydra工具集成进入扫描系统，与WEB开发端结合，通过开发说明明确输入输出格式与业务逻辑。</p></blockquote><h3 id="一、-输入格式"><a href="#一、-输入格式" class="headerlink" title="一、 输入格式"></a>一、 输入格式</h3><ol><li>命令行范式</li></ol><pre><code class="hljs bash">hydra [some <span class="hljs-built_in">command</span> line options] TARGET PROTOCOL</code></pre><ol start="2"><li>输入内容</li></ol><p>包括<strong>协议选择</strong>，<strong>IP地址与端口指定</strong></p><ul><li>协议（必选项），具有<code>RDP</code>、<code>MYSQL</code>、<code>SSH</code>、<code>TELNET</code>选项</li><li>IP地址（必选项）与端口（可选项），具有输入IP与上传IP地址文件两种模式</li></ul><blockquote><p>1) 输入IP模式：支持<code>IP[:port]</code>与<code>CIDR</code>模式(192.168.0.0/24)</p><p>2) 上传IP地址文件模式：文件一行表示一个地址，格式应为<code>IP[:port]</code>，例：</p><p>foo.bar.com<br>target.com:21<br>unusual.port.com:2121<br>default.used.here.com<br>127.0.0.1<br>127.0.0.1:2121</p></blockquote><p><em>（注：后期考虑将其他模块扫描得到的存活主机作为本模块地址参数）</em></p><ol start="3"><li>其他已选相关参数</li></ol><ul><li>-L：指定用户名字典（根据协议选定内置字典）</li><li>-P：指定密码字典（根据协议选定内置字典）</li></ul><p><em>（注：内置字典可置于服务器静态文件中，为行数较多的txt文件）</em></p><ul><li>-e ns：空密码与账密相同探测</li><li>-o：指定输出文件</li><li>-b：指定输出格式（本次选用json）</li></ul><ol start="4"><li>输入示例</li></ol><ul><li>扫描文件地址中的SSH弱口令</li></ul><pre><code class="hljs bash">hydra -L ssh_login.txt -P ssh_passwd.txt -e ns -o result.json -b json -M IP_addr.txt ssh</code></pre><ul><li>扫描指定IP的RDP弱口令</li></ul><pre><code class="hljs bash">hydra -L rdp_login.txt -P rdp_passwd.txt -e ns -o result.json -b json 127.0.0.1 rdp</code></pre><ul><li>扫描文件地址的TELNET弱口令</li></ul><pre><code class="hljs bash">hydra -L telnet_login.txt -P telnet_passwd.txt -e ns -o result.json -b json -M IP_addr.txt telnet</code></pre><ul><li>扫描指定IP的MYSQL弱口令</li></ul><pre><code class="hljs bash">hydra -L mysql_login.txt -P mysql_passwd.txt -e ns -o result.json -b json 127.0.0.1 mysql</code></pre><h3 id="二、输出格式"><a href="#二、输出格式" class="headerlink" title="二、输出格式"></a>二、输出格式</h3><blockquote><p>采用本地缓存json格式，输出文件由-o选项的参数指定。</p></blockquote><p>SSH测试成功样例，扫描记录信息记录在上，结果存于<code>results</code>中。</p><pre><code class="hljs json">&#123; <span class="hljs-attr">"generator"</span>: &#123;<span class="hljs-attr">"software"</span>: <span class="hljs-string">"Hydra"</span>, <span class="hljs-attr">"version"</span>: <span class="hljs-string">"v9.1"</span>, <span class="hljs-attr">"built"</span>: <span class="hljs-string">"2020-09-29 15:44:28"</span>,<span class="hljs-attr">"server"</span>: <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-attr">"service"</span>: <span class="hljs-string">"ssh"</span>, <span class="hljs-attr">"jsonoutputversion"</span>: <span class="hljs-string">"1.00"</span>,<span class="hljs-attr">"commandline"</span>: <span class="hljs-string">"hydra -l root -p root1 -e ns -o b.json -b json 127.0.0.1 ssh"</span>&#125;,<span class="hljs-attr">"results"</span>: [&#123;<span class="hljs-attr">"port"</span>: <span class="hljs-number">22</span>, <span class="hljs-attr">"service"</span>: <span class="hljs-string">"ssh"</span>, <span class="hljs-attr">"host"</span>: <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-attr">"login"</span>: <span class="hljs-string">"root"</span>, <span class="hljs-attr">"password"</span>: <span class="hljs-string">"root"</span>&#125;],<span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">"errormessages"</span>: [  ],<span class="hljs-attr">"quantityfound"</span>: <span class="hljs-number">1</span>   &#125;</code></pre><p>为扫描出弱口令则<code>results</code>为空。</p><pre><code class="hljs json">&#123; <span class="hljs-attr">"generator"</span>: &#123;<span class="hljs-attr">"software"</span>: <span class="hljs-string">"Hydra"</span>, <span class="hljs-attr">"version"</span>: <span class="hljs-string">"v9.1"</span>, <span class="hljs-attr">"built"</span>: <span class="hljs-string">"2020-09-29 15:44:43"</span>,<span class="hljs-attr">"server"</span>: <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-attr">"service"</span>: <span class="hljs-string">"ssh"</span>, <span class="hljs-attr">"jsonoutputversion"</span>: <span class="hljs-string">"1.00"</span>,<span class="hljs-attr">"commandline"</span>: <span class="hljs-string">"hydra -l root1 -p root1 -e ns -o b.json -b json 127.0.0.1 ssh"</span>&#125;,<span class="hljs-attr">"results"</span>: [],<span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">"errormessages"</span>: [  ],<span class="hljs-attr">"quantityfound"</span>: <span class="hljs-number">0</span>   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hydra</tag>
      
      <tag>渗透测试</tag>
      
      <tag>弱口令扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hydra用法简记</title>
    <link href="/2020/09/14/hydra%E7%94%A8%E6%B3%95%E7%AE%80%E8%AE%B0/"/>
    <url>/2020/09/14/hydra%E7%94%A8%E6%B3%95%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hydra是著名黑客组织thc的一款开源的暴力密码破解<a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank" rel="noopener">工具</a>,可以在线破解多种密码。</p><p>官网:<a href="http://www.thc.org/thc-hydra" target="_blank" rel="noopener">http://www.thc.org/thc-hydra</a></p><p>这款暴力密码破解工具相当强大,支持几乎所有协议的在线密码破解,其密码能否被破解关键在于字典是否足够强大。本文仅从安全角度去探讨测试,使用本文内容去做破坏者,与本人无关。</p></blockquote><h3 id="1-指令范式"><a href="#1-指令范式" class="headerlink" title="1.指令范式"></a>1.指令范式</h3><pre><code class="hljs bash">hydra [some <span class="hljs-built_in">command</span> line options] [-s PORT] TARGET PROTOCOL [MODULE-OPTIONS]</code></pre><h3 id="2-参数选项"><a href="#2-参数选项" class="headerlink" title="2.参数选项"></a>2.参数选项</h3><p>使用option指定参数</p><blockquote><p>-R 根据上一次进度继续破解</p><p>-S 使用SSL协议连接</p><p>-s 指定端口,也可通过ip:port指定端口</p><p>-l 指定用户名</p><p>-L 指定用户名字典(文件)</p><p>-p 指定密码破解</p><p>-P 指定密码字典(文件)</p><p>-e ns 空密码探测和指定用户密码探测,n代表null尝试,代表密码同账户名尝试</p><p>-C 用户名可以用:分割(username:password)可以代替-l username -p password,同时支持该类型下的文件</p><p>-M 指定地址(文件)</p><p>-4/6 指定ipv4或ipv6(默认ipv4)</p><p>-o 输出文件</p><p>-t 指定多线程数量,默认为16个线程</p><p>-vV 显示详细过程</p><p>-f 当账号密码爆破成功时,不再继续进行(通常适用于单用户破解)</p><p>-x min:max:charset 生成密码字典,min最短长度,max最长长度,charset中a代表小写字母,A代表大写字母,1代表数字</p></blockquote><h3 id="3-指定IP"><a href="#3-指定IP" class="headerlink" title="3.指定IP"></a>3.指定IP</h3><ul><li>使用一个独立的IP或者DNS地址</li><li>使用CIDR类型的地址段,例<code>&quot;192.168.0.0/24&quot;</code></li><li>通过文件指定地址(使用参数选项 - M)</li><li>亦可通过新方式指定协议、地址、端口、可选项,例<code>ftp://192.168.33.44:22</code></li></ul><h3 id="4-指定协议"><a href="#4-指定协议" class="headerlink" title="4.指定协议"></a>4.指定协议</h3><p>在target之后指明协议。</p><blockquote><p>目前支持的协议类型有:Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MONGODB, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, Radmin, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP</p></blockquote><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h3><pre><code class="hljs bash"><span class="hljs-comment"># 破解ssh:</span>hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip sshhydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解ftp:</span>hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vVhydra ip ftp -l 用户名 -P 密码字典 -e ns -vV</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># get方式提交,破解web登录:</span>hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># post方式提交,破解web登录:</span>hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form ``<span class="hljs-string">"/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry password"</span></code></pre><pre><code class="hljs bash">hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form <span class="hljs-string">"login.php:id=^USER^&amp;passwd=^PASS^:&lt;title&gt;wrong username or password&lt;/title&gt;"</span><span class="hljs-comment"># 参数说明:-t同时线程数3,-l用户名是admin,字典pass.txt,保存为out.txt,-f 当破解了一个密码就停止,</span><span class="hljs-comment"># 10.36.16.18目标ip,http-post-form表示破解是采用http的post方式提交的表单密码破解,&lt;title&gt;中的内容是表示错误猜解的返回信息提示。</span></code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解https:</span>hydra -m /index.php -l muts -P pass.txt 10.36.16.18 https</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解teamspeak:</span>hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解cisco:</span>hydra -P pass.txt 10.36.16.18 ciscohydra -m cloud -P pass.txt 10.36.16.18 cisco-enable</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解smb:</span>hydra -l administrator -P pass.txt 10.36.16.18 smb</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解pop3:</span>hydra -l muts -P pass.txt my.pop3.mail pop3</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解rdp:</span>hydra ip rdp -l administrator -P pass.txt -V</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解http-proxy:</span>hydra -l admin -P pass.txt http-proxy://10.36.16.18</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解imap:</span>hydra -L user.txt -p secret 10.36.16.18 imap PLAINhydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN</code></pre><blockquote><p>参考:</p><p><a href="https://github.com/vanhauser-thc/thc-hydra#special-options-for-modules" target="_blank" rel="noopener">https://github.com/vanhauser-thc/thc-hydra#special-options-for-modules</a></p><p><a href="http://xstarcd.github.io/wiki/shell/hydra.html" target="_blank" rel="noopener">http://xstarcd.github.io/wiki/shell/hydra.html</a></p><p><a href="https://yq.aliyun.com/articles/333121" target="_blank" rel="noopener">https://yq.aliyun.com/articles/333121</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hydra</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux fork机制</title>
    <link href="/2020/08/17/Linux-fork%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/08/17/Linux-fork%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前导"><a href="#1-前导" class="headerlink" title="1. 前导"></a>1. 前导</h2><ol><li><p>进程可以看做程序的一次执行过程。在linux下，每个进程有唯一的PID标识进程。PID是一个从1到32768的正整数，其中1一般是特殊进程init，其它进程从2开始依次编号。当用完32768后，从2重新开始。</p></li><li><p>linux中有一个叫进程表的结构用来存储当前正在运行的进程。可以使用<code>ps aux</code>命令查看所有正在运行的进程。</p></li><li><p>进程在linux中呈树状结构，init为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。</p></li><li><p>fork的作用是<strong>复制一个与当前进程一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p></li></ol><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><ul><li>该进程为父进程时，返回子进程的pid</li><li>该进程为子进程时，返回0</li><li>fork执行失败，返回-1</li></ul><p>其实根据名字十分形象，fork叉子分叉：</p><p><img src="/image/Linux_fork%E6%9C%BA%E5%88%B6/fork.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><p>在网上看fork机制<a href="https://www.jianshu.com/p/1327c51a4a99" target="_blank" rel="noopener">文章</a>中发现一道不错帮助理解的例题，特此记录。</p><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment">已知从这个程序执行到这个程序的所有进程结束这个时间段内，没有其它新进程执行。</span><span class="hljs-comment">1、请说出执行这个程序后，将一共运行几个进程。</span><span class="hljs-comment">2、如果其中一个进程的输出结果是“pid1:1001, pid2:1002”，写出其他进程的输出结果（不考虑进程执行顺序）。</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">pid_t</span> pid1;<span class="hljs-keyword">pid_t</span> pid2;pid1 = fork();pid2 = fork();<span class="hljs-built_in">printf</span>(<span class="hljs-string">"pid1:%d,pid2:%d\n"</span>,pid1,pid2);&#125;</code></pre><h3 id="2-1-解题关键"><a href="#2-1-解题关键" class="headerlink" title="2.1 解题关键"></a>2.1 解题关键</h3><p>解题的关键就是要认识到fork将程序切成两段。看下图：</p><p><img src="/image/Linux_fork%E6%9C%BA%E5%88%B6/ex.png" srcset="/img/loading.gif" alt=""></p><p>上图表示一个含有fork的程序，而fork语句可以看成将程序切为A、B两个部分。然后整个程序会如下运行：</p><ol><li>设由shell直接执行程序，生成了进程P。P执行完Part. A的所有代码。</li><li>当执行到<code>pid = fork();</code>时，P启动一个进程Q，Q是P的子进程，和P是同一个程序的进程。Q继承P的所有变量、环境变量、程序计数器的当前值。</li><li>在P进程中，fork()<strong>将Q的PID返回给变量pid</strong>，并继续执行Part. B的代码。</li><li>在进程Q中，<strong>将0赋给pid</strong>，并继续执行Part. B的代码。</li></ol><p>这里有三个点非常关键:</p><ol><li>P执行了所有程序，而Q只执行了Part. B，即fork()后面的程序。（这是因为Q继承了P的PC-程序计数器）</li><li>Q继承了fork()语句执行时当前的环境，而不是程序的初始环境。</li><li>P中fork()语句启动子进程Q，并将Q的PID返回，而Q中的fork()语句不启动新进程，仅将0返回。</li></ol><h3 id="2-2-解题过程"><a href="#2-2-解题过程" class="headerlink" title="2.2 解题过程"></a>2.2 解题过程</h3><p>下面利用上文阐述的知识进行解题。这里我把两个问题放在一起进行分析。</p><ol><li><p>从shell中执行此程序，启动了一个进程，我们设这个进程为P0，设其PID为XXX（解题过程不需知道其PID）。</p></li><li><p>当执行到pid1 = fork();时，P0启动一个子进程P1，由题目知P1的PID为1001。我们暂且不管P1。</p></li><li><p>P0中的fork返回1001给pid1，继续执行到pid2 = fork();，此时启动另一个新进程，设为P2，由题目知P2的PID为1002。同样暂且不管P2。</p></li><li><p>P0中的第二个fork返回1002给pid2，继续执行完后续程序，结束。所以，P0的结果为“pid1:1001, pid2:1002”。</p></li><li><p>再看P2，P2生成时，P0中pid1=1001，所以P2中pid1继承P0的1001，而作为子进程pid2=0。P2从第二个fork后开始执行，结束后输出“pid1:1001, pid2:0”。</p></li><li><p>接着看P1，P1中第一条fork返回0给pid1，然后接着执行后面的语句。而后面接着的语句是pid2 = fork();执行到这里，P1又产生了一个新进程，设为P3。先不管P3。</p></li><li><p>P1中第二条fork将P3的PID返回给pid2，由预备知识知P3的PID为1003，所以P1的pid2=1003。P1继续执行后续程序，结束，输出“pid1:0, pid2:1003”。</p></li><li><p>P3作为P1的子进程，继承P1中pid1=0，并且第二条fork将0返回给pid2，所以P3最后输出“pid1:0, pid2:0”。</p></li><li><p>至此，整个执行过程完毕。</p></li></ol><h3 id="2-3-所得答案"><a href="#2-3-所得答案" class="headerlink" title="2.3 所得答案"></a>2.3 所得答案</h3><p>1、一共执行了四个进程。（P0, P1, P2, P3）</p><p>2、另外几个进程的输出分别为：</p><p>pid1:1001, pid2:0</p><p>pid1:0, pid2:1003</p><p>pid1:0, pid2:0</p><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/1327c51a4a99" target="_blank" rel="noopener">https://www.jianshu.com/p/1327c51a4a99</a></p><p><a href="https://zhuanlan.zhihu.com/p/36872365" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36872365</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>fork</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spike简单测试使用</title>
    <link href="/2020/08/13/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/13/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前了解了一下Spike模糊测试框架，本文记录一下使用过程中遇到的问题与使用测试结果。</p></blockquote><h2 id="1-编译问题"><a href="#1-编译问题" class="headerlink" title="1. 编译问题"></a>1. 编译问题</h2><h3 id="macos编译"><a href="#macos编译" class="headerlink" title="macos编译"></a>macos编译</h3><p>使用macos编译出现一些问题，未再考虑。</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/lib_mac.png" srcset="/img/loading.gif" alt=""></p><h3 id="centos编译"><a href="#centos编译" class="headerlink" title="centos编译"></a>centos编译</h3><p>centos编译结果正常，但是运行过程中显示一个库文件<code>libdlrpc.so</code>引用失败。如图：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/lib_linux.png" srcset="/img/loading.gif" alt=""></p><p>根据查找，运行<code>src</code>下<code>ld.sh</code>脚本导入环境变量解决。</p><p>注：通过<code>source ld.sh</code>或<code>. ./ld.sh</code>运行，通过<code>./ld.sh</code>则无法解决。原因参见<a href="https://leex0.top/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">此文章</a>。</p><p><code>ld.sh</code>如下：</p><pre><code class="hljs bash"><span class="hljs-comment">#Use this to use any of the generic programs</span><span class="hljs-comment">#try using . ./ld.sh if it's not working</span><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=.</code></pre><h2 id="2-vulnserver程序测试"><a href="#2-vulnserver程序测试" class="headerlink" title="2. vulnserver程序测试"></a>2. vulnserver程序测试</h2><p>通过使用vulnserver，测试spike能否正确使用。</p><p>脚本如下：</p><pre><code class="hljs c">s_readline();s_string(<span class="hljs-string">"TRUN"</span>);s_string_variable(<span class="hljs-string">"COMMAND"</span>);</code></pre><p>攻击端（CentOS）<code>./generic_send_tcp 10.xx.xx.xx 9999 vul_test.spk 0 0</code>：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/vul_fuzz.png" srcset="/img/loading.gif" alt=""></p><p>服务器端（WindowsXP）程序崩溃：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/vul_error.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-flask-web测试"><a href="#3-flask-web测试" class="headerlink" title="3. flask web测试"></a>3. flask web测试</h2><p>搭建一个简单的web服务器(<code>python flask</code>)测试spike使用。</p><p>攻击脚本如下：</p><pre><code class="hljs c">s_string(<span class="hljs-string">"GET / HTTP/1.1\r\n"</span>);s_string(<span class="hljs-string">"Host: 10.37.129.5:5000\r\n"</span>);s_string(<span class="hljs-string">"User-Agent: "</span>);s_string(<span class="hljs-string">"Content-Length: "</span>);s_blocksize_string(<span class="hljs-string">"block1"</span>, <span class="hljs-number">5</span>); s_string(<span class="hljs-string">"\r\nConnection: close\r\n\r\n"</span>);s_block_start(<span class="hljs-string">"block1"</span>);s_string(<span class="hljs-string">"inputvar="</span>);s_block_end(<span class="hljs-string">"block1"</span>);</code></pre><p>攻击端（CentOS）<code>./generic_send_tcp 10.37.129.5 5000 flask.spk 0 0</code>：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/flask_fuzz.png" srcset="/img/loading.gif" alt=""></p><p>服务器端（Ubuntu）：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/flask_run.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本设置环境变量问题</title>
    <link href="/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在编写框架的初始化编译脚本的过程中，需要向系统导入一个环境变量。</p><p>期望导入<code>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$path</code></p><p>使用<code>sh init.sh</code>后，发现环境变量并未导入。</p></blockquote><p>脚本内容简单，如下：</p><pre><code class="hljs sh">./configure &amp;&amp; make clean &amp;&amp; makepath=$(<span class="hljs-built_in">pwd</span>)LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:<span class="hljs-variable">$path</span><span class="hljs-built_in">export</span> LD_LIBRARY_PATHldconfig</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>使用<code>source init.sh</code>可以解决问题（具有权限情况下）。</li></ul><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><ul><li><p>使用 <code>sh</code> 命令来执行shell脚本的时候，脚本实际是在<code>sh</code>创建的子shell中执行。</p></li><li><p>所以当<code>sh</code>进程完成的时候并没有修改系统变量，所以通过执行 <code>sh init.sh</code>来修改系统变量是无效的。</p></li></ul><h3 id="Q1-父子Shell-与-环境变量"><a href="#Q1-父子Shell-与-环境变量" class="headerlink" title="Q1. 父子Shell 与 环境变量"></a>Q1. 父子Shell 与 环境变量</h3><ul><li>执行程序通常可以理解为parent process所产生的child process，child执行完后再返回到parent。这一现象在Linux中成为<code>fork</code>。子进程产生时会从父进程处<strong>获得资源分配与继承环境</strong>，<strong>所谓环境变量其实就是会传给子进程的变量</strong>。</li><li>通常是，<strong>子shell会继承所有父shell的变量</strong>（可以直接引用）。父shell的变量包括<strong>所有export导出的环境变量和当前环境下设置的变量</strong>（形如var=value）的命令。</li><li>从 process 的观念来看，是 <strong>parent process 产生一个 child process 去执行</strong>，当 child 结束后，会返回 parent ，但 parent 的环境是不会因 child 的改变而改变的。</li></ul><h3 id="Q2-source-与-sh-与-xxx-执行脚本的区别"><a href="#Q2-source-与-sh-与-xxx-执行脚本的区别" class="headerlink" title="Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别"></a>Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别</h3><ul><li><p>对于脚本xxx.sh来说，<code>. ./xxx.sh</code>与<code>source ./xxx.sh</code>相同，与<code>./xxx.sh</code>和<code>sh xxx.sh</code>均不同。</p></li><li><p><code>./xxx.sh</code>——首先你会查找脚本第一行是否指定了解释器，如果没指定，那么就用当前系统默认的shell(大多数linux默认是bash)，如果指定了解释器，那么就将该脚本交给指定的解释器。</p></li><li><p><code>sh xxx.sh</code>——表示我使用sh来解释这个脚本，可以不要执行权限。</p></li><li><p>正常来说，当我们执行一个 shell script 时，其实是先<strong>产生一个 sub-shell 的子进程</strong>，然后 sub-shell 再去产生命令行的子进程。（<code>sh</code>执行脚本的一般方式）</p></li><li><p>所谓<code>source</code>就是让 script 在<strong>当前 shell 内执行而不是产生一个 sub-shell 来执行</strong>。<br>由于所有执行结果均于当前 shell 内完成，若 script 的环境有所改变，当然也会改变当前环境。<br><em>可以理解为source是把脚本内容一行一行读到父shell里挨着执行。</em></p></li></ul><blockquote><p>参考：</p><p><a href="http://bbs.chinaunix.net/thread-2211666-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-2211666-1-1.html</a></p><p><a href="https://www.zhihu.com/question/41441630/answer/91061860" target="_blank" rel="noopener">https://www.zhihu.com/question/41441630/answer/91061860</a> - Virtual的回答</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模糊测试与Spike框架简介</title>
    <link href="/2020/08/02/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/08/02/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-内容介绍"><a href="#1-内容介绍" class="headerlink" title="1. 内容介绍"></a>1. 内容介绍</h2><h3 id="1-1-模糊测试简介"><a href="#1-1-模糊测试简介" class="headerlink" title="1.1 模糊测试简介"></a>1.1 模糊测试简介</h3><p>模糊测试（Fuzzing），是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。<br>其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监控目标程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏等。<br>即用随机坏数据（也称做 fuzz）攻击一个程序，然后等着观察哪里遭到了破坏。但这一过程却能揭示出程序中的重要 bug。<br>它是一种介于完全的手工渗透测试与完全的自动化测试之间的安全性测试类型。它充分利用了机器能够随机生成和发送数据的能力。</p><h3 id="1-2-Spike框架"><a href="#1-2-Spike框架" class="headerlink" title="1.2 Spike框架"></a>1.2 Spike框架</h3><p>Spike是一个模糊器创建工具包，它提供了API，允许用户基于网络的协议来创建自己的fuzzer。其中包含一些通用的模糊测试器。</p><h3 id="1-3-网络协议模糊测试"><a href="#1-3-网络协议模糊测试" class="headerlink" title="1.3 网络协议模糊测试"></a>1.3 网络协议模糊测试</h3><p>对网络协议进行模糊测试也需要识别出可被攻击的接口，通过变异或生成方式得到能够触发错误的模糊测试值，然后将这些模糊测试值发送给目标应用，监视目标应用的错误。</p><h2 id="2-基本过程"><a href="#2-基本过程" class="headerlink" title="2. 基本过程"></a>2. 基本过程</h2><ul><li>确定测试的目标</li><li>确定输入的向量</li><li>生成模糊测试数据，可由测试工具通过随机或是半随机的方式生成</li><li>执行模糊数据测试</li><li>监视异常</li><li>判定发现的漏洞是否可能被利用</li></ul><h2 id="3-测试方法分类"><a href="#3-测试方法分类" class="headerlink" title="3. 测试方法分类"></a>3. 测试方法分类</h2><ul><li>基于<code>变异</code>的模糊测试——简而言之就是正常调用协议，抓包，然后混淆数据包达到生成异常数据包的结果，从而进行测试。</li></ul><blockquote><p>这种方法对已有的正常数据集依赖较高。需要有足够丰富的合法输入从而产生足够丰富的测试类型。</p></blockquote><p>例如，png图片除了文件头后面数据内容进行置换混淆得到异常测试数据。</p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/png1.png" srcset="/img/loading.gif" alt=""></p><ul><li>基于<code>生成</code>的模糊测试——简而言之就是理解协议规约定义，创建文法自动生成动态模糊的测试用例。</li></ul><blockquote><p>这种方法对协议的理解掌握程度需求更高。难度更大。</p></blockquote><p>http的post请求如图，其中fuzzable的点可用来生成测试例子。</p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/http-post.png" srcset="/img/loading.gif" alt=""></p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/http-fuzz.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-困难点"><a href="#4-困难点" class="headerlink" title="4. 困难点"></a>4. 困难点</h2><p>协议分析，对于特定的程序与配套协议，需要对程序段进行逆向分析才能得到<br>协议内容以创建测试样例，而其中逆向分析工作难度与工作量都较大。</p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
      <tag>模糊测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识复习(1)--基本命令</title>
    <link href="/2020/06/01/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0-1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/06/01/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0-1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>很久没有使用Linux，基础知识也忘了不少。</p><p>找了本<a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf" target="_blank" rel="noopener">参考书</a>顺带复习一下Linux的部分基础知识。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="常用工作命令"><a href="#常用工作命令" class="headerlink" title="常用工作命令"></a>常用工作命令</h3><ul><li><p><code>echo</code>：用于在终端输出字符串或变量提取后的值</p><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> Hello!Hello!$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>/bin/bash</code></pre></li><li><p><code>reboot</code>：重启系统</p></li><li><p><code>poweroff</code>：关闭系统</p></li><li><p><code>wget</code>：下载网络文件</p><pre><code class="hljs bash">$ wget http://www.linuxprobe.com/docs/LinuxProbe.pdf</code></pre></li><li><p><code>ps</code>：查看系统中的进程状态</p><pre><code class="hljs bash">$ ps -a(all) -u(user)</code></pre></li><li><p><code>top</code>：动态地监视进程活动与系统负载等信息</p></li><li><p><code>pidof</code>：查询某个指定服务进程的 PID 值</p><pre><code class="hljs bash">$ pidof sshd23587 798</code></pre></li><li><p><code>kill</code>：终止某个指定 PID 的服务进程</p><pre><code class="hljs bash">$ <span class="hljs-built_in">kill</span> 23587</code></pre></li><li><p><code>killall</code>：终止某个指定名称的服务所对应的全部进程</p><pre><code class="hljs bash">$ killall sshd</code></pre></li></ul><h3 id="系统状态命令"><a href="#系统状态命令" class="headerlink" title="系统状态命令"></a>系统状态命令</h3><ul><li><code>ifconfig</code>：用于获取网卡配置与网络状态等信息</li><li><code>uname</code>：用于查看系统内核与系统版本等信息 -a</li><li><code>free</code>：用于显示当前系统中内存的使用量信息</li><li><code>who</code>：用于查看当前登入主机的用户终端信息(whoami)</li><li><code>history</code>：用于显示历史执行过的命令（清除 -c）</li></ul><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><code>pwd</code>：显示用户当前所处的工作目录</li><li><code>cd</code>：切换工作路径</li><li><code>ls</code>：显示目录中文件信息（所有文件-a，详细信息-l）</li></ul><h3 id="文件编辑命令"><a href="#文件编辑命令" class="headerlink" title="文件编辑命令"></a>文件编辑命令</h3><ul><li><p><code>cat</code>：查看纯文本文件（较少）</p></li><li><p><code>more</code>：查看纯文本文件（较多）</p></li><li><p><code>head</code>：查看纯文本文档的前 n行</p><pre><code class="hljs bash">$ head -n 20 /etc/passwd</code></pre></li><li><p><code>tail</code>：查看纯文本文档的后 N 行或持续刷新内容</p><pre><code class="hljs bash">$ tail -n 20 /etc/passwd$ tail -f /var/<span class="hljs-built_in">log</span>/message</code></pre></li><li><p><code>tr</code>：替换文本文件中的字符</p><pre><code class="hljs bash">$ cat anaconda-ks.cfg | tr [a-z] [A-Z]</code></pre></li><li><p><code>wc</code>：统计指定文本的行数-l、字数-w、字节数-c</p><pre><code class="hljs bash">$ wc -l /etc/passwd</code></pre></li><li><p><code>stat</code>：查看文件的具体存储信息和时间等信息</p><pre><code class="hljs bash">$ <span class="hljs-built_in">stat</span> /etc/passwd</code></pre></li><li><p><code>diff</code>：比较多个文本文件的差异</p><pre><code class="hljs bash">$ diff diff_a.txt diff_b.txt</code></pre></li></ul><h3 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h3><ul><li><p><code>touch</code>：创建空白文件或设置文件的时间</p><pre><code class="hljs bash">$ touch touch_a.txt</code></pre></li><li><p><code>mkdir</code>：创建空白目录</p><pre><code class="hljs bash">$ mkdir ~/mkdir_a</code></pre></li><li><p><code>cp</code>：用于复制文件和目录</p><pre><code class="hljs bash">$ cp install.log x.log$ cp -r /etc ~/mkdir_a</code></pre></li><li><p><code>mv</code>：剪切文件或将文件重命名</p><pre><code class="hljs bash">$ mv x.log linux.log</code></pre></li><li><p><code>rm</code>：删除文件或目录</p><pre><code class="hljs bash">$ rm -f install.log$ rm -rf ~/mkdir_a</code></pre></li><li><p><code>dd</code>：按照指定大小和个数的数据块来复制文件或转换文件</p><pre><code class="hljs bash">$ dd <span class="hljs-keyword">if</span>=/dev/zero of=560_file count=1 bs=560M<span class="hljs-comment"># if为输入文件，of为输出文件，count为块数 bs为每个块大小</span>1+0 records <span class="hljs-keyword">in</span>1+0 records out587202560 bytes (587 MB, 560 MiB) copied, 3.49432 s, 168 MB/s</code></pre></li><li><p><code>file</code>：查看文件的类型</p><pre><code class="hljs bash">$ file 560_file560_file: data</code></pre></li></ul><h3 id="压缩搜索命令"><a href="#压缩搜索命令" class="headerlink" title="压缩搜索命令"></a>压缩搜索命令</h3><ul><li><p><code>tar</code>：对文件进行打包压缩或解压</p><pre><code class="hljs bash">$ tar -czvf etc.tar.gz /etc<span class="hljs-comment"># 压缩</span>$ tar -xzvf etc.tar.gz -C /root/etc <span class="hljs-comment"># 解压</span></code></pre></li><li><p><code>grep</code>：在文本中执行关键词搜索，并显示匹配的结果</p><pre><code class="hljs bash">$ grep /sbin/nologin /etc/passwd<span class="hljs-comment"># -n 显示行号； -v 反选信息</span></code></pre></li><li><p><code>find</code>：按照指定条件来查找文件</p><pre><code class="hljs bash">$ find /etc -name <span class="hljs-string">"host*"</span> -<span class="hljs-built_in">print</span><span class="hljs-comment"># 获取到/etc中所有以 host 开头的文件列表</span>$ find / -perm -4000 -<span class="hljs-built_in">print</span><span class="hljs-comment"># 在整个系统中搜索权限中包括 SUID 权限的所有文件</span>$ find / -user linuxprobe -<span class="hljs-built_in">exec</span> cp -a &#123;&#125; /root/findresults/ \;<span class="hljs-comment"># 在整个文件系统中找出所有归属于 linuxprobe 用户的文件并复制到/root/findresults 目录</span><span class="hljs-comment"># 命令的结尾必须是“\;”！！！</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo个人博客</title>
    <link href="/2020/05/24/%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/05/24/%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个快速、简洁且高效的博客框架。</p><p>Hexo主题较多，使用也比较方便，搭建一个博客记录生活学习。</p><p>环境搭建比较简单，记录一下中间遇到的小问题和主题的设置。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>下载安装node.js（建议安装10.0版本以上）</li><li>下载安装git</li><li>下载安装hexo， <code>npm install -g hexo</code> （建议终端走代理）</li></ul><h3 id="本地搭建测试"><a href="#本地搭建测试" class="headerlink" title="本地搭建测试"></a>本地搭建测试</h3><ul><li>本地创建一个文件夹，如xxxblog</li><li>bash中切换到xxxblog目录下，输入 <code>hexo init</code></li><li>运行<code>hexo s</code>打开服务</li><li>本地localhost:4000上应该有博客的基本模板，本地搭建完成</li></ul><h3 id="关联git"><a href="#关联git" class="headerlink" title="关联git"></a>关联git</h3><ul><li>git与本地连接</li></ul><p>绑定信息：</p><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">"你的GitHub用户名"</span>$ git config --global user.email <span class="hljs-string">"你的GitHub绑定的邮箱"</span></code></pre><p>然后生成密钥SSH key：</p><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">"你的GitHub绑定的邮箱"</span></code></pre><p>获取生成的密钥信息放入GitHub-&gt;Settings-&gt;SSH and GPG keys：</p><pre><code class="hljs bash">$ cat ~/.ssh/id_rsa.pub</code></pre><ul><li>git与博客绑定</li></ul><p>在Github上创建名字为<code>xxx,github.io</code>的项目，xxx为你的GitHub用户名，之后均用LeeX0示例。</p><p>打开xxxblog中的_config.yml，将其中的deployment选项的内容改为：</p><pre><code class="hljs xml">deploy:  type: git  repo:     github: git@github.com:LeeX0/LeeX0.github.io.git,master</code></pre><p>ps：如果之后推送时显示403错误，将其中的<code>repo: github: git@github.com:LeeX0/LeeX0.github.io.git,master</code></p><p>改为<code>repo: https://GitHub用户名:GitHub密码@github.com/LeeX0/LeeX0.github.io.git</code>尝试</p><ul><li><p>运行<code>npm install hexo-deployer-git –save</code>安装部署工具</p></li><li><p>运行推送</p><pre><code class="hljs bash">$ hexo clean<span class="hljs-comment"># clean 清除本地静态文件</span>$ hexo g<span class="hljs-comment"># generate 生成本地静态文件</span>$ hexo d<span class="hljs-comment"># deploy 推送部署文件至GitHub</span></code></pre></li><li><p>访问leex0.github.io即可查看博客</p></li></ul><h2 id="博客基本使用"><a href="#博客基本使用" class="headerlink" title="博客基本使用"></a>博客基本使用</h2><ul><li>新建文章</li></ul><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"postname"</span><span class="hljs-comment"># 创建新文章</span></code></pre><p>会在source-&gt;_posts文件夹内生成一个postname.md文件，用markdown格式进行编辑。</p><p>其中front-matter字段主要有：title 文章的标题、date 创建日期 、tags 标签、categories 分类。</p><p>tags 、categories写法建议:</p><pre><code class="hljs xml">tags: - [tag1]- [tag2]categories:- [cate1]- [cate2-1,cate2-2]</code></pre><ul><li>插入图片</li></ul><p>文章插入图片source-&gt;image下，对应文件夹markdown相对路径即可/image/xxx.jpg。</p><ul><li>生成推送</li></ul><p>之后运行推送即可</p><pre><code class="hljs bash">$ hexo clean<span class="hljs-comment"># clean 清除本地静态文件</span>$ hexo g<span class="hljs-comment"># generate 生成本地静态文件</span>$ hexo d<span class="hljs-comment"># deploy 推送部署文件至GitHub</span></code></pre><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>其中<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网展示的主题</a>已经比较多了，<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">知乎的问答</a>也有比较多推荐。</p><p>我是用的<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid</a>主题，介绍一下这个主题的设置。</p><ul><li>下载主题</li></ul><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/archive/v1.8.0.zip" target="_blank" rel="noopener">下载</a>最新主题版本，下载后解压到 themes 目录下并重命名为 fluid。</p><ul><li>修改配置</li></ul><p>修改Hexo目录下的<code>_config.yml</code>：</p><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span>Language: zh-CN  <span class="hljs-comment"># 指定语言，可不改</span></code></pre><p>之后正常生成推送即可，更多设置可参考<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
