<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker实践——操作容器</title>
    <link href="/2021/03/22/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/03/22/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h3><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><pre><code class="hljs bash">$ docker run ubuntu:18.04 /bin/<span class="hljs-built_in">echo</span> <span class="hljs-string">'Hello world'</span>Hello world</code></pre><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><pre><code class="hljs bash">$ docker run -t -i ubuntu:18.04 /bin/bashroot@af8bae53bdd3:/<span class="hljs-comment">#</span></code></pre><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><pre><code class="hljs bash">root@74e4ce548f2e:/<span class="hljs-comment"># pwd</span>/root@74e4ce548f2e:/<span class="hljs-comment"># ls</span>bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  varroot@74e4ce548f2e:/<span class="hljs-comment">#</span></code></pre><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从 <a href="">registry</a> 下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><pre><code class="hljs bash">root@ba267838cc1b:/<span class="hljs-comment"># ps</span>  PID TTY          TIME CMD    1 ?        00:00:00 bash   11 ?        00:00:00 ps</code></pre><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h3 id="2-守护态运行"><a href="#2-守护态运行" class="headerlink" title="2. 守护态运行"></a>2. 守护态运行</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><pre><code class="hljs bash">$ docker run ubuntu:18.04 /bin/sh -c <span class="hljs-string">"while true; do echo hello world; sleep 1; done"</span>hello worldhello worldhello worldhello world</code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><pre><code class="hljs bash">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="hljs-string">"while true; do echo hello world; sleep 1; done"</span>439564c20b1720238739ce01c54e7d6dcda6284a3a8f8994c9d28097cad72790</code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><blockquote><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p></blockquote><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><pre><code class="hljs bash">$ docker container lsCONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS     NAMES439564c20b17   ubuntu:18.04   <span class="hljs-string">"/bin/sh -c 'while t…"</span>   6 minutes ago   Up 6 minutes             ecstatic_antonelli</code></pre><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><pre><code class="hljs bash">$ docker container logs [container ID or NAMES]hello worldhello worldhello world. . .</code></pre><h3 id="3-终止"><a href="#3-终止" class="headerlink" title="3. 终止"></a>3. 终止</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><pre><code class="hljs bash">$ docker container stop 439439</code></pre><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><pre><code class="hljs bash">$ docker container ls -aCONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                        PORTS     NAMES439564c20b17   ubuntu:18.04   <span class="hljs-string">"/bin/sh -c 'while t…"</span>   9 minutes ago    Exited (137) 38 seconds ago             ecstatic_antonelli98f27ac5ddc4   ubuntu:18.04   <span class="hljs-string">"/bin/sh -c 'while t…"</span>   9 minutes ago    Exited (0) 9 minutes ago                unruffled_shirley74e4ce548f2e   ubuntu:18.04   <span class="hljs-string">"/bin/bash"</span>              16 minutes ago   Exited (0) 15 minutes ago               ecstatic_jemison5cc8c294fe40   ubuntu:18.04   <span class="hljs-string">"/bin/echo 'Hello wo…"</span>   17 minutes ago   Exited (0) 17 minutes ago               vibrant_buck</code></pre><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><pre><code class="hljs bash">$ docker container start 439439</code></pre><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h3 id="4-进入容器"><a href="#4-进入容器" class="headerlink" title="4. 进入容器"></a>4. 进入容器</h3><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><p>下面示例如何使用 <code>docker attach</code> 命令。</p><pre><code class="hljs bash">$ docker run -dit ubuntuf780a070123a203ab14b1632c9fe51850568baa8ae906e1fc006f21b1b763cde$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMESf780a070123a   ubuntu    <span class="hljs-string">"/bin/bash"</span>   7 seconds ago   Up 6 seconds             interesting_almeida$ docker attach f780root@f780a070123a:/<span class="hljs-comment"># pwd</span>/root@f780a070123a:/<span class="hljs-comment">#</span></code></pre><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><p><code>-i</code> <code>-t</code> 参数</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre><code class="hljs bash">$ docker run -dit ubuntubf85753fd26a3af4ee9a600dd41010e5f6f6ea2a7eb059dd017010d7f47f99b7$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMESbf85753fd26a   ubuntu    <span class="hljs-string">"/bin/bash"</span>   7 seconds ago   Up 7 seconds             loving_tharp$ docker <span class="hljs-built_in">exec</span> -i bf857 bashlsbinboot...$ docker <span class="hljs-built_in">exec</span> -it bf857 bashroot@bf85753fd26a:/<span class="hljs-comment"># pwd</span>/root@bf85753fd26a:/<span class="hljs-comment">#</span></code></pre><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p><h3 id="5-导出和导入"><a href="#5-导出和导入" class="headerlink" title="5. 导出和导入"></a>5. 导出和导入</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><pre><code class="hljs bash">$ docker container ls -aCONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                       PORTS     NAMESbf85753fd26a   ubuntu         <span class="hljs-string">"/bin/bash"</span>              5 minutes ago    Up 5 minutes                           loving_tharpf780a070123a   ubuntu         <span class="hljs-string">"/bin/bash"</span>              7 minutes ago    Exited (0) 6 minutes ago               interesting_almeida$ docker <span class="hljs-built_in">export</span> bf8 &gt; ubuntu.tar</code></pre><p>这样将导出容器快照到本地文件。</p><h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><pre><code class="hljs bash">$ docker import ubuntu.tar <span class="hljs-built_in">test</span>/ubuntu:v1.0sha256:a2096fd67aaa28187fda28a9c3c6a1f9184a13c589f0f5d9eb11dd554cb8d6e5$ docker image lsREPOSITORY    TAG       IMAGE ID       CREATED          SIZE<span class="hljs-built_in">test</span>/ubuntu   v1.0      a2096fd67aaa   10 seconds ago   72.9MBhello-world   latest    d1165f221234   2 weeks ago      13.3kBubuntu        latest    f643c72bc252   3 months ago     72.9MBubuntu        18.04     2c047404e52d   3 months ago     63.3MB</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><pre><code class="hljs bash">$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><p><em>注：用户既可以使用</em> <em><code>docker load</code></em> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <em><code>docker import</code></em> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h3 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><pre><code class="hljs bash">$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMESbf85753fd26a   ubuntu    <span class="hljs-string">"/bin/bash"</span>   43 minutes ago   Up 43 minutes             loving_tharp$ docker container rm bf85Error response from daemon: You cannot remove a running container bf85753fd26a3af4ee9a600dd41010e5f6f6ea2a7eb059dd017010d7f47f99b7. Stop the container before attempting removal or force remove$ docker container stop bf85bf85$ docker container rm bf85bf85</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h4 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h4><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><pre><code class="hljs bash">$ docker container prune</code></pre><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——使用镜像</title>
    <link href="/2021/03/22/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F/"/>
    <url>/2021/03/22/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><pre><code class="hljs bash">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></pre><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><pre><code class="hljs bash">$ docker pull ubuntu:18.0418.04: Pulling from library/ubuntu92dc2a97ff99: Pull completebe13a9d27eb8: Pull completec8299583700a: Pull completeDigest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:18.04docker.io/library/ubuntu:18.04</code></pre><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p><p>从下载过程中可以看到表现出了分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。</p><p>下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><pre><code class="hljs bash">$ docker run -it --rm ubuntu:18.04 bashroot@e7009c6ce357:/<span class="hljs-comment"># cat /etc/os-release</span>NAME=<span class="hljs-string">"Ubuntu"</span>VERSION=<span class="hljs-string">"18.04.1 LTS (Bionic Beaver)"</span>ID=ubuntuID_LIKE=debianPRETTY_NAME=<span class="hljs-string">"Ubuntu 18.04.1 LTS"</span>VERSION_ID=<span class="hljs-string">"18.04"</span>HOME_URL=<span class="hljs-string">"https://www.ubuntu.com/"</span>SUPPORT_URL=<span class="hljs-string">"https://help.ubuntu.com/"</span>BUG_REPORT_URL=<span class="hljs-string">"https://bugs.launchpad.net/ubuntu/"</span>PRIVACY_POLICY_URL=<span class="hljs-string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span>VERSION_CODENAME=bionicUBUNTU_CODENAME=bionic</code></pre><p><code>docker run</code> 就是运行容器的命令，简要的说明一下上面用到的参数（更多参数见“操作容器”一文）。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h3 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2. 列出镜像"></a>2. 列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><pre><code class="hljs bash">$ docker image lsREPOSITORY                TAG       IMAGE ID       CREATED        SIZEleex0/docker101tutorial   latest    4c500ed7d6b5   28 hours ago   27.9MBdocker101tutorial         latest    4c500ed7d6b5   28 hours ago   27.9MBnginx                     latest    6084105296a9   9 days ago     133MBalpine/git                latest    a939554ad0d0   4 weeks ago    25.1MB</code></pre><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>使用 <code>docker image ls</code> 命令会与Docker Hub 上看到的镜像大小不同。因为Docker Hub上的镜像体积为压缩过的体积，方便网络传输。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><pre><code class="hljs bash">$ docker system dfTYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLEImages          3         2         180.5MB   138.7MB (76%)Containers      2         0         1.114kB   1.114kB (100%)Local Volumes   1         1         10.24MB   0B (0%)Build Cache     32        0         395MB     395MB</code></pre><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>此外有时还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p><pre><code class="hljs bash">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</code></pre><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><pre><code class="hljs bash">$ docker image ls -f dangling=<span class="hljs-literal">true</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</code></pre><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><pre><code class="hljs bash">$ docker image prune</code></pre><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><pre><code class="hljs plain">$ docker image ls -a</code></pre><p>这些镜像在<code>-a</code>列出来后也无标签，但平时无需处理。删除依赖中间层镜像的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><pre><code class="hljs bash"><span class="hljs-comment"># 根据仓库名列出镜像</span>$ docker image ls ubuntuREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MBubuntu              bionic              329ed837d508        3 days ago          63.3MB<span class="hljs-comment"># 列出特定的某个镜像，也就是说指定仓库名和标签</span>$ docker image ls ubuntu:18.04REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MB<span class="hljs-comment"># 除此以外，`docker image ls` 还支持强大的过滤器参数 `--filter`，或者简写 `-f`</span><span class="hljs-comment"># 比如，之前查看虚悬镜像，或我们希望看到在 `mongo:3.2` 之后建立的镜像，可以用下面的命令：</span>$ docker image ls -f since=mongo:3.2REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEredis               latest              5f515359c7f8        5 days ago          183 MBnginx               latest              05a60462f8ba        5 days ago          181 MB<span class="hljs-comment"># 想查看某个位置之前的镜像也可以，只需要把 `since` 换成 `before` 即可。</span><span class="hljs-comment"># 此外，如果镜像构建时，定义了 `LABEL`，还可以通过 `LABEL` 来过滤。</span>$ docker image ls -f label=com.example.version=0.1...</code></pre><h5 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h5><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><pre><code class="hljs bash">$ docker image ls --format <span class="hljs-string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span>5f515359c7f8: redis05a60462f8ba: nginxfe9198c04d62: mongo00285df0df87: &lt;none&gt;329ed837d508: ubuntu329ed837d508: ubuntu</code></pre><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><pre><code class="hljs bash">$ docker image ls --format <span class="hljs-string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span>IMAGE ID            REPOSITORY          TAG5f515359c7f8        redis               latest05a60462f8ba        nginx               latestfe9198c04d62        mongo               3.200285df0df87        &lt;none&gt;              &lt;none&gt;329ed837d508        ubuntu              18.04329ed837d508        ubuntu              bionic</code></pre><h3 id="3-删除本地镜像"><a href="#3-删除本地镜像" class="headerlink" title="3. 删除本地镜像"></a>3. 删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><pre><code class="hljs bash">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></pre><h4 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h4><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><pre><code class="hljs bash">$ docker image lsREPOSITORY    TAG       IMAGE ID       CREATED       SIZEhello-world   latest    d1165f221234   2 weeks ago   13.3kB</code></pre><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><pre><code class="hljs bash">$ docker image rm d11Untagged: hello-world:latestUntagged: hello-world@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:d11ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899bDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2faDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</code></pre><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><pre><code class="hljs bash">$ docker image rm hello-worldUntagged: hello-world:latestUntagged: hello-world@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8aDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</code></pre><h4 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h4><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。</p><p>镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h4 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h4><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><pre><code class="hljs bash">$ docker image rm $(docker image ls -q redis)</code></pre><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><pre><code class="hljs bash">$ docker image rm $(docker image ls -q -f before=mongo:3.2)</code></pre><p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——概念与安装</title>
    <link href="/2021/03/21/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <url>/2021/03/21/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h3><p>Docker主要包括三个概念<strong>镜像</strong>、<strong>容器</strong>、<strong>仓库</strong>。</p><h4 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a><strong>镜像</strong>（<code>Image</code>）</h4><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a><strong>容器</strong>（<code>Container</code>）</h4><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p><h4 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a><strong>仓库</strong>（<code>Repository</code>）</h4><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><h4 id="Docker与传统虚拟化区别"><a href="#Docker与传统虚拟化区别" class="headerlink" title="Docker与传统虚拟化区别"></a>Docker与传统虚拟化区别</h4><p><img src="/image/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/virtualization.png" srcset="/img/loading.gif" alt="virtualization"></p><p><img src="/image/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/docker.png" srcset="/img/loading.gif" alt="docker"></p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h3><h4 id="2-1-Ubuntu下安装"><a href="#2-1-Ubuntu下安装" class="headerlink" title="2.1 Ubuntu下安装"></a>2.1 Ubuntu下安装</h4><h5 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h5><pre><code class="hljs bash">sudo apt-get remove docker docker-engine docker.io</code></pre><h5 id="向-sources-list-中添加-Docker-软件源"><a href="#向-sources-list-中添加-Docker-软件源" class="headerlink" title="向 sources.list 中添加 Docker 软件源"></a>向 <code>sources.list</code> 中添加 Docker 软件源</h5><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><span class="hljs-string">  <span class="hljs-variable">$(lsb_release -cs)</span> stable"</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null<span class="hljs-comment"># 官方源</span><span class="hljs-comment"># echo \</span><span class="hljs-comment">#   "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><span class="hljs-comment"># $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></code></pre><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p></blockquote><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre><code class="hljs bash"><span class="hljs-comment"># sudo apt-get update</span>sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre><h5 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h5><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p><pre><code class="hljs bash"><span class="hljs-comment"># curl -fsSL test.docker.com -o get-docker.sh</span>curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun<span class="hljs-comment"># sudo sh get-docker.sh --mirror AzureChinaCloud</span></code></pre><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> dockersudo systemctl start docker</code></pre><h5 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h5><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><pre><code class="hljs bash">sudo groupadd docker</code></pre><p>将当前用户加入 <code>docker</code> 组：</p><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></code></pre><p>退出当前终端并重新登录，进行如下测试。</p><pre><code class="hljs bash">docker run --rm hello-world</code></pre><p>若能正常输出以上信息，则说明安装成功。</p><h4 id="2-2-MacOS下安装"><a href="#2-2-MacOS下安装" class="headerlink" title="2.2 MacOS下安装"></a>2.2 MacOS下安装</h4><p>使用brew即可进行快速安装</p><pre><code class="hljs bash">brew install --cask docker</code></pre><p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener">Nginx 服务器</a>：</p><pre><code class="hljs bash">docker run -d -p 80:80 --name webserver nginx</code></pre><p>服务运行后，可以访问 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>，如果看到了 “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p><h4 id="2-3-镜像加速"><a href="#2-3-镜像加速" class="headerlink" title="2.3 镜像加速"></a>2.3 镜像加速</h4><p>aliyun：<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云加速器(点击管理控制台 -&gt; 登录账号(淘宝账号) -&gt; 左侧镜像中心 -&gt; 镜像加速器 -&gt; 复制地址)</a></p><p>DaoCloud：<a href="http://f1361db2.m.daocloud.io" target="_blank" rel="noopener">http://f1361db2.m.daocloud.io</a></p><ul><li>Ubuntu</li></ul><p>可在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"registry-mirrors"</span>: [    <span class="hljs-string">"https://hub-mirror.c.163.com"</span>,    <span class="hljs-string">"https://mirror.baidubce.com"</span>  ]&#125;</code></pre><p>也可使用DaoCloud服务提供的一键换镜像站脚本：</p><pre><code class="hljs bash">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</code></pre><p>之后重新启动服务。</p><pre><code class="hljs bash">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><ul><li>macOS</li></ul><p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像上述Ubuntu中json一样编辑 json 文件。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。</p><ul><li>检查加速器生效</li></ul><p>执行<code>docker info</code>，若在结果中看到了如下则生效：</p><pre><code class="hljs json">Registry Mirrors: https://5503mc71.mirror.aliyuncs.com/</code></pre><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbook.io/docker_practice/</a></p><p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brew权限问题与Mac使用指定程序打开</title>
    <link href="/2021/03/11/brew%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%E4%B8%8EMac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E7%A8%8B%E5%BA%8F%E6%89%93%E5%BC%80/"/>
    <url>/2021/03/11/brew%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%E4%B8%8EMac%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E7%A8%8B%E5%BA%8F%E6%89%93%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Mac命令行指定特定程序打开文件-a"><a href="#Mac命令行指定特定程序打开文件-a" class="headerlink" title="Mac命令行指定特定程序打开文件 -a"></a>Mac命令行指定特定程序打开文件 -a</h3><pre><code class="hljs bash">open -a /Applications/Sublime\ Text.app/ httpd.conf</code></pre><h3 id="brew-Permission-Denied-问题解决"><a href="#brew-Permission-Denied-问题解决" class="headerlink" title="brew Permission Denied 问题解决"></a>brew <strong>Permission Denied</strong> 问题解决</h3><pre><code class="hljs bash">sudo chown -R $(whoami) /usr/<span class="hljs-built_in">local</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>HomeBrew</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aria2与Homebrew简记</title>
    <link href="/2021/03/10/aria2%E4%B8%8EHomebrew%E7%AE%80%E8%AE%B0/"/>
    <url>/2021/03/10/aria2%E4%B8%8EHomebrew%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h3><blockquote><p><a href="https://aria2.github.io/" target="_blank" rel="noopener">aria2</a>是一个自由、开源、轻量级多协议和多源的命令行下载工具，它支持 HTTP/HTTPS、FTP、SFTP、 BitTorrent 和 Metalink 协议。</p><p>brew install aria2</p></blockquote><pre><code class="hljs bash"><span class="hljs-comment"># 下载单个文件（支持使用种子文件与磁力链接）</span>aria2c https://x/owncloud-9.0.0.tar.bz2<span class="hljs-comment"># 下载多个文件</span>aria2c -Z https://x/owncloud-9.0.0.tar.bz2 https://y/owncloud-9.0.0.tar.bz2<span class="hljs-comment"># 另存文件名字</span>aria2c -o owncloud.zip https://x/owncloud-9.0.0.tar.bz2<span class="hljs-comment"># 续传未完成的下载（中断使用.aria2后缀保存文件，下次重启任务后续传）</span>aria2c -c https://x/owncloud-9.0.0.tar.bz2<span class="hljs-comment"># 从文件获取输入（可传入URL列表）</span>aria2c -i <span class="hljs-built_in">test</span>-aria2.txt<span class="hljs-comment"># 其他</span>-D 后台下载--conf-path=<span class="hljs-string">"~/.aria2/aria2.conf"</span> 配置文件-s 设置线程数-max-download-limit 设置最大下载速度-x3 到服务器的连接数--http-user=xxx --http-password=xxx http密码下载--ftp-user=xxx --ftp-password=xxx ftp密码下载</code></pre><p>配置文件可参考：</p><pre><code class="hljs bash"><span class="hljs-comment">#用户名</span><span class="hljs-comment">#rpc-user=user</span><span class="hljs-comment">#密码</span><span class="hljs-comment">#rpc-passwd=passwd</span><span class="hljs-comment">#上面的认证方式不建议使用,建议使用下面的token方式</span><span class="hljs-comment">#设置加密的密钥</span><span class="hljs-comment">#rpc-secret=token</span><span class="hljs-comment">#允许rpc</span><span class="hljs-built_in">enable</span>-rpc=<span class="hljs-literal">true</span><span class="hljs-comment">#允许所有来源, web界面跨域权限需要</span>rpc-allow-origin-all=<span class="hljs-literal">true</span><span class="hljs-comment">#允许外部访问，false的话只监听本地端口</span>rpc-listen-all=<span class="hljs-literal">true</span><span class="hljs-comment">#RPC端口, 仅当默认端口被占用时修改</span><span class="hljs-comment">#rpc-listen-port=6800</span><span class="hljs-comment">#最大同时下载数(任务数), 路由建议值: 3</span>max-concurrent-downloads=5<span class="hljs-comment">#断点续传</span><span class="hljs-built_in">continue</span>=<span class="hljs-literal">true</span><span class="hljs-comment">#同服务器连接数</span>max-connection-per-server=5<span class="hljs-comment">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span>min-split-size=10M<span class="hljs-comment">#单文件最大线程数, 路由建议值: 5</span>split=10<span class="hljs-comment">#下载速度限制</span>max-overall-download-limit=0<span class="hljs-comment">#单文件速度限制</span>max-download-limit=0<span class="hljs-comment">#上传速度限制</span>max-overall-upload-limit=0<span class="hljs-comment">#单文件速度限制</span>max-upload-limit=0<span class="hljs-comment">#断开速度过慢的连接</span><span class="hljs-comment">#lowest-speed-limit=0</span><span class="hljs-comment">#验证用，需要1.16.1之后的release版本</span><span class="hljs-comment">#referer=*</span><span class="hljs-comment">#文件保存路径, 默认为当前启动位置</span>dir=/Users/xxx/Downloads<span class="hljs-comment">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span><span class="hljs-comment">#disk-cache=0</span><span class="hljs-comment">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span><span class="hljs-comment">#enable-mmap=true</span><span class="hljs-comment">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span><span class="hljs-comment">#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持</span>file-allocation=prealloc</code></pre><p>设置WebUI可参考<a href="https://ziahamza.github.io/webui-aria2/" target="_blank" rel="noopener">链接</a>。</p><h3 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h3><pre><code class="hljs bash"><span class="hljs-comment">## 管理HomeBrew</span><span class="hljs-comment"># 安装 HomeBrew</span>/usr/bin/ruby -e <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span><span class="hljs-comment"># 卸载 HomeBrew</span>ruby -e <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)</span>"</span><span class="hljs-comment"># 更新 HomeBrew</span>brew update<span class="hljs-comment"># 检视HomeBrew</span>brew doctor<span class="hljs-comment">## 管理软件</span><span class="hljs-comment"># 安装卸载更新软件</span>brew install wgetbrew uninstall wgetbrew uograde wget<span class="hljs-comment"># 列出安装的软件</span>brew list<span class="hljs-comment"># 列出安装的软件信息</span>brew info wget<span class="hljs-comment"># 检查软件库</span>brew search wget<span class="hljs-comment">## 管理服务</span><span class="hljs-comment"># 列出服务</span>brew services list<span class="hljs-comment"># 注销未使用服务</span>brew services cleanup<span class="hljs-comment"># 运行服务（不注册为跟随系统启动）</span>brew services run nginx<span class="hljs-comment"># 运行后台服务（注册为跟随系统启动）</span>brew services start nginx<span class="hljs-comment"># 暂停并注销服务</span>brew services stop nginx<span class="hljs-comment"># 重启并注册服务</span>brew services restart nginx</code></pre><blockquote><p>参考：</p><p><a href="https://wild-flame.github.io/guides/docs/mac-os-x-setup-guide/aria_2/readme" target="_blank" rel="noopener">https://wild-flame.github.io/guides/docs/mac-os-x-setup-guide/aria_2/readme</a></p><p><a href="https://www.linuxprobe.com/aria2-download.html" target="_blank" rel="noopener">https://www.linuxprobe.com/aria2-download.html</a></p><p><a href="https://segmentfault.com/a/1190000018928643" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018928643</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aria2</tag>
      
      <tag>Homebrew</tag>
      
      <tag>Terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《史蒂夫·乔布斯传》摘录</title>
    <link href="/2021/02/25/%E3%80%8A%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E3%80%8B%E6%91%98%E5%BD%95/"/>
    <url>/2021/02/25/%E3%80%8A%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E3%80%8B%E6%91%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《史蒂夫·乔布斯传》沃尔特·艾萨克森</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>一个具有强烈个性的人身上集合了人文和科学的天赋后所能产生的那种创造力，我相信这种创造力也是在21世纪建立创新型经济的关键因素。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>“有些人认为，因为我被亲生父母抛弃过，所以我非常努力地工作以求出人头地，这样我父母就会后悔当初的决定，还有一些类似的言论，都太荒谬了。”他坚称，“知道自己是被领养的也许让我感觉更加独立，但我从未感觉自己被抛弃过。我一直都觉得自己很特别。我的父母让我觉得自己很特别。”之后，每当有人称保罗和克拉拉为乔布斯的”养父母“或者暗示他俩不是他的”亲生父母“时，乔布斯就会异常愤怒。”他们百分之一千是我的父母。“他说。另一方面，当谈及他的亲生父母时，他显得很草率：“他们就是我的精子库和卵子库，这话并不过分，因为这就是事实，他们扮演的就是精子库的角色，仅此而已。”</p><blockquote><p>生活中确有的亲情，在内心的感受上要比血脉的相连来的更为直接。</p><p>或许随着年龄的生长才会越加注意血脉带来的感受吧。</p></blockquote><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>​ 宗教应该更多地强调精神体验，而不是一味遵守教条。“<strong>当基督教太过基于信仰，而忽略了以耶稣的生活方式或者从耶稣的角度看世界时，他的精髓就消失了，</strong>”他告诉我，“我觉得不同的宗教就好比通往同一栋房子的不同的门。有时候我觉得这栋房子存在，有时候我又觉得它不存在。这是最神秘的。”</p><h3 id="4"><a href="#4" class="headerlink" title="# 4"></a># 4</h3><p><strong>求知若饥，虚心若愚。</strong></p><p><strong>Stay hungry, Stay foolish.</strong></p><h3 id="5"><a href="#5" class="headerlink" title="# 5"></a># 5</h3><p>苦行和极简将会让人更加敏锐。“他相信匮乏即是富足，自律产生喜悦。”她说，“他知道一个大多数人不知道的道理：物极必反。”</p><h3 id="6"><a href="#6" class="headerlink" title="# 6"></a># 6</h3><p><strong>简洁并不仅仅是视觉上的，也不仅仅是把杂乱无章的东西变少或者抹掉，而是要挖掘复杂性的深度。</strong>要想获得简洁，你就必须要挖的足够深。打个比方，如果你是为了在产品上不装螺丝钉，那你最后可能会造出一个极其繁琐复杂的东西。<strong>更好的方式，是更深刻地理解“简洁”一词，理解他的每一个部分，以及它是如何制造的。你必须深刻的把握产品的精髓，从而判断出哪些不重要的部件是可以拿掉的。</strong></p><h3 id="7"><a href="#7" class="headerlink" title="# 7"></a># 7</h3><p><strong>记住自己很快就要死了，这是我面对人生重大选择时最重要的工具。因为，几乎一切——所有外界的期望，所有骄傲，所有对于困窘和失败的恐惧——这些东西都在死亡面前烟消云散，只留下真正重要的东西。记住自己终会死去，是我所知最好的方式，避免陷入认为自己会失去什么的陷阱。你已是一无所有，没理由不追随内心。</strong></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘录</tag>
      
      <tag>史蒂夫·乔布斯</tag>
      
      <tag>沃尔特·艾萨克森</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS清除DNS缓存</title>
    <link href="/2021/01/15/MacOS%E6%B8%85%E9%99%A4DNS%E7%BC%93%E5%AD%98/"/>
    <url>/2021/01/15/MacOS%E6%B8%85%E9%99%A4DNS%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs bash">sudo killall -HUP mDNSRespondersudo killall mDNSResponderHelpersudo dscacheutil -flushcache</code></pre>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《假面山庄》摘录</title>
    <link href="/2020/12/24/%E3%80%8A%E5%81%87%E9%9D%A2%E5%B1%B1%E5%BA%84%E3%80%8B%E6%91%98%E5%BD%95/"/>
    <url>/2020/12/24/%E3%80%8A%E5%81%87%E9%9D%A2%E5%B1%B1%E5%BA%84%E3%80%8B%E6%91%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《假面山庄》东野圭吾</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>人在谈论别人的事时，都能保持冷静，一旦遇到和自己密切相关的事，就会突然感情用事，难以决断。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>大部分人在痛苦面前都会选择放弃。一旦身处困境，首先想的就是逃避，要不就是自暴自弃、萎靡不振，把自己当成悲剧的主人公。</p><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>我希望自己对人人都好，但我这么对你，并不单单是这个原因。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>假面山庄</tag>
      
      <tag>东野圭吾</tag>
      
      <tag>摘录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux:进程与线程、文件描述符与重定向(补)</title>
    <link href="/2020/12/19/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91-%E8%A1%A5/"/>
    <url>/2020/12/19/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91-%E8%A1%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="Q1：与Windows下进程线程区别？"><a href="#Q1：与Windows下进程线程区别？" class="headerlink" title="Q1：与Windows下进程线程区别？"></a>Q1：与Windows下进程线程区别？</h3><p>Windows中<code>进程</code>只是作为<strong>资源的拥有者</strong>，并不是实际任务的执行者，<strong>实际的执行</strong>靠<code>线程</code>实现。</p><p>一个进程可以拥有多个线程，多个线程共享进程拥有的资源，同时可能具有自己的独占资源。在具体执行任务时由线程来使用处理机。</p><p>Windows中，进程实现靠createProcess实现。而createProcess有一大堆的参数，不过很多时候都默认为null。其作用相当于创建一个进程的同时创建一个线程（一般一个）。</p><p>而Linux中<strong>在 Linux 系统中，进程和线程几乎没有区别</strong>。</p><p>进程和线程都是实际运行的存在，都有一个类似的进程描述符（而Windows中线程不具有进程描述符，只描述一些少量的独有资源，所以很轻量）。</p><p><em>线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享</em>。</p><h3 id="Q2：如何理解Linux-shell中的“2-gt-amp-1”？"><a href="#Q2：如何理解Linux-shell中的“2-gt-amp-1”？" class="headerlink" title="Q2：如何理解Linux shell中的“2&gt;&amp;1”？"></a>Q2：如何理解Linux shell中的“2&gt;&amp;1”？</h3><pre><code class="hljs bash">./test.sh  &gt; log.txt 2&gt;&amp;1</code></pre><p>上面的调用表明将<code>./test.sh</code>的输出重定向到<code>log.txt</code>文件中，同时将标准错误也重定向到<code>log.txt</code>文件中。</p><p>每个程序在运行后，都会至少打开三个文件描述符，分别是0：标准输入；1：标准输出；2：标准错误。例如，对于前面的test.sh脚本它至少打开了三个文件描述符（可以在<code>/proc/&lt;pid&gt;/fd</code>目录下查到）。</p><p>那么现在就容易理解前面的疑问了，<code>2&gt;&amp;1</code>表明将文件描述2（标准错误输出）的内容重定向到文件描述符1（标准输出），为什么1前面需要&amp;？当没有&amp;时，1会被认为是一个普通的文件，<strong>有&amp;表示重定向的目标不是一个文件，而是一个文件描述符</strong>。在前面我们知道，test.sh &gt;log.txt又将文件描述符1的内容重定向到了文件log.txt，那么最终标准错误也会重定向到log.txt。</p><p>可以在<code>/proc/&lt;pid&gt;/fd</code>目录下查到重定向的情况文件，<strong>文件描述符1和2都指向了log.txt文件，</strong>也就得到了我们最终想要的效果：<strong>将标准错误输出重定向到文件中</strong>。</p><blockquote><p>程序运行后会打开三个文件描述符，分别是标准输入，标准输出和标准错误输出。</p><p>在调用脚本时，可使用2&gt;&amp;1来将标准错误输出重定向。</p><p>只需要查看脚本的错误时，可将标准输出重定向到文件，而标准错误会打印在控制台，便于查看。</p><p><code>&gt;&gt;log.txt</code>会将重定向内容追加到log.txt文件末尾。</p><p>通过查看<code>/proc/&lt;pid&gt;/fd</code>下的内容，可了解进程打开的文件描述符信息。</p></blockquote><h3 id="Q3：为什么command-gt-file-2-gt-amp-1不可以？"><a href="#Q3：为什么command-gt-file-2-gt-amp-1不可以？" class="headerlink" title="Q3：为什么command &gt; file 2&gt;&amp;1不可以？"></a>Q3：为什么<code>command &gt; file 2&gt;&amp;1</code>不可以？</h3><ul><li>对于<code>command &gt; file 2&gt;&amp;1</code>:</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 初始状态</span>0 -&gt; /dev/pts/71 -&gt; /dev/pts/72 -&gt; /dev/pts/7</code></pre><p>首先是<code>command &gt; file</code>将标准输出重定向到<code>file</code>中。</p><pre><code class="hljs bash"><span class="hljs-comment"># command &gt; file</span>0 -&gt; /dev/pts/71 -&gt; file2 -&gt; /dev/pts/7</code></pre><p><code>2&gt;&amp;1</code>是标准错误拷贝了标准输出的行为，也就是同样被重定向到<code>file</code>中。</p><pre><code class="hljs bash"><span class="hljs-comment"># 2&gt;&amp;1</span>0 -&gt; /dev/pts/71 -&gt; file2 -&gt; file</code></pre><p>最终结果就是标准输出和错误都被重定向到file中，正确。</p><ul><li>而对于<code>command 2&gt;&amp;1 &gt;file 2&gt;&amp;1</code>:</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># 初始状态</span>0 -&gt; /dev/pts/71 -&gt; /dev/pts/72 -&gt; /dev/pts/7</code></pre><p>首先是<code>2&gt;&amp;1</code>，<strong>标准错误拷贝了标准输出的行为，但此时标准输出还是在终端</strong>。</p><pre><code class="hljs bash"><span class="hljs-comment"># 2&gt;&amp;1</span>0 -&gt; /dev/pts/71 -&gt; /dev/pts/72 -&gt; /dev/pts/7</code></pre><p><code>&gt;file</code>后输出才被重定向到file，但标准错误仍然保持在终端。</p><pre><code class="hljs bash"><span class="hljs-comment"># 2&gt;&amp;1</span>0 -&gt; /dev/pts/71 -&gt; file2 -&gt; /dev/pts/7</code></pre><p>所以达不到标准错误输出重定向的效果。</p><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/47765176" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47765176</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>文件描述符</tag>
      
      <tag>重定向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux:进程与线程、文件描述符与重定向</title>
    <link href="/2020/12/18/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2020/12/18/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在使用重定向的过程中，对文件描述符有一些疑惑。学习过程中涉及到一些Linux下的进程线程知识。</p></blockquote><h2 id="1-Linux进程与线程"><a href="#1-Linux进程与线程" class="headerlink" title="1. Linux进程与线程"></a>1. Linux进程与线程</h2><blockquote><p>先说结论：<strong>在 Linux 系统中，进程和线程几乎没有区别</strong>。</p></blockquote><h3 id="1-1-Linux进程"><a href="#1-1-Linux进程" class="headerlink" title="1.1 Linux进程"></a>1.1 Linux进程</h3><p>抽象的来说，计算机即下图所示。</p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/pro.jpg" srcset="/img/loading.gif" alt=""></p><p>这个大的矩形表示计算机的<strong>内存空间</strong>，其中的小矩形代表<strong>进程</strong>，左下角的圆形表示<strong>磁盘</strong>，右下角的图形表示一些<strong>输入输出设备</strong>，比如鼠标键盘显示器等等。</p><p>另外，注意到内存空间被划分为了两块，上半部分表示<strong>用户空间</strong>，下半部分表示<strong>内核空间</strong>。</p><p>用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组，这个数组肯定存在用户空间；内核空间存放内核进程需要加载的系统资源，这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内核空间的资源，比如一些动态链接库等等。</p><p>我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 hello world，然后程序退出。在操作系统层面，就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。</p><p><strong>你编译好的那个可执行程序只是一个文件</strong>，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后，读入你的程序，你的程序才被系统执行。</p><p>那么，操作系统是如何创建进程的呢？<strong>对于操作系统，进程就是一个数据结构</strong>，我们直接来看 Linux 的源码：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span>    <span class="hljs-comment">// 进程状态</span>    <span class="hljs-keyword">long</span>              state;    <span class="hljs-comment">// 虚拟内存结构体</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span>  *<span class="hljs-title">mm</span>;</span>    <span class="hljs-comment">// 进程号</span>    <span class="hljs-keyword">pid_t</span>              pid;    <span class="hljs-comment">// 指向父进程的指针</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span>  *<span class="hljs-title">parent</span>;</span>    <span class="hljs-comment">// 子进程列表</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>        <span class="hljs-title">children</span>;</span>    <span class="hljs-comment">// 存放文件系统信息的指针</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_struct</span>        *<span class="hljs-title">fs</span>;</span>    <span class="hljs-comment">// 一个数组，包含该进程打开的文件指针</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span>        *<span class="hljs-title">files</span>;</span>&#125;;</code></pre><p><code>task_struct</code>就是 Linux 内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，这里就截取了一小部分比较常见的。</p><p>其中比较有意思的是<code>mm</code>指针和<code>files</code>指针。<code>mm</code>指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；<code>files</code>指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。</p><h3 id="1-2-Linux线程"><a href="#1-2-Linux线程" class="headerlink" title="1.2 Linux线程"></a>1.2 Linux线程</h3><p>为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。</p><p>我们知道系统调用<code>fork()</code>可以新建一个子进程，函数<code>pthread()</code>可以新建一个线程。<strong>但无论线程还是进程，都是用<code>task_struct</code>结构表示的，唯一的区别就是共享的数据区域不同</strong>。</p><p>换句话说<em>，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享</em>。就比如说，<code>mm</code>结构和<code>files</code>结构在线程中都是共享的，可由下面两幅图看出：</p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/thr1.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/thr2.jpg" srcset="/img/loading.gif" alt=""></p><p>所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。</p><p>那么你可能问，<strong>既然进程和线程差不多，而且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使用比多进程普遍得多呢</strong>？</p><p>因为<strong>现实中数据共享的并发更普遍</strong>，比如十个人同时从一个账户取十元，我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一个账户的拷贝，每个拷贝账户减少十元。</p><p>当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复杂度。</p><p>在 Linux 中新建线程和进程的效率都是很高的，对于新建进程时内存区域拷贝的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父进程的内存空间，而是等到需要写操作时才去复制。<strong>所以 Linux 中新建进程和新建线程都是很迅速的</strong>。</p><h2 id="2-Linux文件描述符与重定向"><a href="#2-Linux文件描述符与重定向" class="headerlink" title="2. Linux文件描述符与重定向"></a>2. Linux文件描述符与重定向</h2><h3 id="2-1-文件描述符"><a href="#2-1-文件描述符" class="headerlink" title="2.1 文件描述符"></a>2.1 文件描述符</h3><p>在Linux源码对进程的描述中，具有一个<code>files</code>，它是一个文件指针数组。一般来说，一个进程会从<code>files[0]</code>读取输入，将输出写入<code>files[1]</code>，将错误信息写入<code>files[2]</code>。</p><p>举个例子，以我们的角度 C 语言的<code>printf</code>函数是向命令行打印字符，但是从进程的角度来看，就是向<code>files[1]</code>写入数据；同理，<code>scanf</code>函数就是进程试图从<code>files[0]</code>这个文件中读取数据。</p><p><strong>每个进程被创建时，</strong><code>files</code><strong>的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引</strong>，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。</p><p>可以重新画一幅图：</p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/file1.jpg" srcset="/img/loading.gif" alt=""></p><p>对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过<em>「系统调用」</em>让内核进程访问硬件资源。</p><blockquote><p>不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读和写。</p></blockquote><p>如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到<code>files</code>的第 4 个位置：</p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/file2.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-2-重定向"><a href="#2-2-重定向" class="headerlink" title="2.2 重定向"></a>2.2 重定向</h3><p>明白了这个原理，<strong>输入重定向</strong>就很好理解了，程序想读取数据的时候就会去<code>files[0]</code>读取，所以我们只要把<code>files[0]</code>指向一个文件，那么程序就会从这个文件中读取数据，而不是从键盘：</p><pre><code class="hljs bash">$ <span class="hljs-built_in">command</span> &lt; file.txt</code></pre><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/file3.jpg" srcset="/img/loading.gif" alt=""></p><p>同理，<strong>输出重定向</strong>就是把<code>files[1]</code>指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中：</p><pre><code class="hljs bash">$ <span class="hljs-built_in">command</span> &gt; file.txt</code></pre><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/file4.jpg" srcset="/img/loading.gif" alt=""></p><p>错误重定向也是一样的，就不再赘述。</p><p><strong>管道符</strong>其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美：</p><pre><code class="hljs bash">$ cmd1 | cmd2 | cmd3</code></pre><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/pipe.jpg" srcset="/img/loading.gif" alt=""></p><p>到这里，你可能也看出<em>「Linux 中一切皆文件」</em>设计思路的高明了，不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一装进一个简单的<code>files</code>数组，进程通过简单的文件描述符访问相应资源，具体细节交于操作系统，有效解耦，优美高效。</p><h3><a href="#" class="headerlink"></a></h3><blockquote><p>参考：</p><p><a href="https://labuladong.gitbook.io/algo/di-wu-zhang-ji-shu-wen-zhang-xi-lie/linux-jin-cheng" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/di-wu-zhang-ji-shu-wen-zhang-xi-lie/linux-jin-cheng</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>文件描述符</tag>
      
      <tag>重定向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS中Dock栏使用空白分隔</title>
    <link href="/2020/12/05/MacOS%E4%B8%ADDock%E6%A0%8F%E4%BD%BF%E7%94%A8%E7%A9%BA%E7%99%BD%E5%88%86%E9%9A%94-0/"/>
    <url>/2020/12/05/MacOS%E4%B8%ADDock%E6%A0%8F%E4%BD%BF%E7%94%A8%E7%A9%BA%E7%99%BD%E5%88%86%E9%9A%94-0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给Mac的Dock栏添加空白的图标用以分隔。</p></blockquote><h2 id="添加空白分割区"><a href="#添加空白分割区" class="headerlink" title="添加空白分割区"></a>添加空白分割区</h2><ul><li><p><strong>打开</strong><code>终端（Terminal.app）</code></p></li><li><p><strong>输入下列指令后，按回车键运行，空白区域就会添加到Dock中：</strong></p><pre><code class="hljs bash">defaults write com.apple.dock persistent-apps -array-add <span class="hljs-string">'&#123;"tile-type"="spacer-tile";&#125;'</span>; killall Dock</code></pre></li></ul><ul><li><strong>空白区域就是个透明图标，可以移动位置或拖离Dock栏，重复上方指令可添加多个</strong></li></ul><h2 id="只显示当前运行的应用"><a href="#只显示当前运行的应用" class="headerlink" title="只显示当前运行的应用"></a>只显示当前运行的应用</h2><ul><li><p><strong>打开</strong><code>终端（Terminal.app）</code></p></li><li><p><strong>输入下列指令后，按回车键运行，Dock栏只显示当前运行中的应用程序：</strong></p><pre><code class="hljs bash">defaults write com.apple.dock static-only -bool TRUE; killall Dock</code></pre></li></ul><ul><li><p><strong>想恢复原来状态，输入下列指令，按回车键运行即可：</strong></p><pre><code class="hljs bash">defaults write com.apple.dock static-only -bool FALSE; killall Dock</code></pre></li></ul><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/190175194" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/190175194</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>Dock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《局外人》摘录</title>
    <link href="/2020/11/24/%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B%E6%91%98%E5%BD%95/"/>
    <url>/2020/11/24/%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B%E6%91%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《局外人》阿尔贝·加缪</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>一个人对他所不了解的东西，总是会有一些夸张失真的想法。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>所有身心健康的人，都或多或少设想期待过自己所爱的人的死亡。</p><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>为什么一个普通人身上的优点，到了罪犯身上就成为了他十恶不赦的罪状。</p><h3 id="4"><a href="#4" class="headerlink" title="# 4"></a># 4</h3><p>我体验到这个世界如此像我，如此友爱融洽，觉得自己过去曾经是幸福的，现在仍然是幸福的。为了善始善终，功德圆满，为了不感到自己属于另类，我期望处决我的那天，有很多人前来看热闹，他们都向我发出仇恨的叫喊声。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘录</tag>
      
      <tag>局外人</tag>
      
      <tag>阿尔贝·加缪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第二章:字符串和文本(2)</title>
    <link href="/2020/11/16/Python3-Cookbook%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC-2/"/>
    <url>/2020/11/16/Python3-Cookbook%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC-2/</url>
    
    <content type="html"><![CDATA[<h4 id="2-10-在正则式中使用Unicode"><a href="#2-10-在正则式中使用Unicode" class="headerlink" title="2.10 在正则式中使用Unicode"></a>2.10 在正则式中使用Unicode</h4><pre><code class="hljs python"><span class="hljs-comment"># 在正则式中使用Unicode</span><span class="hljs-string">""" </span><span class="hljs-string">你可以使用Unicode字符对应的转义序列(比如 \uFFF 或者 \UFFFFFFF )</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> rearabic = re.compile(<span class="hljs-string">'[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]+'</span>)</code></pre><h4 id="2-11-删除字符串中不需要的字符"><a href="#2-11-删除字符串中不需要的字符" class="headerlink" title="2.11 删除字符串中不需要的字符"></a>2.11 删除字符串中不需要的字符</h4><pre><code class="hljs python"><span class="hljs-comment"># 删除字符串中不需要的字符</span><span class="hljs-string">""" </span><span class="hljs-string">strip() 方法能用于删除开始或结尾的字符。 </span><span class="hljs-string">lstrip() 和 rstrip() 分别从左和从右执行删除操作。 </span><span class="hljs-string">默认情况下，这些方法会去除空白字符，但是你也可以指定其他字符。</span><span class="hljs-string">"""</span><span class="hljs-comment"># Whitespace stripping</span>s = <span class="hljs-string">' hello world \n'</span>s.strip()  <span class="hljs-comment"># 'hello world'</span>s.lstrip()  <span class="hljs-comment"># 'hello world \n'</span>s.rstrip()  <span class="hljs-comment"># ' hello world'</span><span class="hljs-comment"># Character stripping</span>t = <span class="hljs-string">'-----hello====='</span>t.lstrip(<span class="hljs-string">'-'</span>)  <span class="hljs-comment"># 'hello====='</span>t.strip(<span class="hljs-string">'-='</span>)  <span class="hljs-comment"># 'hello'</span></code></pre><h4 id="2-12-审查清理文本字符串"><a href="#2-12-审查清理文本字符串" class="headerlink" title="2.12 审查清理文本字符串"></a>2.12 审查清理文本字符串</h4><pre><code class="hljs python"><span class="hljs-comment"># 审查清理文本字符串</span><span class="hljs-string">""" </span><span class="hljs-string">除了使用str.upper() 和 str.lower()变换大小写格式。</span><span class="hljs-string">str.replace() 或者 re.sub() 可以进行简单的替换操作。</span><span class="hljs-string">还可以使用 str.translate() 方法，即自己创造映射之后进行替换。</span><span class="hljs-string">"""</span>s = <span class="hljs-string">'pýtĥöñ\fis\tawesome\r\n'</span>  <span class="hljs-comment"># 'pýtĥöñ\x0cis\tawesome\r\n'</span><span class="hljs-comment"># 映射</span>remap = &#123;ord(<span class="hljs-string">'\t'</span>): <span class="hljs-string">' '</span>, ord(<span class="hljs-string">'\f'</span>): <span class="hljs-string">' '</span>, ord(<span class="hljs-string">'\r'</span>): <span class="hljs-literal">None</span>&#125;<span class="hljs-comment"># 替换</span>a = s.translate(remap)  <span class="hljs-comment"># 'pýtĥöñ is awesome\n'</span></code></pre><h4 id="2-13-字符串对齐"><a href="#2-13-字符串对齐" class="headerlink" title="2.13 字符串对齐"></a>2.13 字符串对齐</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串对齐</span><span class="hljs-string">""" </span><span class="hljs-string">对于基本的字符串对齐操作，可以使用字符串的 ljust() , rjust() 和 center() 方法。</span><span class="hljs-string">所有这些方法都能接受一个可选的填充字符。</span><span class="hljs-string">"""</span>text = <span class="hljs-string">'Hello World'</span>text.ljust(<span class="hljs-number">20</span>)  <span class="hljs-comment"># 'Hello World         '</span>text.rjust(<span class="hljs-number">20</span>)  <span class="hljs-comment"># '         Hello World'</span>text.center(<span class="hljs-number">20</span>)  <span class="hljs-comment"># '    Hello World     '</span><span class="hljs-comment"># 有填充字符</span>text.rjust(<span class="hljs-number">20</span>, <span class="hljs-string">'='</span>)  <span class="hljs-comment"># '=========Hello World'</span>text.center(<span class="hljs-number">20</span>, <span class="hljs-string">'*'</span>)  <span class="hljs-comment"># '****Hello World*****'</span><span class="hljs-string">""" </span><span class="hljs-string">函数 format() 同样可以用来很容易的对齐字符串。 你要做的就是使用 &lt;,&gt; 或者 ^ 字符后面紧跟一个指定的宽度。</span><span class="hljs-string">"""</span>format(text, <span class="hljs-string">'&gt;20'</span>)  <span class="hljs-comment"># '         Hello World'</span>format(text, <span class="hljs-string">'&lt;20'</span>)  <span class="hljs-comment"># 'Hello World         '</span>format(text, <span class="hljs-string">'^20'</span>)  <span class="hljs-comment"># '    Hello World     '</span><span class="hljs-string">'&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;'</span>.format(<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'World'</span>)  <span class="hljs-comment"># '     Hello      World'</span><span class="hljs-comment"># 有填充字符</span>format(text, <span class="hljs-string">'=&gt;20s'</span>)  <span class="hljs-comment"># '=========Hello World'</span>format(text, <span class="hljs-string">'*^20s'</span>)  <span class="hljs-comment"># '****Hello World*****'</span></code></pre><h4 id="2-14-合并拼接字符串"><a href="#2-14-合并拼接字符串" class="headerlink" title="2.14 合并拼接字符串"></a>2.14 合并拼接字符串</h4><pre><code class="hljs python"><span class="hljs-comment"># 合并拼接字符串</span><span class="hljs-string">""" </span><span class="hljs-string">如果字符串在一个list里或者iterable中，使用join()</span><span class="hljs-string">"""</span>parts = [<span class="hljs-string">'Is'</span>, <span class="hljs-string">'Chicago'</span>, <span class="hljs-string">'Not'</span>, <span class="hljs-string">'Chicago?'</span>]<span class="hljs-string">' '</span>.join(parts)  <span class="hljs-comment"># 'Is Chicago Not Chicago?'</span><span class="hljs-string">','</span>.join(parts)  <span class="hljs-comment"># 'Is,Chicago,Not,Chicago?'</span><span class="hljs-string">''</span>.join(parts)  <span class="hljs-comment"># 'IsChicagoNotChicago?'</span><span class="hljs-comment"># 永远都不应该如下写</span>s = <span class="hljs-string">''</span><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> parts:    s += p<span class="hljs-comment"># 适当的时候可以使用生成器表达式</span><span class="hljs-string">','</span>.join(str(d) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data)<span class="hljs-comment"># 输出的时候没必要将字符串连接</span>print(a, b, c, sep=<span class="hljs-string">':'</span>)  <span class="hljs-comment"># Better</span></code></pre><h4 id="2-15-字符串中插入变量"><a href="#2-15-字符串中插入变量" class="headerlink" title="2.15 字符串中插入变量"></a>2.15 字符串中插入变量</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串中插入变量</span><span class="hljs-string">""" </span><span class="hljs-string">可以通过字符串的format()方法来解决。</span><span class="hljs-string">"""</span>s = <span class="hljs-string">'&#123;name&#125; has &#123;n&#125; messages.'</span>s.format(name=<span class="hljs-string">'Guido'</span>, n=<span class="hljs-number">37</span>)  <span class="hljs-comment"># 'Guido has 37 messages.'</span><span class="hljs-string">""" </span><span class="hljs-string">如果要被替换的变量能在变量域中找到， 那么你可以结合使用 format_map() 和 vars()。</span><span class="hljs-string">"""</span>name = <span class="hljs-string">'Guido'</span>n = <span class="hljs-number">37</span>s.format_map(vars())  <span class="hljs-comment"># 'Guido has 37 messages.'</span></code></pre><h4 id="2-16-以指定列宽格式化字符"><a href="#2-16-以指定列宽格式化字符" class="headerlink" title="2.16 以指定列宽格式化字符"></a>2.16 以指定列宽格式化字符</h4><pre><code class="hljs python"><span class="hljs-comment"># 以指定列宽格式化字符</span><span class="hljs-string">""" </span><span class="hljs-string">使用 textwrap 模块来格式化字符串的输出</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> textwraps = <span class="hljs-string">"Look into my eyes, look into my eyes, the eyes, the eyes, \</span><span class="hljs-string">the eyes, not around the eyes, don't look around the eyes, \</span><span class="hljs-string">look into my eyes, you're under."</span><span class="hljs-comment"># 输出以多少字符换行</span>print(textwrap.fill(s, <span class="hljs-number">70</span>))print(textwrap.fill(s, <span class="hljs-number">40</span>))<span class="hljs-comment"># 首行缩进</span>print(textwrap.fill(s, <span class="hljs-number">40</span>, initial_indent=<span class="hljs-string">'    '</span>))<span class="hljs-comment"># 次行及之后缩进</span>print(textwrap.fill(s, <span class="hljs-number">40</span>, subsequent_indent=<span class="hljs-string">'    '</span>))<span class="hljs-comment"># 获取终端大小尺寸</span>os.get_terminal_size().columns</code></pre><h4 id="2-17-在字符串中处理html和xml"><a href="#2-17-在字符串中处理html和xml" class="headerlink" title="2.17 在字符串中处理html和xml"></a>2.17 在字符串中处理html和xml</h4><pre><code class="hljs python"><span class="hljs-comment"># 在字符串中处理html和xml</span><span class="hljs-string">""" </span><span class="hljs-string">使用html模块中的函数</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> htmls = <span class="hljs-string">'Elements are written as "&lt;tag&gt;text&lt;/tag&gt;".'</span><span class="hljs-comment"># 替换字符串中的尖括号</span>print(html.escape(s))<span class="hljs-comment"># Elements are written as &amp;quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&amp;quot;.</span><span class="hljs-comment"># 将非ASCII文本对应的编码实体嵌入进去</span>s = <span class="hljs-string">'Spicy Jalapeño'</span>s.encode(<span class="hljs-string">'ascii'</span>, errors=<span class="hljs-string">'xmlcharrefreplace'</span>)<span class="hljs-comment"># b'Spicy Jalape&amp;#241;o'</span><span class="hljs-comment"># 使用HTML或者XML解析器的一些相关工具函数/方法</span>s = <span class="hljs-string">'Spicy &amp;quot;Jalape&amp;#241;o&amp;quot.'</span><span class="hljs-keyword">from</span> html.parser <span class="hljs-keyword">import</span> HTMLParserp = HTMLParser()p.unescape(s)<span class="hljs-comment"># 'Spicy "Jalapeño".'</span>t = <span class="hljs-string">'The prompt is &amp;gt;&amp;gt;&amp;gt;'</span><span class="hljs-keyword">from</span> xml.sax.saxutils <span class="hljs-keyword">import</span> unescapeunescape(t)<span class="hljs-comment"># 'The prompt is &gt;&gt;&gt;'</span></code></pre><h4 id="2-18-字符串令牌解析"><a href="#2-18-字符串令牌解析" class="headerlink" title="2.18 字符串令牌解析"></a>2.18 字符串令牌解析</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串令牌解析</span><span class="hljs-string">"""  </span><span class="hljs-string">模式对象scanner() 方法。 </span><span class="hljs-string">这个方法会创建一个 scanner 对象， 在这个对象上不断的调用 match() 方法会一步步的扫描目标文本，每步一个匹配。</span><span class="hljs-string">"""</span><span class="hljs-comment"># 想将t转换为tokens</span><span class="hljs-keyword">import</span> ret = <span class="hljs-string">'foo = 23 + 42 * 10'</span>tokens = [(<span class="hljs-string">'NAME'</span>, <span class="hljs-string">'foo'</span>), (<span class="hljs-string">'EQ'</span>, <span class="hljs-string">'='</span>), (<span class="hljs-string">'NUM'</span>, <span class="hljs-string">'23'</span>), (<span class="hljs-string">'PLUS'</span>, <span class="hljs-string">'+'</span>),          (<span class="hljs-string">'NUM'</span>, <span class="hljs-string">'42'</span>), (<span class="hljs-string">'TIMES'</span>, <span class="hljs-string">'*'</span>), (<span class="hljs-string">'NUM'</span>, <span class="hljs-string">'10'</span>)]NAME = <span class="hljs-string">r'(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'</span>NUM = <span class="hljs-string">r'(?P&lt;NUM&gt;\d+)'</span>PLUS = <span class="hljs-string">r'(?P&lt;PLUS&gt;\+)'</span>TIMES = <span class="hljs-string">r'(?P&lt;TIMES&gt;\*)'</span>EQ = <span class="hljs-string">r'(?P&lt;EQ&gt;=)'</span>WS = <span class="hljs-string">r'(?P&lt;WS&gt;\s+)'</span>master_pat = re.compile(<span class="hljs-string">'|'</span>.join([NAME, NUM, PLUS, TIMES, EQ, WS]))scanner = master_pat.scanner(<span class="hljs-string">'foo = 42'</span>)scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('NAME', 'foo')</span>scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('WS', ' ')</span>scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('EQ', '=')</span>scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('WS', ' ')</span>scanner.match()<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x100677738&gt;</span>_.lastgroup, _.group()<span class="hljs-comment"># ('NUM', '42')</span>scanner.match()</code></pre><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第二章:字符串和文本(1)</title>
    <link href="/2020/11/14/Python3-Cookbook%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC-1/"/>
    <url>/2020/11/14/Python3-Cookbook%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC-1/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-使用多个界定符分割字符串"><a href="#2-1-使用多个界定符分割字符串" class="headerlink" title="2.1 使用多个界定符分割字符串"></a>2.1 使用多个界定符分割字符串</h4><pre><code class="hljs python"><span class="hljs-comment"># 使用多个界定符分割字符串</span><span class="hljs-string">""" </span><span class="hljs-string">string 对象的 split() 方法只适应于非常简单的字符串分割情形。</span><span class="hljs-string">re.split() 方法可以更加灵活的切割字符串。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> reline = <span class="hljs-string">'asdf fjdk; afed, fjek,asdf, foo'</span><span class="hljs-comment"># 表示可以通过;或,或空格或多个空格分隔</span>re.split(<span class="hljs-string">r'[;,\s]\s*'</span>, line)<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># ['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']</span></code></pre><h4 id="2-2-字符串开头或结尾匹配"><a href="#2-2-字符串开头或结尾匹配" class="headerlink" title="2.2 字符串开头或结尾匹配"></a>2.2 字符串开头或结尾匹配</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串开头或结尾匹配</span><span class="hljs-string">""" </span><span class="hljs-string">简单使用可以通过str.startswith() 或者是 str.endswith() 方法。</span><span class="hljs-string">如果需要多种匹配可以将匹配项作为元组（且必须是元组tuple()）传入上述方法。</span><span class="hljs-string">切片实现不优雅，正则实现较复杂，这种方式简单使用较方便。</span><span class="hljs-string">"""</span>filename = <span class="hljs-string">'spam.txt'</span>filename.endswith(<span class="hljs-string">'.txt'</span>)  <span class="hljs-comment"># True</span>filename.startswith(<span class="hljs-string">'file:'</span>)  <span class="hljs-comment"># False</span>url = <span class="hljs-string">'http://www.python.org'</span>url.startswith(<span class="hljs-string">'http:'</span>)  <span class="hljs-comment"># True</span>[name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> filenames <span class="hljs-keyword">if</span> name.endswith((<span class="hljs-string">'.c'</span>, <span class="hljs-string">'.h'</span>))]</code></pre><h4 id="2-3-用Shell通配符匹配字符串"><a href="#2-3-用Shell通配符匹配字符串" class="headerlink" title="2.3 用Shell通配符匹配字符串"></a>2.3 用Shell通配符匹配字符串</h4><pre><code class="hljs python"><span class="hljs-comment"># 用Shell通配符匹配字符串</span><span class="hljs-string">""" </span><span class="hljs-string">fnmatch 模块提供了两个函数—— fnmatch() 和 fnmatchcase() ，可以用来实现这样的匹配。</span><span class="hljs-string">fnmatch()大小写敏感根据系统不同而不尽相同。fnmatchcase()大小写敏感。</span><span class="hljs-string">功能强度介于字符串与正则之间。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> fnmatch <span class="hljs-keyword">import</span> fnmatch, fnmatchcasefnmatch(<span class="hljs-string">'foo.txt'</span>, <span class="hljs-string">'*.txt'</span>)  <span class="hljs-comment"># True</span>fnmatch(<span class="hljs-string">'foo.txt'</span>, <span class="hljs-string">'?oo.txt'</span>)  <span class="hljs-comment"># True</span>fnmatch(<span class="hljs-string">'Dat45.csv'</span>, <span class="hljs-string">'Dat[0-9]*'</span>)  <span class="hljs-comment"># True</span></code></pre><h4 id="2-4-字符串匹配和搜索"><a href="#2-4-字符串匹配和搜索" class="headerlink" title="2.4 字符串匹配和搜索"></a>2.4 字符串匹配和搜索</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串匹配和搜索</span><span class="hljs-string">""" </span><span class="hljs-string">str.find() , str.endswith() , str.startswith() 或者类似的方法可做简单匹配。</span><span class="hljs-string">复杂匹配可以使用re模块与正则表达式。表达式多次使用可以预编译为模式对象。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> retext1 = <span class="hljs-string">'11/27/2012'</span>text2 = <span class="hljs-string">'Nov 27, 2012'</span><span class="hljs-keyword">if</span> re.match(<span class="hljs-string">r'\d+/\d+/\d+'</span>, text1):    print(<span class="hljs-string">'yes'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'no'</span>)<span class="hljs-keyword">if</span> re.match(<span class="hljs-string">r'\d+/\d+/\d+'</span>, text2):    print(<span class="hljs-string">'yes'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'no'</span>)<span class="hljs-comment"># 预编译为模式对象</span><span class="hljs-comment"># 字符串前的r表示字符串为raw string，即不会转义。如果此处没有r需要双反斜杠阅读性差。</span>datepat = re.compile(<span class="hljs-string">r'\d+/\d+/\d+'</span>)<span class="hljs-keyword">if</span> datepat.match(text1):    print(<span class="hljs-string">'yes'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'no'</span>)<span class="hljs-string">""" </span><span class="hljs-string">match() 总是从字符串开始去匹配，如果你想查找字符串任意部分的模式出现位置， 使用 findall() 方法去代替。</span><span class="hljs-string">如果你想以迭代方式返回匹配，可以使用 finditer() 方法来代替。</span><span class="hljs-string">"""</span>text = <span class="hljs-string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span>datepat.findall(text)<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># ['11/27/2012', '3/13/2013']</span><span class="hljs-string">""" </span><span class="hljs-string">使用括号去捕获分组，分别将每个组的内容提取出来。</span><span class="hljs-string">"""</span>datepat = re.compile(<span class="hljs-string">r'(\d+)/(\d+)/(\d+)'</span>)m = datepat.match(<span class="hljs-string">'11/27/2012'</span>)<span class="hljs-comment"># &lt;_sre.SRE_Match object at 0x1005d2750&gt;</span>m.group(<span class="hljs-number">0</span>)  <span class="hljs-comment"># '11/27/2012'</span>m.group(<span class="hljs-number">1</span>)  <span class="hljs-comment"># '11'</span>m.group(<span class="hljs-number">2</span>)  <span class="hljs-comment"># '27'</span>m.group(<span class="hljs-number">3</span>)  <span class="hljs-comment"># '2012'</span>m.groups()  <span class="hljs-comment"># ('11', '27', '2012')</span><span class="hljs-comment"># Find all matches (notice splitting into tuples)</span>text = <span class="hljs-string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span>datepat.findall(text)[(<span class="hljs-string">'11'</span>, <span class="hljs-string">'27'</span>, <span class="hljs-string">'2012'</span>), (<span class="hljs-string">'3'</span>, <span class="hljs-string">'13'</span>, <span class="hljs-string">'2013'</span>)]<span class="hljs-keyword">for</span> month, day, year <span class="hljs-keyword">in</span> datepat.findall(text):    print(<span class="hljs-string">'&#123;&#125;-&#123;&#125;-&#123;&#125;'</span>.format(year, month, day))</code></pre><h4 id="2-5-字符串搜索和替换"><a href="#2-5-字符串搜索和替换" class="headerlink" title="2.5 字符串搜索和替换"></a>2.5 字符串搜索和替换</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串搜索和替换</span><span class="hljs-string">""" </span><span class="hljs-string">简单字面模式可以使用str.replace()。</span><span class="hljs-string">对于复杂的模式，请使用 re 模块中的 sub() 函数。</span><span class="hljs-string">"""</span><span class="hljs-comment"># str.replace()</span><span class="hljs-keyword">import</span> retext = <span class="hljs-string">'yeah, but no, but yeah, but no, but yeah'</span>text.replace(<span class="hljs-string">'yeah'</span>, <span class="hljs-string">'yep'</span>)<span class="hljs-comment"># 'yep, but no, but yep, but no, but yep'</span><span class="hljs-comment"># re.sub()</span>text = <span class="hljs-string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span>re.sub(<span class="hljs-string">r'(\d+)/(\d+)/(\d+)'</span>, <span class="hljs-string">r'\3-\1-\2'</span>, text)<span class="hljs-comment"># 'Today is 2012-11-27. PyCon starts 2013-3-13.'</span><span class="hljs-comment"># sub() 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \3 指向前面模式的捕获组号。</span><span class="hljs-comment"># 预编译</span>datepat = re.compile(<span class="hljs-string">r'(\d+)/(\d+)/(\d+)'</span>)datepat.sub(<span class="hljs-string">r'\3-\1-\2'</span>, text)</code></pre><h4 id="2-6-字符串忽略大小写的搜索替换"><a href="#2-6-字符串忽略大小写的搜索替换" class="headerlink" title="2.6 字符串忽略大小写的搜索替换"></a>2.6 字符串忽略大小写的搜索替换</h4><pre><code class="hljs python"><span class="hljs-comment"># 字符串忽略大小写的搜索替换</span><span class="hljs-string">""" </span><span class="hljs-string">为了在文本操作时忽略大小写，你需要在使用 re 模块的时候给这些操作提供 re.IGNORECASE 标志参数。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> retext = <span class="hljs-string">'UPPER PYTHON, lower python, Mixed Python'</span>re.findall(<span class="hljs-string">'python'</span>, text, flags=re.IGNORECASE)<span class="hljs-comment"># ['PYTHON', 'python', 'Python']</span>re.sub(<span class="hljs-string">'python'</span>, <span class="hljs-string">'snake'</span>, text, flags=re.IGNORECASE)<span class="hljs-comment"># 'UPPER snake, lower snake, Mixed snake'</span></code></pre><h4 id="2-7-最短模式匹配"><a href="#2-7-最短模式匹配" class="headerlink" title="2.7 最短模式匹配"></a>2.7 最短模式匹配</h4><pre><code class="hljs python"><span class="hljs-comment"># 最短模式匹配</span><span class="hljs-string">""" </span><span class="hljs-string">通过正则表达式的限定符?改变匹配的模式为最短匹配。</span><span class="hljs-string">"(.*)"表示最长匹配双引号内的内容。</span><span class="hljs-string">"(.*?)"表示最短匹配双引号内的内容。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> restr_pat = re.compile(<span class="hljs-string">r'"(.*)"'</span>)text1 = <span class="hljs-string">'Computer says "no."'</span>str_pat.findall(text1)<span class="hljs-comment"># ['no.']</span>text2 = <span class="hljs-string">'Computer says "no." Phone says "yes."'</span>str_pat.findall(text2)<span class="hljs-comment"># ['no." Phone says "yes.']</span>str_pat = re.compile(<span class="hljs-string">r'"(.*?)"'</span>)str_pat.findall(text2)<span class="hljs-comment"># ['no.', 'yes.']</span></code></pre><h4 id="2-8-多行匹配模式"><a href="#2-8-多行匹配模式" class="headerlink" title="2.8 多行匹配模式"></a>2.8 多行匹配模式</h4><pre><code class="hljs python"><span class="hljs-comment"># 多行匹配模式</span><span class="hljs-string">""" </span><span class="hljs-string">当你用点(.)去匹配任意字符的时候，发现点(.)不能匹配换行符的事实。</span><span class="hljs-string">其中一种场景就是匹配C语言的跨行注释。</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> re<span class="hljs-comment"># 该模式对象只能匹配未换行的注释</span>comment = re.compile(<span class="hljs-string">r'/\*(.*?)\*/'</span>)<span class="hljs-comment"># 修改模式增加对换行的支持</span><span class="hljs-comment"># (?:.|*?)中，?:表示匹配但不获取(非捕获组)，|表示或关系，*？表示任意数量但最短匹配</span>comment = re.compile(<span class="hljs-string">r'/\*((?:.|\n)*?)\*/'</span>)</code></pre><h4 id="2-9-将Unicode文本标准化"><a href="#2-9-将Unicode文本标准化" class="headerlink" title="2.9 将Unicode文本标准化"></a>2.9 将Unicode文本标准化</h4><pre><code class="hljs python"><span class="hljs-comment"># 将Unicode文本标准化</span><span class="hljs-string">""" </span><span class="hljs-string">使用unicodedata模块将文本标准化</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> unicodedatas1 = <span class="hljs-string">'Spicy Jalape\u00f1o'</span>  <span class="hljs-comment"># 'Spicy Jalapeño'</span>s2 = <span class="hljs-string">'Spicy Jalapen\u0303o'</span>  <span class="hljs-comment"># 'Spicy Jalapeño'</span>s1 == s2  <span class="hljs-comment"># False</span>t1 = unicodedata.normalize(<span class="hljs-string">'NFC'</span>, s1)t2 = unicodedata.normalize(<span class="hljs-string">'NFC'</span>, s2)t1 == t2  <span class="hljs-comment"># True</span></code></pre><h4><a href="#" class="headerlink"></a></h4><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第一章:数据结构和算法(2)</title>
    <link href="/2020/11/07/Python3-Cookbook%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-2/"/>
    <url>/2020/11/07/Python3-Cookbook%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-2/</url>
    
    <content type="html"><![CDATA[<h4 id="1-11-命名切片"><a href="#1-11-命名切片" class="headerlink" title="1.11 命名切片"></a>1.11 命名切片</h4><pre><code class="hljs python"><span class="hljs-comment"># 命名切片</span><span class="hljs-comment"># 假定你要从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段</span><span class="hljs-comment"># 与其</span>record = <span class="hljs-string">'....................100 .......513.25 ..........'</span>cost = int(record[<span class="hljs-number">20</span>:<span class="hljs-number">23</span>]) * float(record[<span class="hljs-number">31</span>:<span class="hljs-number">37</span>])<span class="hljs-comment"># 不如</span>SHARES = slice(<span class="hljs-number">20</span>, <span class="hljs-number">23</span>)PRICE = slice(<span class="hljs-number">31</span>, <span class="hljs-number">37</span>)cost = int(record[SHARES]) * float(record[PRICE])</code></pre><h4 id="1-12-序列中出现次数最多的元素"><a href="#1-12-序列中出现次数最多的元素" class="headerlink" title="1.12 序列中出现次数最多的元素"></a>1.12 序列中出现次数最多的元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 序列中出现次数最多的元素</span><span class="hljs-string">""" </span><span class="hljs-string">collections.Counter 类就是专门为这类问题而设计的， 它甚至有一个有用的 most_common() 方法直接给了你答案。</span><span class="hljs-string">"""</span><span class="hljs-comment"># 取出出现频率最高的单词</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counterwords = [    <span class="hljs-string">'look'</span>, <span class="hljs-string">'into'</span>, <span class="hljs-string">'my'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'look'</span>, <span class="hljs-string">'into'</span>, <span class="hljs-string">'my'</span>, <span class="hljs-string">'eyes'</span>,    <span class="hljs-string">'the'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'not'</span>, <span class="hljs-string">'around'</span>, <span class="hljs-string">'the'</span>,    <span class="hljs-string">'eyes'</span>, <span class="hljs-string">"don't"</span>, <span class="hljs-string">'look'</span>, <span class="hljs-string">'around'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">'look'</span>, <span class="hljs-string">'into'</span>,    <span class="hljs-string">'my'</span>, <span class="hljs-string">'eyes'</span>, <span class="hljs-string">"you're"</span>, <span class="hljs-string">'under'</span>]word_counts = Counter(words)<span class="hljs-comment"># 出现频率最高的3个单词</span>top_three = word_counts.most_common(<span class="hljs-number">3</span>)print(top_three)<span class="hljs-comment"># Outputs [('eyes', 8), ('the', 5), ('look', 4)]</span><span class="hljs-string">""" </span><span class="hljs-string">collections.Counter底层实际上是一个元素作为key，出现次数作为value的dict。</span><span class="hljs-string">神奇的是还能进行数学运算操作结合。</span><span class="hljs-string">"""</span>morewords = [<span class="hljs-string">'why'</span>,<span class="hljs-string">'are'</span>,<span class="hljs-string">'you'</span>,<span class="hljs-string">'not'</span>,<span class="hljs-string">'looking'</span>,<span class="hljs-string">'in'</span>,<span class="hljs-string">'my'</span>,<span class="hljs-string">'eyes'</span>]a = Counter(words)b = Counter(morewords)a<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># Counter(&#123;'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,"you're": 1, "don't": 1, 'under': 1, 'not': 1&#125;)</span>b<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># Counter(&#123;'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,'my': 1, 'why': 1&#125;)</span><span class="hljs-comment"># Combine counts</span>c = a + bc<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># Counter(&#123;'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,'around': 2, "you're": 1, "don't": 1, 'in': 1, 'why': 1,'looking': 1, 'are': 1, 'under': 1,'you': 1&#125;)</span><span class="hljs-comment"># Subtract counts</span>d = a - bd<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># Counter(&#123;'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,"you're": 1, "don't": 1, 'under': 1&#125;)</span></code></pre><h4 id="1-13-通过某个关键字排序一个字典列表"><a href="#1-13-通过某个关键字排序一个字典列表" class="headerlink" title="1.13 通过某个关键字排序一个字典列表"></a>1.13 通过某个关键字排序一个字典列表</h4><pre><code class="hljs python"><span class="hljs-comment"># 通过某个关键字排序一个字典列表</span><span class="hljs-string">""" </span><span class="hljs-string">使用 operator 模块的 itemgetter 函数。</span><span class="hljs-string">排序过程中，相当于key使用的itemgetter获取到了dict中对应key的value进行排序。</span><span class="hljs-string">itemgetter同时支持多个keys。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetterrows = [    &#123;<span class="hljs-string">'fname'</span>: <span class="hljs-string">'Brian'</span>, <span class="hljs-string">'lname'</span>: <span class="hljs-string">'Jones'</span>, <span class="hljs-string">'uid'</span>: <span class="hljs-number">1003</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>: <span class="hljs-string">'David'</span>, <span class="hljs-string">'lname'</span>: <span class="hljs-string">'Beazley'</span>, <span class="hljs-string">'uid'</span>: <span class="hljs-number">1002</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>: <span class="hljs-string">'John'</span>, <span class="hljs-string">'lname'</span>: <span class="hljs-string">'Cleese'</span>, <span class="hljs-string">'uid'</span>: <span class="hljs-number">1001</span>&#125;,    &#123;<span class="hljs-string">'fname'</span>: <span class="hljs-string">'Big'</span>, <span class="hljs-string">'lname'</span>: <span class="hljs-string">'Jones'</span>, <span class="hljs-string">'uid'</span>: <span class="hljs-number">1004</span>&#125;]rows_by_fname = sorted(rows, key=itemgetter(<span class="hljs-string">'fname'</span>))rows_by_uid = sorted(rows, key=itemgetter(<span class="hljs-string">'uid'</span>))print(rows_by_fname)print(rows_by_uid)rows_by_lfname = sorted(rows, key=itemgetter(<span class="hljs-string">'lname'</span>, <span class="hljs-string">'fname'</span>))print(rows_by_lfname)<span class="hljs-string">""" </span><span class="hljs-string">在上面例子中， rows 被传递给接受一个关键字参数的 sorted() 内置函数。 </span><span class="hljs-string">这个参数是 callable 类型，并且从 rows 中接受一个单一元素，然后返回被用来排序的值。</span><span class="hljs-string">itemgetter() 函数就是负责创建这个 callable 对象的。</span><span class="hljs-string">本例中的操作基本等同于key中使用lambda定义，但是效率更高。同样适用于max，min等。</span><span class="hljs-string">"""</span>rows_by_fname = sorted(rows, key=<span class="hljs-keyword">lambda</span> r: r[<span class="hljs-string">'fname'</span>])rows_by_lfname = sorted(rows, key=<span class="hljs-keyword">lambda</span> r: (r[<span class="hljs-string">'lname'</span>], r[<span class="hljs-string">'fname'</span>]))</code></pre><h4 id="1-14-排序不支持原生比较的对象"><a href="#1-14-排序不支持原生比较的对象" class="headerlink" title="1.14 排序不支持原生比较的对象"></a>1.14 排序不支持原生比较的对象</h4><pre><code class="hljs python"><span class="hljs-comment"># 排序不支持原生比较的对象</span><span class="hljs-string">""" </span><span class="hljs-string">关键在于传入callable的key参数时，获取到非原生对象的具体变量。</span><span class="hljs-string">可以通过lambda或者operator中的attrgetter。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> attrgetter<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, user_id)</span>:</span>        self.user_id = user_id    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'User(&#123;&#125;)'</span>.format(self.user_id)users = [User(<span class="hljs-number">23</span>), User(<span class="hljs-number">3</span>), User(<span class="hljs-number">99</span>)]<span class="hljs-comment"># Method 1</span>print(sorted(users, key=<span class="hljs-keyword">lambda</span> u: u.user_id))<span class="hljs-comment"># Method 2</span>print(sorted(users, key=attrgetter(<span class="hljs-string">'user_id'</span>)))</code></pre><h4 id="1-15-通过某个字段将记录分组"><a href="#1-15-通过某个字段将记录分组" class="headerlink" title="1.15 通过某个字段将记录分组"></a>1.15 通过某个字段将记录分组</h4><pre><code class="hljs python"><span class="hljs-comment"># 通过某个字段将记录分组</span><span class="hljs-string">""" </span><span class="hljs-string">使用itertools.groupby()函数，务必记得需要先排序</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> groupby<span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetterrows = [    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'5412 N CLARK'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/01/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'5148 N CLARK'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/04/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'5800 E 58TH'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'2122 N CLARK'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/03/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'5645 N RAVENSWOOD'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'1060 W ADDISON'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/02/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'4801 N BROADWAY'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/01/2012'</span>&#125;,    &#123;<span class="hljs-string">'address'</span>: <span class="hljs-string">'1039 W GRANVILLE'</span>, <span class="hljs-string">'date'</span>: <span class="hljs-string">'07/04/2012'</span>&#125;,]<span class="hljs-comment"># 需要预先按照想要分组的item排序</span>rows.sort(key=itemgetter(<span class="hljs-string">'date'</span>))<span class="hljs-comment"># 分组</span><span class="hljs-keyword">for</span> date, items <span class="hljs-keyword">in</span> groupby(rows, key=itemgetter(<span class="hljs-string">'date'</span>)):    print(date)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items:        print(<span class="hljs-string">' '</span>, i)<span class="hljs-string">""" 输出结果</span><span class="hljs-string">07/01/2012</span><span class="hljs-string">  &#123;'date': '07/01/2012', 'address': '5412 N CLARK'&#125;</span><span class="hljs-string">  &#123;'date': '07/01/2012', 'address': '4801 N BROADWAY'&#125;</span><span class="hljs-string">07/02/2012</span><span class="hljs-string">  &#123;'date': '07/02/2012', 'address': '5800 E 58TH'&#125;</span><span class="hljs-string">  &#123;'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'&#125;</span><span class="hljs-string">  &#123;'date': '07/02/2012', 'address': '1060 W ADDISON'&#125;</span><span class="hljs-string">07/03/2012</span><span class="hljs-string">  &#123;'date': '07/03/2012', 'address': '2122 N CLARK'&#125;</span><span class="hljs-string">07/04/2012</span><span class="hljs-string">  &#123;'date': '07/04/2012', 'address': '5148 N CLARK'&#125;</span><span class="hljs-string">  &#123;'date': '07/04/2012', 'address': '1039 W GRANVILLE'&#125;</span><span class="hljs-string">"""</span><span class="hljs-string">""" </span><span class="hljs-string">如果需要保持序列顺序，则可以通过1-6中的defaultdict，将想要分组的item作为其中的key，然后将整条记录append到对应item的组别中。</span><span class="hljs-string">"""</span>rows_by_date = defaultdict(list)<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:    rows_by_date[row[<span class="hljs-string">'date'</span>]].append(row)</code></pre><h4 id="1-16-过滤序列元素"><a href="#1-16-过滤序列元素" class="headerlink" title="1.16 过滤序列元素"></a>1.16 过滤序列元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 过滤序列元素</span><span class="hljs-string">""" </span><span class="hljs-string">可通过列表推导式达到目的，好处是同时还能充当简单的数据住转换。但是当元素结果集很大时则很占内存。</span><span class="hljs-string">可以将过滤代码放到一个函数中， 然后使用内建的 filter() 函数。</span><span class="hljs-string">"""</span><span class="hljs-comment"># filter得到的是一个迭代器，如果想得到列表还需要进行list()转换</span>values = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'-3'</span>, <span class="hljs-string">'-'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'N/A'</span>, <span class="hljs-string">'5'</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_int</span><span class="hljs-params">(val)</span>:</span>    <span class="hljs-keyword">try</span>:        x = int(val)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">except</span> ValueError:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>ivals = list(filter(is_int, values))print(ivals)<span class="hljs-comment"># Outputs ['1', '2', '-3', '4', '5']</span><span class="hljs-string">""" </span><span class="hljs-string">列表推导式</span><span class="hljs-string">1. [i for i in range(k) if condition]：此时if起条件判断作用，满足条件的，将被返回成为最终生成的列表的一员。</span><span class="hljs-string">2. [i if condition else exp for exp]：此时if...else被用来赋值，满足条件的i以及else被用来生成最终的列表。</span><span class="hljs-string">"""</span>print([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>])print([i <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)])<span class="hljs-comment"># Outputs</span>[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>][<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>]</code></pre><h4 id="1-17-从字典中提取子集"><a href="#1-17-从字典中提取子集" class="headerlink" title="1.17 从字典中提取子集"></a>1.17 从字典中提取子集</h4><pre><code class="hljs python"><span class="hljs-comment"># 从字典中提取子集</span><span class="hljs-comment"># 使用字典推导</span>prices = &#123;    <span class="hljs-string">'ACME'</span>: <span class="hljs-number">45.23</span>,    <span class="hljs-string">'AAPL'</span>: <span class="hljs-number">612.78</span>,    <span class="hljs-string">'IBM'</span>: <span class="hljs-number">205.55</span>,    <span class="hljs-string">'HPQ'</span>: <span class="hljs-number">37.20</span>,    <span class="hljs-string">'FB'</span>: <span class="hljs-number">10.75</span>&#125;<span class="hljs-comment"># 取出value大于200的</span>p1 = &#123;key: value <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> prices.items() <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">200</span>&#125;<span class="hljs-comment"># 取出在name列表中的键值对</span>tech_names = &#123;<span class="hljs-string">'AAPL'</span>, <span class="hljs-string">'IBM'</span>, <span class="hljs-string">'HPQ'</span>, <span class="hljs-string">'MSFT'</span>&#125;p2 = &#123;key: value <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> prices.items() <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> tech_names&#125;</code></pre><h4 id="1-18-映射名称到序列元素"><a href="#1-18-映射名称到序列元素" class="headerlink" title="1.18 映射名称到序列元素"></a>1.18 映射名称到序列元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 映射名称到序列元素</span><span class="hljs-string">""" </span><span class="hljs-string">使用collections.namedtuple()，函数使用即在初始化的时候传入一个类型名与需要的下标字段。</span><span class="hljs-string">通过使用下标对元组中的内容进行组合操作会表意不清晰。</span><span class="hljs-string">命名元组与字典功能很接近，但是要更节省内存。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtupleSubscriber = namedtuple(<span class="hljs-string">'Subscriber'</span>, [<span class="hljs-string">'addr'</span>, <span class="hljs-string">'joined'</span>])sub = Subscriber(<span class="hljs-string">'jonesy@example.com'</span>, <span class="hljs-string">'2012-10-19'</span>)print(sub)  <span class="hljs-comment"># Subscriber(addr='jonesy@example.com', joined='2012-10-19')</span>print(sub.addr)  <span class="hljs-comment"># jonesy@example.com</span>print(sub.joined)  <span class="hljs-comment"># 2012-10-19</span><span class="hljs-comment"># 举例使用，在命名元组中使用下标。</span><span class="hljs-comment"># 实际上本身对records中的每条记录内容都知道是什么，只是为了表意清楚，使用有名字的下标进行计算。</span>Stock = namedtuple(<span class="hljs-string">'Stock'</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>])<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_cost</span><span class="hljs-params">(records)</span>:</span>    total = <span class="hljs-number">0.0</span>    <span class="hljs-keyword">for</span> rec <span class="hljs-keyword">in</span> records:        s = Stock(*rec)        total += s.shares * s.price    <span class="hljs-keyword">return</span> total</code></pre><h4 id="1-19-转换并同时计算数据"><a href="#1-19-转换并同时计算数据" class="headerlink" title="1.19 转换并同时计算数据"></a>1.19 转换并同时计算数据</h4><pre><code class="hljs python"><span class="hljs-comment"># 转换并同时计算数据</span><span class="hljs-string">""" </span><span class="hljs-string">练习使用生成器表达式参数</span><span class="hljs-string">"""</span><span class="hljs-comment"># 计算平方和</span><span class="hljs-keyword">import</span> osnums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]s = sum(x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums)<span class="hljs-comment"># 查看文件夹中是否包含.py后缀文件</span>files = os.listdir(<span class="hljs-string">'dirname'</span>)<span class="hljs-keyword">if</span> any(name.endswith(<span class="hljs-string">'.py'</span>) <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> files):    print(<span class="hljs-string">'There be python!'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'Sorry, no python.'</span>)<span class="hljs-comment"># 计算字典列表中某个key最小的value</span>portfolio = [    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'GOOG'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">50</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'YHOO'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">75</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'AOL'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">20</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'SCOX'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">65</span>&#125;]min_shares = min(s[<span class="hljs-string">'shares'</span>] <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> portfolio)<span class="hljs-comment"># 对于min() 和 max() 它们接受的一个 key 关键字参数或许对你很有帮助</span></code></pre><h4 id="1-20-合并多个字典或映射"><a href="#1-20-合并多个字典或映射" class="headerlink" title="1.20 合并多个字典或映射"></a>1.20 合并多个字典或映射</h4><pre><code class="hljs python"><span class="hljs-comment"># 合并多个字典或映射</span><span class="hljs-string">""" </span><span class="hljs-string">使用collections 模块中的 ChainMap 类</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> ChainMapa = &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">3</span>&#125;b = &#123;<span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">4</span>&#125;c = ChainMap(a, b)  <span class="hljs-comment"># 先从a找，再从b找</span>print(c[<span class="hljs-string">'x'</span>])  <span class="hljs-comment"># Outputs 1 (from a)</span>print(c[<span class="hljs-string">'y'</span>])  <span class="hljs-comment"># Outputs 2 (from b)</span>print(c[<span class="hljs-string">'z'</span>])  <span class="hljs-comment"># Outputs 3 (from a)</span><span class="hljs-string">""" </span><span class="hljs-string">通过这种操作的字典并不是真正的合并了，只是内部创建了容纳这些字典的列表，大部分字典操作可以正常使用。</span><span class="hljs-string">对于新字典的更新与删除会影响列表中的第一个字典。而使用update()方法，原字典的更新不会影响到新的合并字典。</span><span class="hljs-string">"""</span>a = &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">3</span>&#125;b = &#123;<span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">4</span>&#125;merged = dict(b)merged.update(a)merged[<span class="hljs-string">'x'</span>]  <span class="hljs-comment"># 1</span>merged[<span class="hljs-string">'y'</span>]  <span class="hljs-comment"># 2</span>merged[<span class="hljs-string">'z'</span>]  <span class="hljs-comment"># 3</span>a[<span class="hljs-string">'x'</span>] = <span class="hljs-number">13</span>merged[<span class="hljs-string">'x'</span>]  <span class="hljs-comment"># 1</span></code></pre><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第一章:数据结构和算法(1)</title>
    <link href="/2020/11/05/Python3-Cookbook%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-1/"/>
    <url>/2020/11/05/Python3-Cookbook%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于<strong>《Python Cookbook》</strong>一书进行学习，通过书中部分代码注释与自己的理解写成笔记方便学习与回忆。</p></blockquote><h4 id="1-1-解压序列赋值给多个变量"><a href="#1-1-解压序列赋值给多个变量" class="headerlink" title="1.1 解压序列赋值给多个变量"></a>1.1 解压序列赋值给多个变量</h4><pre><code class="hljs python"><span class="hljs-comment"># 解压序列赋值给多个变量</span>data = [<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>, (<span class="hljs-number">2012</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>)]name, shares, price, date = dataprint(<span class="hljs-string">"name: &#123;&#125;"</span>.format(name))  <span class="hljs-comment"># Prints name: ACME</span>print(<span class="hljs-string">"shares: &#123;&#125;"</span>.format(shares))  <span class="hljs-comment"># Prints shares: 50</span>print(<span class="hljs-string">"price: &#123;&#125;"</span>.format(price))  <span class="hljs-comment"># Prints price: 91.1</span>print(<span class="hljs-string">"data: &#123;&#125;"</span>.format(data))  <span class="hljs-comment"># Prints data: ['ACME', 50, 91.1, (2012, 12, 21)]</span><span class="hljs-comment"># 不需要的变量用占位符取代，最后丢弃即可</span>name, _, _, date = data<span class="hljs-comment"># 字符串也可通过此种方式取值</span>s = <span class="hljs-string">"hello"</span>a, b, c, d, e = sprint(<span class="hljs-string">"c: &#123;&#125;"</span>.format(c))  <span class="hljs-comment"># Prints c: l</span></code></pre><h4 id="1-2-解压可迭代对象赋值给多个变量"><a href="#1-2-解压可迭代对象赋值给多个变量" class="headerlink" title="1.2 解压可迭代对象赋值给多个变量"></a>1.2 解压可迭代对象赋值给多个变量</h4><pre><code class="hljs python"><span class="hljs-comment"># 解压可迭代对象赋值给多个变量</span><span class="hljs-comment"># 1-1中如果item数量需要确定的去取</span><span class="hljs-string">""" </span><span class="hljs-string">Python中的星号键不是指针，代表取一个不定长的list；同样两个星号代表取一个不定长的dict </span><span class="hljs-string">"""</span>record = (<span class="hljs-string">'Dave'</span>, <span class="hljs-string">'dave@example.com'</span>, <span class="hljs-string">'773-555-1212'</span>, <span class="hljs-string">'847-555-1212'</span>)name, email, *number = recordprint(<span class="hljs-string">"name: &#123;&#125;"</span>.format(name))  <span class="hljs-comment"># Prints name: Dave</span>print(<span class="hljs-string">"email: &#123;&#125;"</span>.format(email))  <span class="hljs-comment"># Prints email: dave@example.com</span>print(<span class="hljs-string">"number: &#123;&#125;"</span>.format(number))  <span class="hljs-comment"># Prints number: ['773-555-1212', '847-555-1212']</span><span class="hljs-comment"># 用此种方法可以轻易取list中的第一个元素与最后一个元素</span>record = (<span class="hljs-string">'Dave'</span>, <span class="hljs-string">'dave@example.com'</span>, <span class="hljs-string">'773-555-1212'</span>, <span class="hljs-string">'847-555-1212'</span>, <span class="hljs-string">'boss11'</span>)name, *_ = record*_, stuff = record<span class="hljs-comment"># 同样此方法可以用来获取不确定的参数，用以函数传参等</span>records = [(<span class="hljs-string">'foo'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">'bar'</span>, <span class="hljs-string">'hello'</span>), (<span class="hljs-string">'foo'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>), ]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_foo</span><span class="hljs-params">(x, y)</span>:</span>    print(<span class="hljs-string">'foo'</span>, x, y)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_bar</span><span class="hljs-params">(s)</span>:</span>    print(<span class="hljs-string">'bar'</span>, s)<span class="hljs-keyword">for</span> tag, *args <span class="hljs-keyword">in</span> records:    <span class="hljs-keyword">if</span> tag == <span class="hljs-string">'foo'</span>:        do_foo(*args)    <span class="hljs-keyword">elif</span> tag == <span class="hljs-string">'bar'</span>:        do_bar(*args)<span class="hljs-comment"># Prints </span><span class="hljs-comment"># foo 1 2</span><span class="hljs-comment"># bar hello</span><span class="hljs-comment"># foo 3 4</span></code></pre><h4 id="1-3-保留最后N个元素"><a href="#1-3-保留最后N个元素" class="headerlink" title="1.3 保留最后N个元素"></a>1.3 保留最后N个元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 保留最后N个元素</span><span class="hljs-string">""" </span><span class="hljs-string">使用collections.deque即可完成该操作，deque是一个可以设置长度的双端队列。</span><span class="hljs-string">具有append(),appendleft(),pop(),popleft()。</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> dequeq = deque(maxlen=<span class="hljs-number">3</span>)q.append(<span class="hljs-number">1</span>)q.append(<span class="hljs-number">2</span>)q.append(<span class="hljs-number">3</span>)print(q)  <span class="hljs-comment"># Prints deque([1, 2, 3], maxlen=3)</span>q.append(<span class="hljs-number">4</span>)print(q)  <span class="hljs-comment"># Prints deque([2, 3, 4], maxlen=3)</span><span class="hljs-comment"># 不指定大小则获得一个无限长度的双端队列</span>q = deque()q.append(<span class="hljs-number">1</span>)q.append(<span class="hljs-number">2</span>)q.append(<span class="hljs-number">3</span>)print(q)  <span class="hljs-comment"># Prints deque([1, 2, 3])</span>q.appendleft(<span class="hljs-number">4</span>)print(q)  <span class="hljs-comment"># Prints deque([4, 1, 2, 3])</span>print(q.pop())  <span class="hljs-comment"># Prints 3</span>print(q.popleft())  <span class="hljs-comment"># Prints 4</span><span class="hljs-comment"># 举例：保留文件中包含python字样的最后五行数据</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(lines, pattern, history=<span class="hljs-number">5</span>)</span>:</span>    previous_lines = deque(maxlen=history)    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:        <span class="hljs-keyword">if</span> pattern <span class="hljs-keyword">in</span> line:            <span class="hljs-keyword">yield</span> line, previous_lines        previous_lines.append(line)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    <span class="hljs-keyword">with</span> open(<span class="hljs-string">r'./somefile.txt'</span>) <span class="hljs-keyword">as</span> f:        <span class="hljs-keyword">for</span> line, prevlines <span class="hljs-keyword">in</span> search(f, <span class="hljs-string">'python'</span>, <span class="hljs-number">5</span>):            <span class="hljs-keyword">for</span> pline <span class="hljs-keyword">in</span> prevlines:                print(pline, end=<span class="hljs-string">''</span>)                print(line, end=<span class="hljs-string">''</span>)                print(<span class="hljs-string">'-'</span> * <span class="hljs-number">20</span>)</code></pre><h4 id="1-4-查找最大最小的N个元素"><a href="#1-4-查找最大最小的N个元素" class="headerlink" title="1.4 查找最大最小的N个元素"></a>1.4 查找最大最小的N个元素</h4><pre><code class="hljs python"><span class="hljs-comment"># 查找最大最小的N个元素</span><span class="hljs-string">""" </span><span class="hljs-string">heapq 模块有两个函数：nlargest() 和 nsmallest() 可以进行输出</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> heapqnums = [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">23</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">18</span>, <span class="hljs-number">23</span>, <span class="hljs-number">42</span>, <span class="hljs-number">37</span>, <span class="hljs-number">2</span>]print(heapq.nlargest(<span class="hljs-number">3</span>, nums))  <span class="hljs-comment"># Prints [42, 37, 23]</span>print(heapq.nsmallest(<span class="hljs-number">3</span>, nums))  <span class="hljs-comment"># Prints [-4, 1, 2]</span><span class="hljs-comment"># 同时支持复杂的数据结构的排序,需要传入一个key函数</span>portfolio = [    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'IBM'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">100</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">91.1</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'AAPL'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">50</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">543.22</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'FB'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">200</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">21.09</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'HPQ'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">35</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">31.75</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'YHOO'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">45</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">16.35</span>&#125;,    &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'ACME'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">75</span>, <span class="hljs-string">'price'</span>: <span class="hljs-number">115.65</span>&#125;]cheap = heapq.nsmallest(<span class="hljs-number">3</span>, portfolio, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-string">'price'</span>])expensive = heapq.nlargest(<span class="hljs-number">3</span>, portfolio, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-string">'price'</span>])<span class="hljs-comment"># 使用heapq.heapify对list进行处理</span>heap = list(nums)heapq.heapify(heap)  <span class="hljs-comment"># 对heap进行排序</span>heapq.heappop(heap)  <span class="hljs-comment"># 弹出heap最下的元素，根据堆的性质每次都会弹出最小</span></code></pre><h4 id="1-5-优先级队列"><a href="#1-5-优先级队列" class="headerlink" title="1.5 优先级队列"></a>1.5 优先级队列</h4><pre><code class="hljs python"><span class="hljs-comment"># 优先级队列，与一个元组顺序比较的小问题</span><span class="hljs-string">""" </span><span class="hljs-string">利用1-4中的heapq堆，将优先级的负数传入，根据heapq每次会pop最小值的属性，从而每次pop出优先级最高的item（同样优先级的元素按照插入顺序输出）</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> heapq<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self._queue = []        self._index = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, item, priority)</span>:</span>        heapq.heappush(self._queue, (-priority, self._index, item))        self._index += <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> heapq.heappop(self._queue)[<span class="hljs-number">-1</span>]<span class="hljs-string">""" </span><span class="hljs-string">其中index变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的index下标变量，可以确保元素按照它们插入的顺序排序。 </span><span class="hljs-string">而且index变量也在相同优先级元素比较的时候起到重要作用。 </span><span class="hljs-string">"""</span><span class="hljs-comment"># 展示另一个多元组大小比较的问题，多元组是依次比较同位置的元素，上例中的index就是避免了对比错误</span>a = (<span class="hljs-number">1</span>, Item(<span class="hljs-string">'foo'</span>))b = (<span class="hljs-number">5</span>, Item(<span class="hljs-string">'bar'</span>))a &lt; b  <span class="hljs-comment"># Print True</span>c = (<span class="hljs-number">1</span>, Item(<span class="hljs-string">'grok'</span>))a &lt; c  <span class="hljs-comment"># Print TypeError</span></code></pre><h4 id="1-6-字典中的键映射多个值"><a href="#1-6-字典中的键映射多个值" class="headerlink" title="1.6 字典中的键映射多个值"></a>1.6 字典中的键映射多个值</h4><pre><code class="hljs python"><span class="hljs-comment"># 字典中的键映射多个值</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdictd = defaultdict(list)d[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">1</span>)d[<span class="hljs-string">'a'</span>].append(<span class="hljs-number">2</span>)d[<span class="hljs-string">'b'</span>].append(<span class="hljs-number">4</span>)d = defaultdict(set)d[<span class="hljs-string">'a'</span>].add(<span class="hljs-number">1</span>)d[<span class="hljs-string">'a'</span>].add(<span class="hljs-number">2</span>)d[<span class="hljs-string">'b'</span>].add(<span class="hljs-number">4</span>)<span class="hljs-string">""" </span><span class="hljs-string">元组tuple(),不可变有序</span><span class="hljs-string">列表list[],可变有序</span><span class="hljs-string">字典dict&#123;key:value&#125;,存键值对无序</span><span class="hljs-string">集合set&#123;&#125;,无重复无序</span><span class="hljs-string">"""</span></code></pre><h4 id="1-7-字典排序"><a href="#1-7-字典排序" class="headerlink" title="1.7 字典排序"></a>1.7 字典排序</h4><pre><code class="hljs python"><span class="hljs-comment"># 字典排序</span><span class="hljs-string">""" </span><span class="hljs-string">collections中的OrderedDict可以按照键值对插入字典的顺序存储dict</span><span class="hljs-string">"""</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDictd = OrderedDict()d[<span class="hljs-string">'foo'</span>] = <span class="hljs-number">1</span>d[<span class="hljs-string">'bar'</span>] = <span class="hljs-number">2</span>d[<span class="hljs-string">'spam'</span>] = <span class="hljs-number">3</span>d[<span class="hljs-string">'grok'</span>] = <span class="hljs-number">4</span><span class="hljs-comment"># Outputs "foo 1", "bar 2", "spam 3", "grok 4"</span><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:    print(key, d[key])<span class="hljs-string">""" </span><span class="hljs-string">Python sorted() 函数</span><span class="hljs-string">"""</span>a = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]b = sorted(a)<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [1, 2, 3, 4, 5, 6, 7]</span> L=[(<span class="hljs-string">'b'</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">'a'</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">'c'</span>,<span class="hljs-number">3</span>),(<span class="hljs-string">'d'</span>,<span class="hljs-number">4</span>)]sorted(L, cmp=<span class="hljs-keyword">lambda</span> x,y:cmp(x[<span class="hljs-number">1</span>],y[<span class="hljs-number">1</span>]))   <span class="hljs-comment"># 利用cmp函数</span><span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [('a', 1), ('b', 2), ('c', 3), ('d', 4)]</span>sorted(L, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])               <span class="hljs-comment"># 利用key</span><span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [('a', 1), ('b', 2), ('c', 3), ('d', 4)]</span> students = [(<span class="hljs-string">'john'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-number">15</span>), (<span class="hljs-string">'jane'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-number">12</span>), (<span class="hljs-string">'dave'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-number">10</span>)]sorted(students, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-number">2</span>])            <span class="hljs-comment"># 按年龄排序</span><span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]</span>sorted(students, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-number">2</span>], reverse=<span class="hljs-literal">True</span>)       <span class="hljs-comment"># 按降序</span><span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]</span></code></pre><h4 id="1-8-字典的运算"><a href="#1-8-字典的运算" class="headerlink" title="1.8 字典的运算"></a>1.8 字典的运算</h4><pre><code class="hljs python"><span class="hljs-comment"># 字典的运算</span><span class="hljs-string">"""</span><span class="hljs-string">zip()，可以将两个数量相同的list一一对应组合。</span><span class="hljs-string">通过取出dict中的key，values，将其颠倒组合，就能对value进行排序最大最小等操作。</span><span class="hljs-string">注：Python3中的zip之后是一个对象而不是list，需要通过list()转成list。</span><span class="hljs-string">"""</span>prices = &#123;    <span class="hljs-string">'ACME'</span>: <span class="hljs-number">45.23</span>,    <span class="hljs-string">'AAPL'</span>: <span class="hljs-number">612.78</span>,    <span class="hljs-string">'IBM'</span>: <span class="hljs-number">205.55</span>,    <span class="hljs-string">'HPQ'</span>: <span class="hljs-number">37.20</span>,    <span class="hljs-string">'FB'</span>: <span class="hljs-number">10.75</span>&#125;<span class="hljs-comment"># prices.values()可以取出value所有值作为list。为了对字典值执行计算操作，通常需要使用 zip() 函数先将键和值反转过来。</span>min_price = min(zip(prices.values(), prices.keys()))<span class="hljs-comment"># min_price is (10.75, 'FB')</span>max_price = max(zip(prices.values(), prices.keys()))<span class="hljs-comment"># max_price is (612.78, 'AAPL')</span><span class="hljs-comment"># 类似的，可以使用 zip() 和 sorted() 函数来排列字典数据：</span>prices_sorted = sorted(zip(prices.values(), prices.keys()))<span class="hljs-comment"># prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),</span><span class="hljs-comment">#                   (45.23, 'ACME'), (205.55, 'IBM'),</span><span class="hljs-comment">#                   (612.78, 'AAPL')]</span><span class="hljs-comment"># 执行这些计算的时候，需要注意的是 zip() 函数创建的是一个只能访问一次的迭代器。 如果需要可以将zip后的list取出。</span>vtok = list(zip(prices.values(), prices.keys())))</code></pre><h4 id="1-9-查找两字典的相同点"><a href="#1-9-查找两字典的相同点" class="headerlink" title="1.9 查找两字典的相同点"></a>1.9 查找两字典的相同点</h4><pre><code class="hljs python"><span class="hljs-comment"># 查找两字典的相同点</span><span class="hljs-string">""" </span><span class="hljs-string">字典中的key是可以进行集合操作的。而a.values不可以，需要转成set后操作。</span><span class="hljs-string">"""</span>a = &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'z'</span>: <span class="hljs-number">3</span>&#125;b = &#123;<span class="hljs-string">'w'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'x'</span>: <span class="hljs-number">11</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>&#125;<span class="hljs-comment"># Find keys in common</span>a.keys() &amp; b.keys()  <span class="hljs-comment"># &#123; 'x', 'y' &#125;</span><span class="hljs-comment"># Find keys in a that are not in b</span>a.keys() - b.keys()  <span class="hljs-comment"># &#123; 'z' &#125;</span><span class="hljs-comment"># Find (key,value) pairs in common</span>a.items() &amp; b.items()  <span class="hljs-comment"># &#123; ('y', 2) &#125;</span></code></pre><h4 id="1-10-删除序列相同元素并保持顺序"><a href="#1-10-删除序列相同元素并保持顺序" class="headerlink" title="1.10 删除序列相同元素并保持顺序"></a>1.10 删除序列相同元素并保持顺序</h4><pre><code class="hljs python"><span class="hljs-comment"># 删除序列相同元素并保持顺序</span><span class="hljs-string">""" </span><span class="hljs-string">如果序列上的值为hashable类型，则可以通过集合与生成器解决这个问题。</span><span class="hljs-string">其中集合是为了解决元素重复问题，yield则是依次返回元素到list。</span><span class="hljs-string">"""</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dedupe</span><span class="hljs-params">(items)</span>:</span>    seen = set()    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:        <span class="hljs-keyword">if</span> item <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:            <span class="hljs-keyword">yield</span> item            seen.add(item)a = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>]list(dedupe(a))<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [1, 5, 2, 9, 10]</span><span class="hljs-string">""" </span><span class="hljs-string">如果你想消除元素不可哈希（比如 dict 类型）的序列中重复元素的话，需改动代码，将序列元素转换成hashable类型，其实即是选取需要对比的value。</span><span class="hljs-string">"""</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dedupe2</span><span class="hljs-params">(items, key=None)</span>:</span>    seen = set()    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:        val = item <span class="hljs-keyword">if</span> key <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> key(item)        <span class="hljs-keyword">if</span> val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:            <span class="hljs-keyword">yield</span> item            seen.add(val)a = [&#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">'x'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">4</span>&#125;]list(dedupe2(a, key=<span class="hljs-keyword">lambda</span> d: (d[<span class="hljs-string">'x'</span>], d[<span class="hljs-string">'y'</span>])))<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [&#123;'x': 1, 'y': 2&#125;, &#123;'x': 1, 'y': 3&#125;, &#123;'x': 2, 'y': 4&#125;]</span>list(dedupe2(a, key=<span class="hljs-keyword">lambda</span> d: d[<span class="hljs-string">'x'</span>]))<span class="hljs-comment"># Outputs</span><span class="hljs-comment"># [&#123;'x': 1, 'y': 2&#125;, &#123;'x': 2, 'y': 4&#125;]</span><span class="hljs-string">""" </span><span class="hljs-string">仅仅消除元素的话用set就足够。</span><span class="hljs-string">对文件操作的话仅需进行如下变化，可以消除重复行：</span><span class="hljs-string">with open(somefile,'r') as f:</span><span class="hljs-string">for line in dedupe(f):</span><span class="hljs-string">    ...</span><span class="hljs-string">"""</span></code></pre><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook" target="_blank" rel="noopener">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试使用fuzzowski框架</title>
    <link href="/2020/11/01/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8fuzzowski%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/11/01/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8fuzzowski%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>fuzzowski是一个模糊测试器，目前主要支持LPD、IPP、BACnet、Modbus协议。本次测试使用的Modbus部分内容进行修改测试，实际上是通过测定规则生成数据通过tcp不断进行发包。</p><h3 id="Socket脚本"><a href="#Socket脚本" class="headerlink" title="Socket脚本"></a>Socket脚本</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> socketHOST = <span class="hljs-string">'0.0.0.0'</span>PORT = <span class="hljs-number">6678</span>count = <span class="hljs-number">1</span>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((HOST, PORT))s.listen(<span class="hljs-number">10</span>)print(<span class="hljs-string">'Server start at: %s:%s'</span> %(HOST, PORT))print(<span class="hljs-string">'wait for connection...'</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    conn, addr = s.accept()    data = conn.recv(<span class="hljs-number">1024</span>)    f = open(<span class="hljs-string">"test1.txt"</span>,<span class="hljs-string">'a'</span>)    f.write(<span class="hljs-string">"&#123;:&lt;5d&#125;:"</span>.format(count))    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> data:        f.write(<span class="hljs-string">'%02X'</span> % ord(c))        f.write(<span class="hljs-string">' '</span>)    f.write(<span class="hljs-string">'\n'</span>)    f.close()    print(<span class="hljs-string">"&#123;:&lt;5d&#125;:Connected by&#123;&#125;"</span>.format(count, addr))    count+=<span class="hljs-number">1</span>    conn.send(data)    conn.close()</code></pre><h3 id="Fuzzowski设置"><a href="#Fuzzowski设置" class="headerlink" title="Fuzzowski设置"></a>Fuzzowski设置</h3><p>先使用简单的<code>python3 -m fuzzowski 127.0.0.1 6789 -f modbus</code></p><p>经过输出测试，发现变动一个<code>word</code>型会产生<strong>140</strong>种十六进制数据，变动一个<code>byte</code>型会产生<strong>116</strong>种十六进制数据，为固定产生非随机生成。</p><p>通过测试modbus的read_coil模块，主要为<code>/fuzzowski-master/fuzzowski/fuzzers/modbus/modbus.py</code>中如下代码：</p><pre><code class="hljs python">s_initialize(<span class="hljs-string">"modbus_read_coil"</span>)<span class="hljs-keyword">with</span> s_block(<span class="hljs-string">"modbus_head"</span>):    s_word(<span class="hljs-number">0x0001</span>,name=<span class="hljs-string">'transId'</span>,fuzzable=<span class="hljs-literal">True</span>)    s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'protoId'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_word(<span class="hljs-number">0x06</span>,name=<span class="hljs-string">'length'</span>)    s_byte(<span class="hljs-number">0xff</span>,name=<span class="hljs-string">'unit Identifier'</span>,fuzzable=<span class="hljs-literal">False</span>)    <span class="hljs-keyword">with</span> s_block(<span class="hljs-string">'pdu'</span>):        s_byte(<span class="hljs-number">0x01</span>,name=<span class="hljs-string">'funcCode read coil memory'</span>,fuzzable=<span class="hljs-literal">False</span>)        s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'start address'</span>)        s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'quantity'</span>)s_initialize(<span class="hljs-string">'read_holding_registers'</span>)<span class="hljs-keyword">with</span> s_block(<span class="hljs-string">"modbus_head"</span>):    s_word(<span class="hljs-number">0x0001</span>,name=<span class="hljs-string">'transId'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_word(<span class="hljs-number">0x0002</span>,name=<span class="hljs-string">'protoId'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_word(<span class="hljs-number">0x06</span>,name=<span class="hljs-string">'length'</span>)    s_byte(<span class="hljs-number">0xff</span>,name=<span class="hljs-string">'unit Identifier'</span>,fuzzable=<span class="hljs-literal">False</span>)    <span class="hljs-keyword">with</span> s_block(<span class="hljs-string">'read_holding_registers_block'</span>):        s_byte(<span class="hljs-number">0x01</span>,name=<span class="hljs-string">'read_holding_registers'</span>)        s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'start address'</span>)        s_word(<span class="hljs-number">0x0000</span>,name=<span class="hljs-string">'quantity'</span>)</code></pre><p>其中，fuzzable默认为True。设定为True的字段会依次产生变动生成数据，而非交叉产生，即一个数据包仅会有一个字段被fuzz。</p><p>举例修改上述模块为：</p><pre><code class="hljs python">s_initialize(<span class="hljs-string">"modbus_read_coil"</span>)<span class="hljs-keyword">with</span> s_block(<span class="hljs-string">"modbus_head"</span>):    s_byte(<span class="hljs-number">0x68</span>,name=<span class="hljs-string">'funcCode read coil memory1'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_byte(<span class="hljs-number">0x04</span>,name=<span class="hljs-string">'funcCode read coil memory2'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_byte(<span class="hljs-number">0x07</span>,name=<span class="hljs-string">'funcCode read coil memory3'</span>,fuzzable=<span class="hljs-literal">True</span>)    s_byte(<span class="hljs-number">0x00</span>,name=<span class="hljs-string">'funcCode read coil memory4'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_byte(<span class="hljs-number">0x00</span>,name=<span class="hljs-string">'funcCode read coil memory5'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_byte(<span class="hljs-number">0x00</span>,name=<span class="hljs-string">'funcCode read coil memory6'</span>,fuzzable=<span class="hljs-literal">False</span>)    s_initialize(<span class="hljs-string">'read_holding_registers'</span>)<span class="hljs-keyword">with</span> s_block(<span class="hljs-string">"modbus_head"</span>):    s_word(<span class="hljs-number">0x0001</span>,name=<span class="hljs-string">'transId'</span>,fuzzable=<span class="hljs-literal">False</span>)    <span class="hljs-comment"># s_word(0x0002,name='protoId',fuzzable=False)</span>    <span class="hljs-comment"># s_word(0x06,name='length')</span>    <span class="hljs-comment"># s_byte(0xff,name='unit Identifier',fuzzable=False)</span>    <span class="hljs-comment"># with s_block('read_holding_registers_block'):</span>    <span class="hljs-comment">#     s_byte(0x01,name='read_holding_registers')</span>    <span class="hljs-comment">#     s_word(0x0000,name='start address')</span>    <span class="hljs-comment">#     s_word(0x0000,name='quantity')</span></code></pre><p>即只会生成<code>68 04 07 [00] 00 00</code>其中会对第4字节的fuzz数据，共112条。</p><p>通过<code>python3 -m fuzzowski 127.0.0.1 6789 -f modbus -tn -rt 1 -r read_coil</code>调用modbus的read_coil模块（实际上只是生成测试数据发送tcp包，设置为不处理响应）。</p><p><img src="/image/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8fuzzowski%E6%A1%86%E6%9E%B6/modbus-fuzz.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用conda管理环境</title>
    <link href="/2020/10/24/%E4%BD%BF%E7%94%A8conda%E7%AE%A1%E7%90%86%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/10/24/%E4%BD%BF%E7%94%A8conda%E7%AE%A1%E7%90%86%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Python中具有数量庞大且功能相对完善的标准库和第三方库。通过对库的引用，能够实现对不同领域业务的开发。然而，正是由于库的数量庞大，对于管理这些库以及对库作及时的维护成为既重要但复杂度又高的事情。</p><p><a href="https://www.anaconda.com/products/individual#macos" target="_blank" rel="noopener">Anaconda</a>就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</p></blockquote><h3 id="1-Anaconda安装"><a href="#1-Anaconda安装" class="headerlink" title="1. Anaconda安装"></a>1. Anaconda安装</h3><p>在<a href="https://www.anaconda.com/products/individual" target="_blank" rel="noopener">Anaconda</a>中下载对应的安装器安装。</p><p>例通过图形化界面安装完MacOS Anaconda，如果成功安装，通过<code>condal list</code>可以看到相关信息。</p><p>在终端中输入<code>python</code>。如果Anaconda被成功安装并且可以运行，则可看到Anaconda字样。</p><pre><code class="hljs python">Python <span class="hljs-number">3.7</span><span class="hljs-number">.6</span> (default, Jan  <span class="hljs-number">8</span> <span class="hljs-number">2020</span>, <span class="hljs-number">13</span>:<span class="hljs-number">42</span>:<span class="hljs-number">34</span>)[Clang <span class="hljs-number">4.0</span><span class="hljs-number">.1</span> (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin</code></pre><h3 id="2-管理conda环境"><a href="#2-管理conda环境" class="headerlink" title="2. 管理conda环境"></a>2. 管理conda环境</h3><blockquote><pre><code class="hljs bash">conda --version <span class="hljs-comment"># 验证conda安装</span></code></pre></blockquote><h4 id="更新conda"><a href="#更新conda" class="headerlink" title="更新conda"></a>更新conda</h4><pre><code class="hljs bash">conda update conda</code></pre><h4 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h4><pre><code class="hljs xml">conda create --name <span class="hljs-tag">&lt;<span class="hljs-name">env_name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">package_names</span>&gt;</span></code></pre><p>注意：</p><ul><li><p><code>&lt;env_name&gt;</code>即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</p></li><li><p><code>&lt;package_names&gt;</code>即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。</p></li><li><p><code>--name</code>同样可以替换为<code>-n</code>。</p><pre><code class="hljs bash"><span class="hljs-comment"># 创建名为python2的环境，python版本为2.7</span>conda create --name python2_test python=2.7<span class="hljs-comment"># 创建名为python3的环境，python版本为3.5，同时创建numpy和pandas包</span>conda create -n python3 python=3.5 numpy pandas</code></pre></li></ul><blockquote><p>注：默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/envs</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</p></blockquote><h4 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h4><pre><code class="hljs bash"><span class="hljs-comment"># 激活环境</span>conda activate &lt;env_name&gt;<span class="hljs-built_in">source</span> activate &lt;env_name&gt;<span class="hljs-comment"># 示例</span>conda activate python2_test<span class="hljs-built_in">source</span> activate python2_test<span class="hljs-comment"># 退出环境</span>conda deactivate<span class="hljs-built_in">source</span> deactivate<span class="hljs-comment"># 显示已创建环境</span>conda env listconda info -econda info --envs</code></pre><h4 id="复制环境"><a href="#复制环境" class="headerlink" title="复制环境"></a>复制环境</h4><pre><code class="hljs csharp">conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt;</code></pre><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><pre><code class="hljs csharp">conda <span class="hljs-keyword">remove</span> --name &lt;env_name&gt; --all</code></pre><h3 id="3-管理包"><a href="#3-管理包" class="headerlink" title="3. 管理包"></a>3. 管理包</h3><pre><code class="hljs bash"><span class="hljs-comment">### 查找包 ###</span><span class="hljs-comment"># 精确查找</span>conda search --full-name &lt;package_full_name&gt;<span class="hljs-comment"># 模糊查找</span>conda search &lt;text&gt;<span class="hljs-comment"># 获取当前环境包信息</span>conda list</code></pre><pre><code class="hljs bash"><span class="hljs-comment">### 安装包 ###</span><span class="hljs-comment"># 在指定环境中安装包</span>conda install --name &lt;env_name&gt; &lt;package_name&gt;<span class="hljs-comment"># 在当前环境中安装包</span>conda install &lt;package_name&gt;</code></pre><pre><code class="hljs bash"><span class="hljs-comment">### 卸载包 ###</span><span class="hljs-comment"># 在指定环境中卸载包</span>conda remove --name &lt;env_name&gt; &lt;package_name&gt;<span class="hljs-comment"># 在当前环境中卸载包</span>conda remove &lt;package_name&gt;</code></pre><pre><code class="hljs bash"><span class="hljs-comment">### 更新包 ### </span>conda update --allconda upgrade --allconda update &lt;package_name&gt;conda upgrade &lt;package_name&gt;<span class="hljs-comment"># 更新多个指定包，空格隔开即可</span>conda update pandas numpy matplotlib</code></pre><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/62f155eb6ac5" target="_blank" rel="noopener">https://www.jianshu.com/p/62f155eb6ac5</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下zsh及Oh-My-Zsh设置</title>
    <link href="/2020/10/14/Ubuntu%E4%B8%8Bzsh%E5%8F%8AOh-My-Zsh%E8%AE%BE%E7%BD%AE/"/>
    <url>/2020/10/14/Ubuntu%E4%B8%8Bzsh%E5%8F%8AOh-My-Zsh%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Z shell（Zsh）是一款可用作交互式登录的shell及脚本编写的命令解释器。内置于Ubuntu与OSX中，功能强大。</p><p>Oh My Zsh是一个开源的的框架，用于管理你的Zsh配置。有很多主题与扩展。</p></blockquote><h2 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h2><pre><code class="hljs bash"><span class="hljs-comment"># 查看系统已有shell</span>cat /etc/shells<span class="hljs-comment"># 查看当前默认的 Shell</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span> <span class="hljs-comment"># 安装zsh（Ubuntu与OSX内置有）</span>sudo apt install zsh<span class="hljs-comment"># 将 Zsh 设置为默认 Shell（chsh-change shell）</span>chsh -s /bin/zsh<span class="hljs-comment"># 重启 Shell（reboot）。</span></code></pre><h2 id="安装-Oh-My-Zsh"><a href="#安装-Oh-My-Zsh" class="headerlink" title="安装 Oh My Zsh"></a>安装 Oh My Zsh</h2><pre><code class="hljs bash"><span class="hljs-comment"># 安装Oh My Zsh</span>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre><p>出现如下界面则安装成功。安装于默认<code>.oh-my-zsh</code>。</p><pre><code class="hljs csharp">__                                     __     ____  / /_     ____ ___  __  __   ____  _____/ /_   / __ \/ __ \   / __ `__ \/ / / /  /_  / / ___/ __ \ / /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / / \____/_/ /_/  /_/ /_/ /_/\__, /    /___/____/_/ /_/                          /____/                       ....<span class="hljs-keyword">is</span> now installed!Please look over the ~/.zshrc file to <span class="hljs-keyword">select</span> plugins, themes, and options.p.s. Follow us at https:<span class="hljs-comment">//twitter.com/ohmyzsh.</span>p.p.s. Get stickers and t-shirts at http:<span class="hljs-comment">//shop.planetargon.com.</span></code></pre><h2 id="Zsh配置"><a href="#Zsh配置" class="headerlink" title="Zsh配置"></a>Zsh配置</h2><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes" target="_blank" rel="noopener">Oh My Zsh主题</a>较多，默认使用的是<em>robbyrussell</em>，<em>agnoster</em>也比较不错。内置主题位于<code>~/.oh-my-zsh/themes</code>中，其他的主题也可下载在此处，在配置文件中直接启用。主题文件可直接打开编辑，重新source配置文件即可生效。</p><pre><code class="hljs bash"><span class="hljs-comment"># 编辑配置文件修改主题</span>vim ~/.zshrc<span class="hljs-comment"># 修改其中的内容</span>ZSH_THEME=<span class="hljs-string">"agnoster"</span></code></pre><p>使用<em>agnoster</em>主题出现乱码，可通过安装解决字体问题。</p><pre><code class="hljs bash">sudo apt-get install powerline fonts-powerline</code></pre><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins" target="_blank" rel="noopener">Oh My Zsh插件</a>，内置很多插件位于<code>/.oh-my-zsh/plugins</code>。可在<code>~/.zshrc</code>中的<code>plugins</code>直接配置打开。</p><p>同时额外装了几个常用的插件。可置于<code>~/.oh-my-zsh/custom/plugins</code>中便于管理。</p><pre><code class="hljs bash"><span class="hljs-comment"># 安装 zsh-autosuggestions</span><span class="hljs-comment"># 命令行命令键入时的历史命令建议插件</span>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions<span class="hljs-comment"># 安装 zsh-syntax-highlighting</span><span class="hljs-comment"># 命令行语法高亮插件</span>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting<span class="hljs-built_in">echo</span> <span class="hljs-string">"source <span class="hljs-variable">$&#123;(q-)PWD&#125;</span>/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"</span> &gt;&gt; <span class="hljs-variable">$&#123;ZDOTDIR:-$HOME&#125;</span>/.zshrc</code></pre><p>修改配置文件<code>vim ~/.zshrc</code>。</p><ul><li><p>z 是一个相当实用的 cd 命令增强脚本（记录你的cd使用习惯 通过z命令模糊匹配）</p></li><li><p>extract是功能强大的解压插件，所有类型的文件解压一个命令x全搞定</p></li></ul><pre><code class="hljs c"># 最好把zsh-syntax-highlighting放在最后plugins=(  git extract zsh-autosuggestions z zsh-syntax-highlighting)</code></pre><blockquote><p>参考：</p><p><a href="https://juejin.im/post/6844903620333289486" target="_blank" rel="noopener">https://juejin.im/post/6844903620333289486</a></p><p><a href="https://www.jianshu.com/p/fa82d932888b" target="_blank" rel="noopener">https://www.jianshu.com/p/fa82d932888b</a></p><p><a href="https://linuxtoy.org/archives/z.html" target="_blank" rel="noopener">https://linuxtoy.org/archives/z.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux SSH免密认证密钥配置及VSCode-SSH配置</title>
    <link href="/2020/10/04/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/10/04/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下Linux的SSH免密配置，以及在VSCode上配置SSH以映射文件，编辑远端文档。</p><p>至于为什么转投VSCode，Ayu Light主题配色实在是太好看了。</p></blockquote><h2 id="SSH公私钥配置"><a href="#SSH公私钥配置" class="headerlink" title="SSH公私钥配置"></a>SSH公私钥配置</h2><blockquote><p>SSH使用方便且安全，公私钥均有本地生成，公钥存放至服务器端即可</p></blockquote><h3 id="生成密钥ssh-keygen"><a href="#生成密钥ssh-keygen" class="headerlink" title="生成密钥ssh-keygen"></a>生成密钥<code>ssh-keygen</code></h3><p>样例：</p><pre><code class="hljs bash">ssh-keygen -t rsa -f aliyun_ssh -C <span class="hljs-string">"备注"</span></code></pre><table><thead><tr><th>参数</th><th align="left">使用</th></tr></thead><tbody><tr><td>-f</td><td align="left">生成文件名</td></tr><tr><td>-t</td><td align="left">采用rsa加密方式,t=type</td></tr><tr><td>-b</td><td align="left">采用长度1024bit的密钥对,b=bits,最长4096</td></tr><tr><td>-C</td><td align="left">备注</td></tr></tbody></table><p>如果该命令是在<code>~/.ssh</code>目录下执行，执行后~/.ssh目录对多出<code>aliyun_ssh</code>和<code>aliyun_ssh.pub</code>两个文件。</p><p>有pub后缀的文件为公钥，没有pub后缀的文件为私钥。</p><h3 id="配置公钥ssh-copy-id"><a href="#配置公钥ssh-copy-id" class="headerlink" title="配置公钥ssh-copy-id"></a>配置公钥<code>ssh-copy-id</code></h3><p>样例：</p><pre><code class="hljs bash">ssh-copy-id -i ~/.ssh/aliyun_ssh.pub root@2.2.2.2</code></pre><p><code>-i</code> (identity_file认证文件)，其实是通过ssh将公钥写入远程服务器的<code>~/ .ssh/authorized_key</code>中（向后添加）。通过文本的复制效果相同。</p><blockquote><p>注：<strong>需要服务器端的~/ .ssh/authorized_key文件具有600权限！</strong></p></blockquote><h3 id="本地SSH配置"><a href="#本地SSH配置" class="headerlink" title="本地SSH配置"></a>本地SSH配置</h3><p>配置格式简单如下：</p><pre><code class="hljs json">Host 10.211.1.1  HostName 10.211.1.1  User rootHost aliyun-2.2.2.2  HostName 2.2.2.2  User root  IdentityFile ~/.ssh/aliyun_ssh</code></pre><p>其中<strong>Host</strong>是自己备注的名字，<strong>HostName</strong>即服务器IP，<strong>User</strong>为登录用户。</p><p>如果使用SSH公私钥登录则需要配置<strong>IdentityFile</strong>指向本地存放的私钥。</p><p>登录时即可备注的名字快速登录(支持tab补全)</p><pre><code class="hljs bash">ssh aliyun-2.2.2.2</code></pre><h2 id="配置VSCode-Remote-SSH"><a href="#配置VSCode-Remote-SSH" class="headerlink" title="配置VSCode Remote - SSH"></a>配置VSCode Remote - SSH</h2><p>直接在VSCode安装Remote - SSH扩展即可。</p><p><img src="/image/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/remotessh.png" srcset="/img/loading.gif" alt=""></p><p>安装完后会在侧边栏和左下角出现相应的扩展栏。</p><p><img src="/image/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/sidebar.png" srcset="/img/loading.gif" alt=""></p><p>可根据系统ssh-config进行连接，即可快速在本地编辑远端文本。</p><h2 id="VSCode快捷键"><a href="#VSCode快捷键" class="headerlink" title="VSCode快捷键"></a>VSCode快捷键</h2><blockquote><p>最后记录一些常用的快捷键</p></blockquote><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><pre><code class="hljs bash">Command + Shift + P / F1 显示命令面板Command + P 快速打开Command + Shift + N 打开新窗口Command + W 关闭窗口</code></pre><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><pre><code class="hljs bash">Command + X 剪切（未选中文本的情况下，剪切光标所在行）Command + C 复制（未选中文本的情况下，复制光标所在行）Option + Up 向上移动行Option + Down 向下移动行Option + Shift + Up 向上复制行Option + Shift + Down 向下复制行Command + Shift + K 删除行Command + Enter 下一行插入Command + Shift + Enter 上一行插入Command + Shift + \ 跳转到匹配的括号Command + [ 减少缩进Command + ] 增加缩进Home 跳转至行首End 跳转到行尾Command + Up 跳转至文件开头Command + Down 跳转至文件结尾Ctrl + PgUp 按行向上滚动Ctrl + PgDown 按行向下滚动Command + PgUp 按屏向上滚动Command + PgDown 按屏向下滚动Command + Shift + [ 折叠代码块Command + Shift + ] 展开代码块Command + K Command + [ 折叠全部子代码块Command + K Command + ] 展开全部子代码块Command + K Command + 0 折叠全部代码块Command + K Command + J 展开全部代码块Command + K Command + C 添加行注释Command + K Command + U 移除行注释Command + / 添加、移除行注释Option + Shift + A 添加、移除块注释Option + Z 自动换行、取消自动换行</code></pre><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><pre><code class="hljs bash">Option + 点击 插入多个光标Command + Option + Up 向上插入光标Command + Option + Down 向下插入光标Command + U 撤销上一个光标操作Option + Shift + I 在所选行的行尾插入光标Command + I 选中当前行Command + Shift + L 选中所有与当前选中内容相同部分Command + F2 选中所有与当前选中单词相同的单词Command + Ctrl + Shift + Left 折叠选中Command + Ctrl + Shift + Right 展开选中Alt + Shift + 拖动鼠标 选中代码块Command + Shift + Option + Up 列选择 向上Command + Shift + Option + Down 列选择 向下Command + Shift + Option + Left 列选择 向左Command + Shift + Option + Right 列选择 向右Command + Shift + Option + PgUp 列选择 向上翻页Command + Shift + Option + PgDown 列选择 向下翻页</code></pre><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><pre><code class="hljs bash">Command + F 查找Command + Option + F 替换Command + G 查找下一个Command + Shift + G 查找上一个Option + Enter 选中所有匹配项Command + D 向下选中相同内容Command + K Command + D 移除前一个向下选中相同内容</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><pre><code class="hljs bash">Ctrl + Space 打开建议Command + Shift + Space 参数提示Tab Emmet插件缩写补全Option + Shift + F 格式化Command + K Command + F 格式化选中内容F12 跳转到声明位置Option + F12 查看具体声明内容Command + K F12 分屏查看具体声明内容Command + . 快速修复Shift + F12 显示引用F2 重命名符号Command + Shift + . 替换为上一个值Command + Shift + , 替换为下一个值Command + K Command + X 删除行尾多余空格Command + K M 更改文件语言</code></pre><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><pre><code class="hljs bash">Command + T 显示所有符号Ctrl + G 跳转至某行Command + P 跳转到某个文件Command + Shift + O 跳转到某个符号Command + Shift + M 打开问题面板F8 下一个错误或警告位置Shift + F8 上一个错误或警告位置Ctrl + Shift + Tab 编辑器历史记录Ctrl + - 后退Ctrl + Shift + - 前进Ctrl + Shift + M Tab 切换焦点</code></pre><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><pre><code class="hljs bash">Command + W 关闭编辑器Command + K F 关闭文件夹Command + \ 编辑器分屏Command + 1 切换到第一分组Command + 2 切换到第二分组Command + 3 切换到第三分组Command + K Command + Left 切换到上一分组Command + K Command + Right 切换到下一分组Command + K Command + Shift + Left 左移编辑器Command + K Command + Shift + Right 右移编辑器Command + K Left 激活左侧编辑组Command + K Right 激活右侧编辑组</code></pre><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><pre><code class="hljs bash">Command + N 新建文件Command + O 打开文件Command + S 保存文件Command + Shift + S 另存为Command + Option + S 全部保存Command + W 关闭Command + K Command + W 全部关闭Command + Shift + T 重新打开被关闭的编辑器Command + K Enter 保持打开Ctrl + Tab 打开下一个Ctrl + Shift + Tab 打开上一个Command + K P 复制当前文件路径Command + K R 在资源管理器中查看当前文件Command + K O 新窗口打开当前文件</code></pre><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><pre><code class="hljs bash">Command + Ctrl + F 全屏、退出全屏Command + Option + 1 切换编辑器分屏方式（横、竖）Command + + 放大Command + - 缩小Command + B 显示、隐藏侧边栏Command + Shift + E 显示资源管理器 或 切换焦点Command + Shift + F 显示搜索框Ctrl + Shift + G 显示Git面板Command + Shift + D 显示调试面板Command + Shift + X 显示插件面板Command + Shift + H 全局搜索替换Command + Shift + J 显示、隐藏高级搜索Command + Shift + C 打开新终端Command + Shift + U 显示输出面板Command + Shift + V Markdown预览窗口Command + K V 分屏显示 Markdown预览窗口</code></pre><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><pre><code class="hljs bash">F9 设置 或 取消断点F5 开始 或 继续F11 进入Shift + F11 跳出F10 跳过Command + K Command + I 显示悬停信息</code></pre><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><pre><code class="hljs bash">Ctrl + ` 显示终端Ctrl + Shift + ` 新建终端Command + Up 向上滚动Command + Down 向下滚动PgUp 向上翻页PgDown 向下翻页Command + Home 滚动到顶部Command + End 滚动到底部</code></pre><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/dd053c18e5ee" target="_blank" rel="noopener">https://www.jianshu.com/p/dd053c18e5ee</a></p><p><a href="https://segmentfault.com/a/1190000012811886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012811886</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hydra开发说明</title>
    <link href="/2020/09/29/Hydra%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/09/29/Hydra%E5%BC%80%E5%8F%91%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hydra工具集成进入扫描系统，与WEB开发端结合，通过开发说明明确输入输出格式与业务逻辑。</p></blockquote><h3 id="一、-输入格式"><a href="#一、-输入格式" class="headerlink" title="一、 输入格式"></a>一、 输入格式</h3><ol><li>命令行范式</li></ol><pre><code class="hljs bash">hydra [some <span class="hljs-built_in">command</span> line options] TARGET PROTOCOL</code></pre><ol start="2"><li>输入内容</li></ol><p>包括<strong>协议选择</strong>，<strong>IP地址与端口指定</strong></p><ul><li>协议（必选项），具有<code>RDP</code>、<code>MYSQL</code>、<code>SSH</code>、<code>TELNET</code>选项</li><li>IP地址（必选项）与端口（可选项），具有输入IP与上传IP地址文件两种模式</li></ul><blockquote><p>1) 输入IP模式：支持<code>IP[:port]</code>与<code>CIDR</code>模式(192.168.0.0/24)</p><p>2) 上传IP地址文件模式：文件一行表示一个地址，格式应为<code>IP[:port]</code>，例：</p><p>foo.bar.com<br>target.com:21<br>unusual.port.com:2121<br>default.used.here.com<br>127.0.0.1<br>127.0.0.1:2121</p></blockquote><p><em>（注：后期考虑将其他模块扫描得到的存活主机作为本模块地址参数）</em></p><ol start="3"><li>其他已选相关参数</li></ol><ul><li>-L：指定用户名字典（根据协议选定内置字典）</li><li>-P：指定密码字典（根据协议选定内置字典）</li></ul><p><em>（注：内置字典可置于服务器静态文件中，为行数较多的txt文件）</em></p><ul><li>-e ns：空密码与账密相同探测</li><li>-o：指定输出文件</li><li>-b：指定输出格式（本次选用json）</li></ul><ol start="4"><li>输入示例</li></ol><ul><li>扫描文件地址中的SSH弱口令</li></ul><pre><code class="hljs bash">hydra -L ssh_login.txt -P ssh_passwd.txt -e ns -o result.json -b json -M IP_addr.txt ssh</code></pre><ul><li>扫描指定IP的RDP弱口令</li></ul><pre><code class="hljs bash">hydra -L rdp_login.txt -P rdp_passwd.txt -e ns -o result.json -b json 127.0.0.1 rdp</code></pre><ul><li>扫描文件地址的TELNET弱口令</li></ul><pre><code class="hljs bash">hydra -L telnet_login.txt -P telnet_passwd.txt -e ns -o result.json -b json -M IP_addr.txt telnet</code></pre><ul><li>扫描指定IP的MYSQL弱口令</li></ul><pre><code class="hljs bash">hydra -L mysql_login.txt -P mysql_passwd.txt -e ns -o result.json -b json 127.0.0.1 mysql</code></pre><h3 id="二、输出格式"><a href="#二、输出格式" class="headerlink" title="二、输出格式"></a>二、输出格式</h3><blockquote><p>采用本地缓存json格式，输出文件由-o选项的参数指定。</p></blockquote><p>SSH测试成功样例，扫描记录信息记录在上，结果存于<code>results</code>中。</p><pre><code class="hljs json">&#123; <span class="hljs-attr">"generator"</span>: &#123;<span class="hljs-attr">"software"</span>: <span class="hljs-string">"Hydra"</span>, <span class="hljs-attr">"version"</span>: <span class="hljs-string">"v9.1"</span>, <span class="hljs-attr">"built"</span>: <span class="hljs-string">"2020-09-29 15:44:28"</span>,<span class="hljs-attr">"server"</span>: <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-attr">"service"</span>: <span class="hljs-string">"ssh"</span>, <span class="hljs-attr">"jsonoutputversion"</span>: <span class="hljs-string">"1.00"</span>,<span class="hljs-attr">"commandline"</span>: <span class="hljs-string">"hydra -l root -p root1 -e ns -o b.json -b json 127.0.0.1 ssh"</span>&#125;,<span class="hljs-attr">"results"</span>: [&#123;<span class="hljs-attr">"port"</span>: <span class="hljs-number">22</span>, <span class="hljs-attr">"service"</span>: <span class="hljs-string">"ssh"</span>, <span class="hljs-attr">"host"</span>: <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-attr">"login"</span>: <span class="hljs-string">"root"</span>, <span class="hljs-attr">"password"</span>: <span class="hljs-string">"root"</span>&#125;],<span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">"errormessages"</span>: [  ],<span class="hljs-attr">"quantityfound"</span>: <span class="hljs-number">1</span>   &#125;</code></pre><p>为扫描出弱口令则<code>results</code>为空。</p><pre><code class="hljs json">&#123; <span class="hljs-attr">"generator"</span>: &#123;<span class="hljs-attr">"software"</span>: <span class="hljs-string">"Hydra"</span>, <span class="hljs-attr">"version"</span>: <span class="hljs-string">"v9.1"</span>, <span class="hljs-attr">"built"</span>: <span class="hljs-string">"2020-09-29 15:44:43"</span>,<span class="hljs-attr">"server"</span>: <span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-attr">"service"</span>: <span class="hljs-string">"ssh"</span>, <span class="hljs-attr">"jsonoutputversion"</span>: <span class="hljs-string">"1.00"</span>,<span class="hljs-attr">"commandline"</span>: <span class="hljs-string">"hydra -l root1 -p root1 -e ns -o b.json -b json 127.0.0.1 ssh"</span>&#125;,<span class="hljs-attr">"results"</span>: [],<span class="hljs-attr">"success"</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">"errormessages"</span>: [  ],<span class="hljs-attr">"quantityfound"</span>: <span class="hljs-number">0</span>   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hydra</tag>
      
      <tag>渗透测试</tag>
      
      <tag>弱口令扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hydra用法简记</title>
    <link href="/2020/09/14/hydra%E7%94%A8%E6%B3%95%E7%AE%80%E8%AE%B0/"/>
    <url>/2020/09/14/hydra%E7%94%A8%E6%B3%95%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hydra是著名黑客组织thc的一款开源的暴力密码破解<a href="https://github.com/vanhauser-thc/thc-hydra" target="_blank" rel="noopener">工具</a>,可以在线破解多种密码。</p><p>官网:<a href="http://www.thc.org/thc-hydra" target="_blank" rel="noopener">http://www.thc.org/thc-hydra</a></p><p>这款暴力密码破解工具相当强大,支持几乎所有协议的在线密码破解,其密码能否被破解关键在于字典是否足够强大。本文仅从安全角度去探讨测试,使用本文内容去做破坏者,与本人无关。</p></blockquote><h3 id="1-指令范式"><a href="#1-指令范式" class="headerlink" title="1.指令范式"></a>1.指令范式</h3><pre><code class="hljs bash">hydra [some <span class="hljs-built_in">command</span> line options] [-s PORT] TARGET PROTOCOL [MODULE-OPTIONS]</code></pre><h3 id="2-参数选项"><a href="#2-参数选项" class="headerlink" title="2.参数选项"></a>2.参数选项</h3><p>使用option指定参数</p><blockquote><p>-R 根据上一次进度继续破解</p><p>-S 使用SSL协议连接</p><p>-s 指定端口,也可通过ip:port指定端口</p><p>-l 指定用户名</p><p>-L 指定用户名字典(文件)</p><p>-p 指定密码破解</p><p>-P 指定密码字典(文件)</p><p>-e ns 空密码探测和指定用户密码探测,n代表null尝试,代表密码同账户名尝试</p><p>-C 用户名可以用:分割(username:password)可以代替-l username -p password,同时支持该类型下的文件</p><p>-M 指定地址(文件)</p><p>-4/6 指定ipv4或ipv6(默认ipv4)</p><p>-o 输出文件</p><p>-t 指定多线程数量,默认为16个线程</p><p>-vV 显示详细过程</p><p>-f 当账号密码爆破成功时,不再继续进行(通常适用于单用户破解)</p><p>-x min:max:charset 生成密码字典,min最短长度,max最长长度,charset中a代表小写字母,A代表大写字母,1代表数字</p></blockquote><h3 id="3-指定IP"><a href="#3-指定IP" class="headerlink" title="3.指定IP"></a>3.指定IP</h3><ul><li>使用一个独立的IP或者DNS地址</li><li>使用CIDR类型的地址段,例<code>&quot;192.168.0.0/24&quot;</code></li><li>通过文件指定地址(使用参数选项 - M)</li><li>亦可通过新方式指定协议、地址、端口、可选项,例<code>ftp://192.168.33.44:22</code></li></ul><h3 id="4-指定协议"><a href="#4-指定协议" class="headerlink" title="4.指定协议"></a>4.指定协议</h3><p>在target之后指明协议。</p><blockquote><p>目前支持的协议类型有:Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MONGODB, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, Radmin, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP</p></blockquote><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h3><pre><code class="hljs bash"><span class="hljs-comment"># 破解ssh:</span>hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip sshhydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解ftp:</span>hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vVhydra ip ftp -l 用户名 -P 密码字典 -e ns -vV</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># get方式提交,破解web登录:</span>hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># post方式提交,破解web登录:</span>hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form ``<span class="hljs-string">"/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry password"</span></code></pre><pre><code class="hljs bash">hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form <span class="hljs-string">"login.php:id=^USER^&amp;passwd=^PASS^:&lt;title&gt;wrong username or password&lt;/title&gt;"</span><span class="hljs-comment"># 参数说明:-t同时线程数3,-l用户名是admin,字典pass.txt,保存为out.txt,-f 当破解了一个密码就停止,</span><span class="hljs-comment"># 10.36.16.18目标ip,http-post-form表示破解是采用http的post方式提交的表单密码破解,&lt;title&gt;中的内容是表示错误猜解的返回信息提示。</span></code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解https:</span>hydra -m /index.php -l muts -P pass.txt 10.36.16.18 https</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解teamspeak:</span>hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解cisco:</span>hydra -P pass.txt 10.36.16.18 ciscohydra -m cloud -P pass.txt 10.36.16.18 cisco-enable</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解smb:</span>hydra -l administrator -P pass.txt 10.36.16.18 smb</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解pop3:</span>hydra -l muts -P pass.txt my.pop3.mail pop3</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解rdp:</span>hydra ip rdp -l administrator -P pass.txt -V</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解http-proxy:</span>hydra -l admin -P pass.txt http-proxy://10.36.16.18</code></pre><pre><code class="hljs bash"><span class="hljs-comment"># 破解imap:</span>hydra -L user.txt -p secret 10.36.16.18 imap PLAINhydra -C defaults.txt -6 imap://[fe80::2c:31ff:fe12:ac11]:143/PLAIN</code></pre><blockquote><p>参考:</p><p><a href="https://github.com/vanhauser-thc/thc-hydra#special-options-for-modules" target="_blank" rel="noopener">https://github.com/vanhauser-thc/thc-hydra#special-options-for-modules</a></p><p><a href="http://xstarcd.github.io/wiki/shell/hydra.html" target="_blank" rel="noopener">http://xstarcd.github.io/wiki/shell/hydra.html</a></p><p><a href="https://yq.aliyun.com/articles/333121" target="_blank" rel="noopener">https://yq.aliyun.com/articles/333121</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hydra</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux fork机制</title>
    <link href="/2020/08/17/Linux-fork%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/08/17/Linux-fork%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前导"><a href="#1-前导" class="headerlink" title="1. 前导"></a>1. 前导</h2><ol><li><p>进程可以看做程序的一次执行过程。在linux下，每个进程有唯一的PID标识进程。PID是一个从1到32768的正整数，其中1一般是特殊进程init，其它进程从2开始依次编号。当用完32768后，从2重新开始。</p></li><li><p>linux中有一个叫进程表的结构用来存储当前正在运行的进程。可以使用<code>ps aux</code>命令查看所有正在运行的进程。</p></li><li><p>进程在linux中呈树状结构，init为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。</p></li><li><p>fork的作用是<strong>复制一个与当前进程一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p></li></ol><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><ul><li>该进程为父进程时，返回子进程的pid</li><li>该进程为子进程时，返回0</li><li>fork执行失败，返回-1</li></ul><p>其实根据名字十分形象，fork叉子分叉：</p><p><img src="/image/Linux_fork%E6%9C%BA%E5%88%B6/fork.png" srcset="/img/loading.gif" alt=""></p><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><p>在网上看fork机制<a href="https://www.jianshu.com/p/1327c51a4a99" target="_blank" rel="noopener">文章</a>中发现一道不错帮助理解的例题，特此记录。</p><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment">已知从这个程序执行到这个程序的所有进程结束这个时间段内，没有其它新进程执行。</span><span class="hljs-comment">1、请说出执行这个程序后，将一共运行几个进程。</span><span class="hljs-comment">2、如果其中一个进程的输出结果是“pid1:1001, pid2:1002”，写出其他进程的输出结果（不考虑进程执行顺序）。</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mian</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">pid_t</span> pid1;<span class="hljs-keyword">pid_t</span> pid2;pid1 = fork();pid2 = fork();<span class="hljs-built_in">printf</span>(<span class="hljs-string">"pid1:%d,pid2:%d\n"</span>,pid1,pid2);&#125;</code></pre><h3 id="2-1-解题关键"><a href="#2-1-解题关键" class="headerlink" title="2.1 解题关键"></a>2.1 解题关键</h3><p>解题的关键就是要认识到fork将程序切成两段。看下图：</p><p><img src="/image/Linux_fork%E6%9C%BA%E5%88%B6/ex.png" srcset="/img/loading.gif" alt=""></p><p>上图表示一个含有fork的程序，而fork语句可以看成将程序切为A、B两个部分。然后整个程序会如下运行：</p><ol><li>设由shell直接执行程序，生成了进程P。P执行完Part. A的所有代码。</li><li>当执行到<code>pid = fork();</code>时，P启动一个进程Q，Q是P的子进程，和P是同一个程序的进程。Q继承P的所有变量、环境变量、程序计数器的当前值。</li><li>在P进程中，fork()<strong>将Q的PID返回给变量pid</strong>，并继续执行Part. B的代码。</li><li>在进程Q中，<strong>将0赋给pid</strong>，并继续执行Part. B的代码。</li></ol><p>这里有三个点非常关键:</p><ol><li>P执行了所有程序，而Q只执行了Part. B，即fork()后面的程序。（这是因为Q继承了P的PC-程序计数器）</li><li>Q继承了fork()语句执行时当前的环境，而不是程序的初始环境。</li><li>P中fork()语句启动子进程Q，并将Q的PID返回，而Q中的fork()语句不启动新进程，仅将0返回。</li></ol><h3 id="2-2-解题过程"><a href="#2-2-解题过程" class="headerlink" title="2.2 解题过程"></a>2.2 解题过程</h3><p>下面利用上文阐述的知识进行解题。这里我把两个问题放在一起进行分析。</p><ol><li><p>从shell中执行此程序，启动了一个进程，我们设这个进程为P0，设其PID为XXX（解题过程不需知道其PID）。</p></li><li><p>当执行到pid1 = fork();时，P0启动一个子进程P1，由题目知P1的PID为1001。我们暂且不管P1。</p></li><li><p>P0中的fork返回1001给pid1，继续执行到pid2 = fork();，此时启动另一个新进程，设为P2，由题目知P2的PID为1002。同样暂且不管P2。</p></li><li><p>P0中的第二个fork返回1002给pid2，继续执行完后续程序，结束。所以，P0的结果为“pid1:1001, pid2:1002”。</p></li><li><p>再看P2，P2生成时，P0中pid1=1001，所以P2中pid1继承P0的1001，而作为子进程pid2=0。P2从第二个fork后开始执行，结束后输出“pid1:1001, pid2:0”。</p></li><li><p>接着看P1，P1中第一条fork返回0给pid1，然后接着执行后面的语句。而后面接着的语句是pid2 = fork();执行到这里，P1又产生了一个新进程，设为P3。先不管P3。</p></li><li><p>P1中第二条fork将P3的PID返回给pid2，由预备知识知P3的PID为1003，所以P1的pid2=1003。P1继续执行后续程序，结束，输出“pid1:0, pid2:1003”。</p></li><li><p>P3作为P1的子进程，继承P1中pid1=0，并且第二条fork将0返回给pid2，所以P3最后输出“pid1:0, pid2:0”。</p></li><li><p>至此，整个执行过程完毕。</p></li></ol><h3 id="2-3-所得答案"><a href="#2-3-所得答案" class="headerlink" title="2.3 所得答案"></a>2.3 所得答案</h3><p>1、一共执行了四个进程。（P0, P1, P2, P3）</p><p>2、另外几个进程的输出分别为：</p><p>pid1:1001, pid2:0</p><p>pid1:0, pid2:1003</p><p>pid1:0, pid2:0</p><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/1327c51a4a99" target="_blank" rel="noopener">https://www.jianshu.com/p/1327c51a4a99</a></p><p><a href="https://zhuanlan.zhihu.com/p/36872365" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36872365</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>fork</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spike简单测试使用</title>
    <link href="/2020/08/13/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/13/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前了解了一下Spike模糊测试框架，本文记录一下使用过程中遇到的问题与使用测试结果。</p></blockquote><h2 id="1-编译问题"><a href="#1-编译问题" class="headerlink" title="1. 编译问题"></a>1. 编译问题</h2><h3 id="macos编译"><a href="#macos编译" class="headerlink" title="macos编译"></a>macos编译</h3><p>使用macos编译出现一些问题，未再考虑。</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/lib_mac.png" srcset="/img/loading.gif" alt=""></p><h3 id="centos编译"><a href="#centos编译" class="headerlink" title="centos编译"></a>centos编译</h3><p>centos编译结果正常，但是运行过程中显示一个库文件<code>libdlrpc.so</code>引用失败。如图：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/lib_linux.png" srcset="/img/loading.gif" alt=""></p><p>根据查找，运行<code>src</code>下<code>ld.sh</code>脚本导入环境变量解决。</p><p>注：通过<code>source ld.sh</code>或<code>. ./ld.sh</code>运行，通过<code>./ld.sh</code>则无法解决。原因参见<a href="https://leex0.top/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">此文章</a>。</p><p><code>ld.sh</code>如下：</p><pre><code class="hljs bash"><span class="hljs-comment">#Use this to use any of the generic programs</span><span class="hljs-comment">#try using . ./ld.sh if it's not working</span><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=.</code></pre><h2 id="2-vulnserver程序测试"><a href="#2-vulnserver程序测试" class="headerlink" title="2. vulnserver程序测试"></a>2. vulnserver程序测试</h2><p>通过使用vulnserver，测试spike能否正确使用。</p><p>脚本如下：</p><pre><code class="hljs c">s_readline();s_string(<span class="hljs-string">"TRUN"</span>);s_string_variable(<span class="hljs-string">"COMMAND"</span>);</code></pre><p>攻击端（CentOS）<code>./generic_send_tcp 10.xx.xx.xx 9999 vul_test.spk 0 0</code>：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/vul_fuzz.png" srcset="/img/loading.gif" alt=""></p><p>服务器端（WindowsXP）程序崩溃：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/vul_error.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-flask-web测试"><a href="#3-flask-web测试" class="headerlink" title="3. flask web测试"></a>3. flask web测试</h2><p>搭建一个简单的web服务器(<code>python flask</code>)测试spike使用。</p><p>攻击脚本如下：</p><pre><code class="hljs c">s_string(<span class="hljs-string">"GET / HTTP/1.1\r\n"</span>);s_string(<span class="hljs-string">"Host: 10.37.129.5:5000\r\n"</span>);s_string(<span class="hljs-string">"User-Agent: "</span>);s_string(<span class="hljs-string">"Content-Length: "</span>);s_blocksize_string(<span class="hljs-string">"block1"</span>, <span class="hljs-number">5</span>); s_string(<span class="hljs-string">"\r\nConnection: close\r\n\r\n"</span>);s_block_start(<span class="hljs-string">"block1"</span>);s_string(<span class="hljs-string">"inputvar="</span>);s_block_end(<span class="hljs-string">"block1"</span>);</code></pre><p>攻击端（CentOS）<code>./generic_send_tcp 10.37.129.5 5000 flask.spk 0 0</code>：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/flask_fuzz.png" srcset="/img/loading.gif" alt=""></p><p>服务器端（Ubuntu）：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/flask_run.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本设置环境变量问题</title>
    <link href="/2020/08/11/Shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/11/Shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在编写框架的初始化编译脚本的过程中，需要向系统导入一个环境变量。</p><p>期望导入<code>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$path</code></p><p>使用<code>sh init.sh</code>后，发现环境变量并未导入。</p></blockquote><p>脚本内容简单，如下：</p><pre><code class="hljs sh">./configure &amp;&amp; make clean &amp;&amp; makepath=$(<span class="hljs-built_in">pwd</span>)LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:<span class="hljs-variable">$path</span><span class="hljs-built_in">export</span> LD_LIBRARY_PATHldconfig</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>使用<code>source init.sh</code>可以解决问题（具有权限情况下）。</li></ul><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><ul><li><p>使用 <code>sh</code> 命令来执行shell脚本的时候，脚本实际是在<code>sh</code>创建的子shell中执行。</p></li><li><p>所以当<code>sh</code>进程完成的时候并没有修改系统变量，所以通过执行 <code>sh init.sh</code>来修改系统变量是无效的。</p></li></ul><h3 id="Q1-父子Shell-与-环境变量"><a href="#Q1-父子Shell-与-环境变量" class="headerlink" title="Q1. 父子Shell 与 环境变量"></a>Q1. 父子Shell 与 环境变量</h3><ul><li>执行程序通常可以理解为parent process所产生的child process，child执行完后再返回到parent。这一现象在Linux中成为<code>fork</code>。子进程产生时会从父进程处<strong>获得资源分配与继承环境</strong>，<strong>所谓环境变量其实就是会传给子进程的变量</strong>。</li><li>通常是，<strong>子shell会继承所有父shell的变量</strong>（可以直接引用）。父shell的变量包括<strong>所有export导出的环境变量和当前环境下设置的变量</strong>（形如var=value）的命令。</li><li>从 process 的观念来看，是 <strong>parent process 产生一个 child process 去执行</strong>，当 child 结束后，会返回 parent ，但 parent 的环境是不会因 child 的改变而改变的。</li></ul><h3 id="Q2-source-与-sh-与-xxx-执行脚本的区别"><a href="#Q2-source-与-sh-与-xxx-执行脚本的区别" class="headerlink" title="Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别"></a>Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别</h3><ul><li><p>对于脚本xxx.sh来说，<code>. ./xxx.sh</code>与<code>source ./xxx.sh</code>相同，与<code>./xxx.sh</code>和<code>sh xxx.sh</code>均不同。</p></li><li><p><code>./xxx.sh</code>——首先你会查找脚本第一行是否指定了解释器，如果没指定，那么就用当前系统默认的shell(大多数linux默认是bash)，如果指定了解释器，那么就将该脚本交给指定的解释器。</p></li><li><p><code>sh xxx.sh</code>——表示我使用sh来解释这个脚本，可以不要执行权限。</p></li><li><p>正常来说，当我们执行一个 shell script 时，其实是先<strong>产生一个 sub-shell 的子进程</strong>，然后 sub-shell 再去产生命令行的子进程。（<code>sh</code>执行脚本的一般方式）</p></li><li><p>所谓<code>source</code>就是让 script 在<strong>当前 shell 内执行而不是产生一个 sub-shell 来执行</strong>。<br>由于所有执行结果均于当前 shell 内完成，若 script 的环境有所改变，当然也会改变当前环境。<br><em>可以理解为source是把脚本内容一行一行读到父shell里挨着执行。</em></p></li></ul><blockquote><p>参考：</p><p><a href="http://bbs.chinaunix.net/thread-2211666-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-2211666-1-1.html</a></p><p><a href="https://www.zhihu.com/question/41441630/answer/91061860" target="_blank" rel="noopener">https://www.zhihu.com/question/41441630/answer/91061860</a> - Virtual的回答</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模糊测试与Spike框架简介</title>
    <link href="/2020/08/02/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/08/02/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-内容介绍"><a href="#1-内容介绍" class="headerlink" title="1. 内容介绍"></a>1. 内容介绍</h2><h3 id="1-1-模糊测试简介"><a href="#1-1-模糊测试简介" class="headerlink" title="1.1 模糊测试简介"></a>1.1 模糊测试简介</h3><p>模糊测试（Fuzzing），是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。<br>其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监控目标程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏等。<br>即用随机坏数据（也称做 fuzz）攻击一个程序，然后等着观察哪里遭到了破坏。但这一过程却能揭示出程序中的重要 bug。<br>它是一种介于完全的手工渗透测试与完全的自动化测试之间的安全性测试类型。它充分利用了机器能够随机生成和发送数据的能力。</p><h3 id="1-2-Spike框架"><a href="#1-2-Spike框架" class="headerlink" title="1.2 Spike框架"></a>1.2 Spike框架</h3><p>Spike是一个模糊器创建工具包，它提供了API，允许用户基于网络的协议来创建自己的fuzzer。其中包含一些通用的模糊测试器。</p><h3 id="1-3-网络协议模糊测试"><a href="#1-3-网络协议模糊测试" class="headerlink" title="1.3 网络协议模糊测试"></a>1.3 网络协议模糊测试</h3><p>对网络协议进行模糊测试也需要识别出可被攻击的接口，通过变异或生成方式得到能够触发错误的模糊测试值，然后将这些模糊测试值发送给目标应用，监视目标应用的错误。</p><h2 id="2-基本过程"><a href="#2-基本过程" class="headerlink" title="2. 基本过程"></a>2. 基本过程</h2><ul><li>确定测试的目标</li><li>确定输入的向量</li><li>生成模糊测试数据，可由测试工具通过随机或是半随机的方式生成</li><li>执行模糊数据测试</li><li>监视异常</li><li>判定发现的漏洞是否可能被利用</li></ul><h2 id="3-测试方法分类"><a href="#3-测试方法分类" class="headerlink" title="3. 测试方法分类"></a>3. 测试方法分类</h2><ul><li>基于<code>变异</code>的模糊测试——简而言之就是正常调用协议，抓包，然后混淆数据包达到生成异常数据包的结果，从而进行测试。</li></ul><blockquote><p>这种方法对已有的正常数据集依赖较高。需要有足够丰富的合法输入从而产生足够丰富的测试类型。</p></blockquote><p>例如，png图片除了文件头后面数据内容进行置换混淆得到异常测试数据。</p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/png1.png" srcset="/img/loading.gif" alt=""></p><ul><li>基于<code>生成</code>的模糊测试——简而言之就是理解协议规约定义，创建文法自动生成动态模糊的测试用例。</li></ul><blockquote><p>这种方法对协议的理解掌握程度需求更高。难度更大。</p></blockquote><p>http的post请求如图，其中fuzzable的点可用来生成测试例子。</p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/http-post.png" srcset="/img/loading.gif" alt=""></p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/http-fuzz.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-困难点"><a href="#4-困难点" class="headerlink" title="4. 困难点"></a>4. 困难点</h2><p>协议分析，对于特定的程序与配套协议，需要对程序段进行逆向分析才能得到<br>协议内容以创建测试样例，而其中逆向分析工作难度与工作量都较大。</p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
      <tag>模糊测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识复习(1)--基本命令</title>
    <link href="/2020/06/01/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0-1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/06/01/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0-1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>很久没有使用Linux，基础知识也忘了不少。</p><p>找了本<a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf" target="_blank" rel="noopener">参考书</a>顺带复习一下Linux的部分基础知识。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="常用工作命令"><a href="#常用工作命令" class="headerlink" title="常用工作命令"></a>常用工作命令</h3><ul><li><p><code>echo</code>：用于在终端输出字符串或变量提取后的值</p><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> Hello!Hello!$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>/bin/bash</code></pre></li><li><p><code>reboot</code>：重启系统</p></li><li><p><code>poweroff</code>：关闭系统</p></li><li><p><code>wget</code>：下载网络文件</p><pre><code class="hljs bash">$ wget http://www.linuxprobe.com/docs/LinuxProbe.pdf</code></pre></li><li><p><code>ps</code>：查看系统中的进程状态</p><pre><code class="hljs bash">$ ps -a(all) -u(user)</code></pre></li><li><p><code>top</code>：动态地监视进程活动与系统负载等信息</p></li><li><p><code>pidof</code>：查询某个指定服务进程的 PID 值</p><pre><code class="hljs bash">$ pidof sshd23587 798</code></pre></li><li><p><code>kill</code>：终止某个指定 PID 的服务进程</p><pre><code class="hljs bash">$ <span class="hljs-built_in">kill</span> 23587</code></pre></li><li><p><code>killall</code>：终止某个指定名称的服务所对应的全部进程</p><pre><code class="hljs bash">$ killall sshd</code></pre></li></ul><h3 id="系统状态命令"><a href="#系统状态命令" class="headerlink" title="系统状态命令"></a>系统状态命令</h3><ul><li><code>ifconfig</code>：用于获取网卡配置与网络状态等信息</li><li><code>uname</code>：用于查看系统内核与系统版本等信息 -a</li><li><code>free</code>：用于显示当前系统中内存的使用量信息</li><li><code>who</code>：用于查看当前登入主机的用户终端信息(whoami)</li><li><code>history</code>：用于显示历史执行过的命令（清除 -c）</li></ul><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><code>pwd</code>：显示用户当前所处的工作目录</li><li><code>cd</code>：切换工作路径</li><li><code>ls</code>：显示目录中文件信息（所有文件-a，详细信息-l）</li></ul><h3 id="文件编辑命令"><a href="#文件编辑命令" class="headerlink" title="文件编辑命令"></a>文件编辑命令</h3><ul><li><p><code>cat</code>：查看纯文本文件（较少）</p></li><li><p><code>more</code>：查看纯文本文件（较多）</p></li><li><p><code>head</code>：查看纯文本文档的前 n行</p><pre><code class="hljs bash">$ head -n 20 /etc/passwd</code></pre></li><li><p><code>tail</code>：查看纯文本文档的后 N 行或持续刷新内容</p><pre><code class="hljs bash">$ tail -n 20 /etc/passwd$ tail -f /var/<span class="hljs-built_in">log</span>/message</code></pre></li><li><p><code>tr</code>：替换文本文件中的字符</p><pre><code class="hljs bash">$ cat anaconda-ks.cfg | tr [a-z] [A-Z]</code></pre></li><li><p><code>wc</code>：统计指定文本的行数-l、字数-w、字节数-c</p><pre><code class="hljs bash">$ wc -l /etc/passwd</code></pre></li><li><p><code>stat</code>：查看文件的具体存储信息和时间等信息</p><pre><code class="hljs bash">$ <span class="hljs-built_in">stat</span> /etc/passwd</code></pre></li><li><p><code>diff</code>：比较多个文本文件的差异</p><pre><code class="hljs bash">$ diff diff_a.txt diff_b.txt</code></pre></li></ul><h3 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h3><ul><li><p><code>touch</code>：创建空白文件或设置文件的时间</p><pre><code class="hljs bash">$ touch touch_a.txt</code></pre></li><li><p><code>mkdir</code>：创建空白目录</p><pre><code class="hljs bash">$ mkdir ~/mkdir_a</code></pre></li><li><p><code>cp</code>：用于复制文件和目录</p><pre><code class="hljs bash">$ cp install.log x.log$ cp -r /etc ~/mkdir_a</code></pre></li><li><p><code>mv</code>：剪切文件或将文件重命名</p><pre><code class="hljs bash">$ mv x.log linux.log</code></pre></li><li><p><code>rm</code>：删除文件或目录</p><pre><code class="hljs bash">$ rm -f install.log$ rm -rf ~/mkdir_a</code></pre></li><li><p><code>dd</code>：按照指定大小和个数的数据块来复制文件或转换文件</p><pre><code class="hljs bash">$ dd <span class="hljs-keyword">if</span>=/dev/zero of=560_file count=1 bs=560M<span class="hljs-comment"># if为输入文件，of为输出文件，count为块数 bs为每个块大小</span>1+0 records <span class="hljs-keyword">in</span>1+0 records out587202560 bytes (587 MB, 560 MiB) copied, 3.49432 s, 168 MB/s</code></pre></li><li><p><code>file</code>：查看文件的类型</p><pre><code class="hljs bash">$ file 560_file560_file: data</code></pre></li></ul><h3 id="压缩搜索命令"><a href="#压缩搜索命令" class="headerlink" title="压缩搜索命令"></a>压缩搜索命令</h3><ul><li><p><code>tar</code>：对文件进行打包压缩或解压</p><pre><code class="hljs bash">$ tar -czvf etc.tar.gz /etc<span class="hljs-comment"># 压缩</span>$ tar -xzvf etc.tar.gz -C /root/etc <span class="hljs-comment"># 解压</span></code></pre></li><li><p><code>grep</code>：在文本中执行关键词搜索，并显示匹配的结果</p><pre><code class="hljs bash">$ grep /sbin/nologin /etc/passwd<span class="hljs-comment"># -n 显示行号； -v 反选信息</span></code></pre></li><li><p><code>find</code>：按照指定条件来查找文件</p><pre><code class="hljs bash">$ find /etc -name <span class="hljs-string">"host*"</span> -<span class="hljs-built_in">print</span><span class="hljs-comment"># 获取到/etc中所有以 host 开头的文件列表</span>$ find / -perm -4000 -<span class="hljs-built_in">print</span><span class="hljs-comment"># 在整个系统中搜索权限中包括 SUID 权限的所有文件</span>$ find / -user linuxprobe -<span class="hljs-built_in">exec</span> cp -a &#123;&#125; /root/findresults/ \;<span class="hljs-comment"># 在整个文件系统中找出所有归属于 linuxprobe 用户的文件并复制到/root/findresults 目录</span><span class="hljs-comment"># 命令的结尾必须是“\;”！！！</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo个人博客</title>
    <link href="/2020/05/24/%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/05/24/%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个快速、简洁且高效的博客框架。</p><p>Hexo主题较多，使用也比较方便，搭建一个博客记录生活学习。</p><p>环境搭建比较简单，记录一下中间遇到的小问题和主题的设置。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>下载安装node.js（建议安装10.0版本以上）</li><li>下载安装git</li><li>下载安装hexo， <code>npm install -g hexo</code> （建议终端走代理）</li></ul><h3 id="本地搭建测试"><a href="#本地搭建测试" class="headerlink" title="本地搭建测试"></a>本地搭建测试</h3><ul><li>本地创建一个文件夹，如xxxblog</li><li>bash中切换到xxxblog目录下，输入 <code>hexo init</code></li><li>运行<code>hexo s</code>打开服务</li><li>本地localhost:4000上应该有博客的基本模板，本地搭建完成</li></ul><h3 id="关联git"><a href="#关联git" class="headerlink" title="关联git"></a>关联git</h3><ul><li>git与本地连接</li></ul><p>绑定信息：</p><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">"你的GitHub用户名"</span>$ git config --global user.email <span class="hljs-string">"你的GitHub绑定的邮箱"</span></code></pre><p>然后生成密钥SSH key：</p><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">"你的GitHub绑定的邮箱"</span></code></pre><p>获取生成的密钥信息放入GitHub-&gt;Settings-&gt;SSH and GPG keys：</p><pre><code class="hljs bash">$ cat ~/.ssh/id_rsa.pub</code></pre><ul><li>git与博客绑定</li></ul><p>在Github上创建名字为<code>xxx,github.io</code>的项目，xxx为你的GitHub用户名，之后均用LeeX0示例。</p><p>打开xxxblog中的_config.yml，将其中的deployment选项的内容改为：</p><pre><code class="hljs xml">deploy:  type: git  repo:     github: git@github.com:LeeX0/LeeX0.github.io.git,master</code></pre><p>ps：如果之后推送时显示403错误，将其中的<code>repo: github: git@github.com:LeeX0/LeeX0.github.io.git,master</code></p><p>改为<code>repo: https://GitHub用户名:GitHub密码@github.com/LeeX0/LeeX0.github.io.git</code>尝试</p><ul><li><p>运行<code>npm install hexo-deployer-git –save</code>安装部署工具</p></li><li><p>运行推送</p><pre><code class="hljs bash">$ hexo clean<span class="hljs-comment"># clean 清除本地静态文件</span>$ hexo g<span class="hljs-comment"># generate 生成本地静态文件</span>$ hexo d<span class="hljs-comment"># deploy 推送部署文件至GitHub</span></code></pre></li><li><p>访问leex0.github.io即可查看博客</p></li></ul><h2 id="博客基本使用"><a href="#博客基本使用" class="headerlink" title="博客基本使用"></a>博客基本使用</h2><ul><li>新建文章</li></ul><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"postname"</span><span class="hljs-comment"># 创建新文章</span></code></pre><p>会在source-&gt;_posts文件夹内生成一个postname.md文件，用markdown格式进行编辑。</p><p>其中front-matter字段主要有：title 文章的标题、date 创建日期 、tags 标签、categories 分类。</p><p>tags 、categories写法建议:</p><pre><code class="hljs xml">tags: - [tag1]- [tag2]categories:- [cate1]- [cate2-1,cate2-2]</code></pre><ul><li>插入图片</li></ul><p>文章插入图片source-&gt;image下，对应文件夹markdown相对路径即可/image/xxx.jpg。</p><ul><li>生成推送</li></ul><p>之后运行推送即可</p><pre><code class="hljs bash">$ hexo clean<span class="hljs-comment"># clean 清除本地静态文件</span>$ hexo g<span class="hljs-comment"># generate 生成本地静态文件</span>$ hexo d<span class="hljs-comment"># deploy 推送部署文件至GitHub</span></code></pre><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>其中<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网展示的主题</a>已经比较多了，<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">知乎的问答</a>也有比较多推荐。</p><p>我是用的<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid</a>主题，介绍一下这个主题的设置。</p><ul><li>下载主题</li></ul><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/archive/v1.8.0.zip" target="_blank" rel="noopener">下载</a>最新主题版本，下载后解压到 themes 目录下并重命名为 fluid。</p><ul><li>修改配置</li></ul><p>修改Hexo目录下的<code>_config.yml</code>：</p><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span>Language: zh-CN  <span class="hljs-comment"># 指定语言，可不改</span></code></pre><p>之后正常生成推送即可，更多设置可参考<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
