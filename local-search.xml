<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spike简单测试使用</title>
    <link href="/2020/08/13/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/13/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前了解了一下Spike模糊测试框架，本文记录一下使用过程中遇到的问题与使用测试结果。</p></blockquote><h2 id="1-编译问题"><a href="#1-编译问题" class="headerlink" title="1. 编译问题"></a>1. 编译问题</h2><h3 id="macos编译"><a href="#macos编译" class="headerlink" title="macos编译"></a>macos编译</h3><p>使用macos编译出现一些问题，未再考虑。</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/lib_mac.png" srcset="/img/loading.gif" alt=""></p><h3 id="centos编译"><a href="#centos编译" class="headerlink" title="centos编译"></a>centos编译</h3><p>centos编译结果正常，但是运行过程中显示一个库文件<code>libdlrpc.so</code>引用失败。如图：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/lib_linux.png" srcset="/img/loading.gif" alt=""></p><p>根据查找，运行<code>src</code>下<code>ld.sh</code>脚本导入环境变量解决。</p><p>注：通过<code>source ld.sh</code>或<code>. ./ld.sh</code>运行，通过<code>./ld.sh</code>则无法解决。原因参见<a href="https://leex0.top/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">此文章</a>。</p><p><code>ld.sh</code>如下：</p><pre><code class="hljs bash"><span class="hljs-comment">#Use this to use any of the generic programs</span><span class="hljs-comment">#try using . ./ld.sh if it's not working</span><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=.</code></pre><h2 id="2-vulnserver程序测试"><a href="#2-vulnserver程序测试" class="headerlink" title="2. vulnserver程序测试"></a>2. vulnserver程序测试</h2><p>通过使用vulnserver，测试spike能否正确使用。</p><p>脚本如下：</p><pre><code class="hljs c">s_readline();s_string(<span class="hljs-string">"TRUN"</span>);s_string_variable(<span class="hljs-string">"COMMAND"</span>);</code></pre><p>攻击端（CentOS）<code>./generic_send_tcp 10.xx.xx.xx 9999 vul_test.spk 0 0</code>：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/vul_fuzz.png" srcset="/img/loading.gif" alt=""></p><p>服务器端（WindowsXP）程序崩溃：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/vul_error.png" srcset="/img/loading.gif" alt=""></p><h2 id="3-flask-web测试"><a href="#3-flask-web测试" class="headerlink" title="3. flask web测试"></a>3. flask web测试</h2><p>搭建一个简单的web服务器(<code>python flsk</code>)测试spike使用。</p><p>攻击脚本如下：</p><pre><code class="hljs c">s_string(<span class="hljs-string">"GET / HTTP/1.1\r\n"</span>);s_string(<span class="hljs-string">"Host: 10.37.129.5:5000\r\n"</span>);s_string(<span class="hljs-string">"User-Agent: "</span>);s_string(<span class="hljs-string">"Content-Length: "</span>);s_blocksize_string(<span class="hljs-string">"block1"</span>, <span class="hljs-number">5</span>); s_string(<span class="hljs-string">"\r\nConnection: close\r\n\r\n"</span>);s_block_start(<span class="hljs-string">"block1"</span>);s_string(<span class="hljs-string">"inputvar="</span>);s_block_end(<span class="hljs-string">"block1"</span>);</code></pre><p>攻击端（CentOS）<code>./generic_send_tcp 10.37.129.5 5000 flask.spk 0 0</code>：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/flask_fuzz.png" srcset="/img/loading.gif" alt=""></p><p>服务器端（Ubuntu）：</p><p><img src="/image/Spike%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/flask_run.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本设置环境变量问题</title>
    <link href="/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/11/shell%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在编写框架的初始化编译脚本的过程中，需要向系统导入一个环境变量。</p><p>期望导入<code>LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$path</code></p><p>使用<code>sh init.sh</code>后，发现环境变量并未导入。</p></blockquote><p>脚本内容简单，如下：</p><pre><code class="hljs sh">./configure &amp;&amp; make clean &amp;&amp; makepath=$(<span class="hljs-built_in">pwd</span>)LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:<span class="hljs-variable">$path</span><span class="hljs-built_in">export</span> LD_LIBRARY_PATHldconfig</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>使用<code>source init.sh</code>可以解决问题（具有权限情况下）。</li></ul><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><ul><li><p>使用 <code>sh</code> 命令来执行shell脚本的时候，脚本实际是在<code>sh</code>创建的子shell中执行。</p></li><li><p>所以当<code>sh</code>进程完成的时候并没有修改系统变量，所以通过执行 <code>sh init.sh</code>来修改系统变量是无效的。</p></li></ul><h3 id="Q1-父子Shell-与-环境变量"><a href="#Q1-父子Shell-与-环境变量" class="headerlink" title="Q1. 父子Shell 与 环境变量"></a>Q1. 父子Shell 与 环境变量</h3><ul><li>执行程序通常可以理解为parent process所产生的child process，child执行完后再返回到parent。这一现象在Linux中成为<code>fork</code>。子进程产生时会从父进程处<strong>获得资源分配与继承环境</strong>，<strong>所谓环境变量其实就是会传给子进程的变量</strong>。</li><li>通常是，<strong>子shell会继承所有父shell的变量</strong>（可以直接引用）。父shell的变量包括<strong>所有export导出的环境变量和当前环境下设置的变量</strong>（形如var=value）的命令。</li><li>从 process 的观念来看，是 <strong>parent process 产生一个 child process 去执行</strong>，当 child 结束后，会返回 parent ，但 parent 的环境是不会因 child 的改变而改变的。</li></ul><h3 id="Q2-source-与-sh-与-xxx-执行脚本的区别"><a href="#Q2-source-与-sh-与-xxx-执行脚本的区别" class="headerlink" title="Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别"></a>Q2. source(.) 与 sh 与 ./xxx 执行脚本的区别</h3><ul><li><p>对于脚本xxx.sh来说，<code>. ./xxx.sh</code>与<code>source ./xxx.sh</code>相同，与<code>./xxx.sh</code>和<code>sh xxx.sh</code>均不同。</p></li><li><p><code>./xxx.sh</code>——首先你会查找脚本第一行是否指定了解释器，如果没指定，那么就用当前系统默认的shell(大多数linux默认是bash)，如果指定了解释器，那么就将该脚本交给指定的解释器。</p></li><li><p><code>sh xxx.sh</code>——表示我使用sh来解释这个脚本，可以不要执行权限。</p></li><li><p>正常来说，当我们执行一个 shell script 时，其实是先<strong>产生一个 sub-shell 的子进程</strong>，然后 sub-shell 再去产生命令行的子进程。（<code>sh</code>执行脚本的一般方式）</p></li><li><p>所谓<code>source</code>就是让 script 在<strong>当前 shell 内执行而不是产生一个 sub-shell 来执行</strong>。<br>由于所有执行结果均于当前 shell 内完成，若 script 的环境有所改变，当然也会改变当前环境。<br><em>可以理解为source是把脚本内容一行一行读到父shell里挨着执行。</em></p></li></ul><p>记得之后去理解fork机制。</p><blockquote><p>参考：</p><p><a href="http://bbs.chinaunix.net/thread-2211666-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-2211666-1-1.html</a></p><p><a href="https://www.zhihu.com/question/41441630/answer/91061860" target="_blank" rel="noopener">https://www.zhihu.com/question/41441630/answer/91061860</a> - Virtual的回答</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模糊测试与Spike框架简介</title>
    <link href="/2020/08/02/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
    <url>/2020/08/02/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-内容介绍"><a href="#1-内容介绍" class="headerlink" title="1. 内容介绍"></a>1. 内容介绍</h2><h3 id="1-1-模糊测试简介"><a href="#1-1-模糊测试简介" class="headerlink" title="1.1 模糊测试简介"></a>1.1 模糊测试简介</h3><p>模糊测试（Fuzzing），是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。<br>其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监控目标程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏等。<br>即用随机坏数据（也称做 fuzz）攻击一个程序，然后等着观察哪里遭到了破坏。但这一过程却能揭示出程序中的重要 bug。<br>它是一种介于完全的手工渗透测试与完全的自动化测试之间的安全性测试类型。它充分利用了机器能够随机生成和发送数据的能力。</p><h3 id="1-2-Spike框架"><a href="#1-2-Spike框架" class="headerlink" title="1.2 Spike框架"></a>1.2 Spike框架</h3><p>Spike是一个模糊器创建工具包，它提供了API，允许用户基于网络的协议来创建自己的fuzzer。其中包含一些通用的模糊测试器。</p><h3 id="1-3-网络协议模糊测试"><a href="#1-3-网络协议模糊测试" class="headerlink" title="1.3 网络协议模糊测试"></a>1.3 网络协议模糊测试</h3><p>对网络协议进行模糊测试也需要识别出可被攻击的接口，通过变异或生成方式得到能够触发错误的模糊测试值，然后将这些模糊测试值发送给目标应用，监视目标应用的错误。</p><h2 id="2-基本过程"><a href="#2-基本过程" class="headerlink" title="2. 基本过程"></a>2. 基本过程</h2><ul><li>确定测试的目标</li><li>确定输入的向量</li><li>生成模糊测试数据，可由测试工具通过随机或是半随机的方式生成</li><li>执行模糊数据测试</li><li>监视异常</li><li>判定发现的漏洞是否可能被利用</li></ul><h2 id="3-测试方法分类"><a href="#3-测试方法分类" class="headerlink" title="3. 测试方法分类"></a>3. 测试方法分类</h2><ul><li>基于<code>变异</code>的模糊测试——简而言之就是正常调用协议，抓包，然后混淆数据包达到生成异常数据包的结果，从而进行测试。</li></ul><blockquote><p>这种方法对已有的正常数据集依赖较高。需要有足够丰富的合法输入从而产生足够丰富的测试类型。</p></blockquote><p>例如，png图片除了文件头后面数据内容进行置换混淆得到异常测试数据。</p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/png1.png" srcset="/img/loading.gif" alt=""></p><ul><li>基于<code>生成</code>的模糊测试——简而言之就是理解协议规约定义，创建文法自动生成动态模糊的测试用例。</li></ul><blockquote><p>这种方法对协议的理解掌握程度需求更高。难度更大。</p></blockquote><p>http的post请求如图，其中fuzzable的点可用来生成测试例子。</p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/http-post.png" srcset="/img/loading.gif" alt=""></p><p><img src="/image/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B8%8ESpike%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/http-fuzz.png" srcset="/img/loading.gif" alt=""></p><h2 id="4-困难点"><a href="#4-困难点" class="headerlink" title="4. 困难点"></a>4. 困难点</h2><p>协议分析，对于特定的程序与配套协议，需要对程序段进行逆向分析才能得到<br>协议内容以创建测试样例，而其中逆向分析工作难度与工作量都较大。</p>]]></content>
    
    
    <categories>
      
      <category>项目组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spike</tag>
      
      <tag>模糊测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识复习(1)--基本命令</title>
    <link href="/2020/06/01/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0-1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/06/01/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0-1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>很久没有使用Linux，基础知识也忘了不少。</p><p>找了本<a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf" target="_blank" rel="noopener">参考书</a>顺带复习一下Linux的部分基础知识。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="常用工作命令"><a href="#常用工作命令" class="headerlink" title="常用工作命令"></a>常用工作命令</h3><ul><li><p><code>echo</code>：用于在终端输出字符串或变量提取后的值</p><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> Hello!Hello!$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>/bin/bash</code></pre></li><li><p><code>reboot</code>：重启系统</p></li><li><p><code>poweroff</code>：关闭系统</p></li><li><p><code>wget</code>：下载网络文件</p><pre><code class="hljs bash">$ wget http://www.linuxprobe.com/docs/LinuxProbe.pdf</code></pre></li><li><p><code>ps</code>：查看系统中的进程状态</p><pre><code class="hljs bash">$ ps -a(all) -u(user)</code></pre></li><li><p><code>top</code>：动态地监视进程活动与系统负载等信息</p></li><li><p><code>pidof</code>：查询某个指定服务进程的 PID 值</p><pre><code class="hljs bash">$ pidof sshd23587 798</code></pre></li><li><p><code>kill</code>：终止某个指定 PID 的服务进程</p><pre><code class="hljs bash">$ <span class="hljs-built_in">kill</span> 23587</code></pre></li><li><p><code>killall</code>：终止某个指定名称的服务所对应的全部进程</p><pre><code class="hljs bash">$ killall sshd</code></pre></li></ul><h3 id="系统状态命令"><a href="#系统状态命令" class="headerlink" title="系统状态命令"></a>系统状态命令</h3><ul><li><code>ifconfig</code>：用于获取网卡配置与网络状态等信息</li><li><code>uname</code>：用于查看系统内核与系统版本等信息 -a</li><li><code>free</code>：用于显示当前系统中内存的使用量信息</li><li><code>who</code>：用于查看当前登入主机的用户终端信息(whoami)</li><li><code>history</code>：用于显示历史执行过的命令（清除 -c）</li></ul><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><code>pwd</code>：显示用户当前所处的工作目录</li><li><code>cd</code>：切换工作路径</li><li><code>ls</code>：显示目录中文件信息（所有文件-a，详细信息-l）</li></ul><h3 id="文件编辑命令"><a href="#文件编辑命令" class="headerlink" title="文件编辑命令"></a>文件编辑命令</h3><ul><li><p><code>cat</code>：查看纯文本文件（较少）</p></li><li><p><code>more</code>：查看纯文本文件（较多）</p></li><li><p><code>head</code>：查看纯文本文档的前 n行</p><pre><code class="hljs bash">$ head -n 20 /etc/passwd</code></pre></li><li><p><code>tail</code>：查看纯文本文档的后 N 行或持续刷新内容</p><pre><code class="hljs bash">$ tail -n 20 /etc/passwd$ tail -f /var/<span class="hljs-built_in">log</span>/message</code></pre></li><li><p><code>tr</code>：替换文本文件中的字符</p><pre><code class="hljs bash">$ cat anaconda-ks.cfg | tr [a-z] [A-Z]</code></pre></li><li><p><code>wc</code>：统计指定文本的行数-l、字数-w、字节数-c</p><pre><code class="hljs bash">$ wc -l /etc/passwd</code></pre></li><li><p><code>stat</code>：查看文件的具体存储信息和时间等信息</p><pre><code class="hljs bash">$ <span class="hljs-built_in">stat</span> /etc/passwd</code></pre></li><li><p><code>diff</code>：比较多个文本文件的差异</p><pre><code class="hljs bash">$ diff diff_a.txt diff_b.txt</code></pre></li></ul><h3 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h3><ul><li><p><code>touch</code>：创建空白文件或设置文件的时间</p><pre><code class="hljs bash">$ touch touch_a.txt</code></pre></li><li><p><code>mkdir</code>：创建空白目录</p><pre><code class="hljs bash">$ mkdir ~/mkdir_a</code></pre></li><li><p><code>cp</code>：用于复制文件和目录</p><pre><code class="hljs bash">$ cp install.log x.log$ cp -r /etc ~/mkdir_a</code></pre></li><li><p><code>mv</code>：剪切文件或将文件重命名</p><pre><code class="hljs bash">$ mv x.log linux.log</code></pre></li><li><p><code>rm</code>：删除文件或目录</p><pre><code class="hljs bash">$ rm -f install.log$ rm -rf ~/mkdir_a</code></pre></li><li><p><code>dd</code>：按照指定大小和个数的数据块来复制文件或转换文件</p><pre><code class="hljs bash">$ dd <span class="hljs-keyword">if</span>=/dev/zero of=560_file count=1 bs=560M<span class="hljs-comment"># if为输入文件，of为输出文件，count为块数 bs为每个块大小</span>1+0 records <span class="hljs-keyword">in</span>1+0 records out587202560 bytes (587 MB, 560 MiB) copied, 3.49432 s, 168 MB/s</code></pre></li><li><p><code>file</code>：查看文件的类型</p><pre><code class="hljs bash">$ file 560_file560_file: data</code></pre></li></ul><h3 id="压缩搜索命令"><a href="#压缩搜索命令" class="headerlink" title="压缩搜索命令"></a>压缩搜索命令</h3><ul><li><p><code>tar</code>：对文件进行打包压缩或解压</p><pre><code class="hljs bash">$ tar -czvf etc.tar.gz /etc<span class="hljs-comment"># 压缩</span>$ tar -xzvf etc.tar.gz -C /root/etc <span class="hljs-comment"># 解压</span></code></pre></li><li><p><code>grep</code>：在文本中执行关键词搜索，并显示匹配的结果</p><pre><code class="hljs bash">$ grep /sbin/nologin /etc/passwd<span class="hljs-comment"># -n 显示行号； -v 反选信息</span></code></pre></li><li><p><code>find</code>：按照指定条件来查找文件</p><pre><code class="hljs bash">$ find /etc -name <span class="hljs-string">"host*"</span> -<span class="hljs-built_in">print</span><span class="hljs-comment"># 获取到/etc中所有以 host 开头的文件列表</span>$ find / -perm -4000 -<span class="hljs-built_in">print</span><span class="hljs-comment"># 在整个系统中搜索权限中包括 SUID 权限的所有文件</span>$ find / -user linuxprobe -<span class="hljs-built_in">exec</span> cp -a &#123;&#125; /root/findresults/ \;<span class="hljs-comment"># 在整个文件系统中找出所有归属于 linuxprobe 用户的文件并复制到/root/findresults 目录</span><span class="hljs-comment"># 命令的结尾必须是“\;”！！！</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo个人博客</title>
    <link href="/2020/05/24/%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/05/24/%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个快速、简洁且高效的博客框架。</p><p>Hexo主题较多，使用也比较方便，搭建一个博客记录生活学习。</p><p>环境搭建比较简单，记录一下中间遇到的小问题和主题的设置。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>下载安装node.js（建议安装10.0版本以上）</li><li>下载安装git</li><li>下载安装hexo， <code>npm install -g hexo</code> （建议终端走代理）</li></ul><h3 id="本地搭建测试"><a href="#本地搭建测试" class="headerlink" title="本地搭建测试"></a>本地搭建测试</h3><ul><li>本地创建一个文件夹，如xxxblog</li><li>bash中切换到xxxblog目录下，输入 <code>hexo init</code></li><li>运行<code>hexo s</code>打开服务</li><li>本地localhost:4000上应该有博客的基本模板，本地搭建完成</li></ul><h3 id="关联git"><a href="#关联git" class="headerlink" title="关联git"></a>关联git</h3><ul><li>git与本地连接</li></ul><p>绑定信息：</p><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">"你的GitHub用户名"</span>$ git config --global user.email <span class="hljs-string">"你的GitHub绑定的邮箱"</span></code></pre><p>然后生成密钥SSH key：</p><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">"你的GitHub绑定的邮箱"</span></code></pre><p>获取生成的密钥信息放入GitHub-&gt;Settings-&gt;SSH and GPG keys：</p><pre><code class="hljs bash">$ cat ~/.ssh/id_rsa.pub</code></pre><ul><li>git与博客绑定</li></ul><p>在Github上创建名字为<code>xxx,github.io</code>的项目，xxx为你的GitHub用户名，之后均用LeeX0示例。</p><p>打开xxxblog中的_config.yml，将其中的deployment选项的内容改为：</p><pre><code class="hljs xml">deploy:  type: git  repository: https://github.com/LeeX0/LeeX0.github.io.git  branch: master</code></pre><p>ps：如果之后推送时显示403错误，将其中的<code>repository: https://github.com/LeeX0/LeeX0.github.io.git</code></p><p>改为<code>repo: https://GitHub用户名:GitHub密码@github.com/LeeX0/LeeX0.github.io.git</code>尝试</p><ul><li><p>运行<code>npm install hexo-deployer-git –save</code>安装部署工具</p></li><li><p>运行推送</p><pre><code class="hljs bash">$ hexo clean<span class="hljs-comment"># clean 清除本地静态文件</span>$ hexo g<span class="hljs-comment"># generate 生成本地静态文件</span>$ hexo d<span class="hljs-comment"># deploy 推送部署文件至GitHub</span></code></pre></li><li><p>访问leex0.github.io即可查看博客</p></li></ul><h2 id="博客基本使用"><a href="#博客基本使用" class="headerlink" title="博客基本使用"></a>博客基本使用</h2><ul><li>新建文章</li></ul><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"postname"</span><span class="hljs-comment"># 创建新文章</span></code></pre><p>会在source-&gt;_posts文件夹内生成一个postname.md文件，用markdown格式进行编辑。</p><p>其中front-matter字段主要有：title 文章的标题、date 创建日期 、tags 标签、categories 分类。</p><p>tags 、categories写法建议:</p><pre><code class="hljs xml">tags: - [tag1]- [tag2]categories:- [cate1]- [cate2-1,cate2-2]</code></pre><ul><li>插入图片</li></ul><p>文章插入图片source-&gt;image下，对应文件夹markdown相对路径即可/image/xxx.jpg。</p><ul><li>生成推送</li></ul><p>之后运行推送即可</p><pre><code class="hljs bash">$ hexo clean<span class="hljs-comment"># clean 清除本地静态文件</span>$ hexo g<span class="hljs-comment"># generate 生成本地静态文件</span>$ hexo d<span class="hljs-comment"># deploy 推送部署文件至GitHub</span></code></pre><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>其中<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网展示的主题</a>已经比较多了，<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">知乎的问答</a>也有比较多推荐。</p><p>我是用的<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">Fluid</a>主题，介绍一下这个主题的设置。</p><ul><li>下载主题</li></ul><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/archive/v1.8.0.zip" target="_blank" rel="noopener">下载</a>最新主题版本，下载后解压到 themes 目录下并重命名为 fluid。</p><ul><li>修改配置</li></ul><p>修改Hexo目录下的<code>_config.yml</code>：</p><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span>Language: zh-CN  <span class="hljs-comment"># 指定语言，可不改</span></code></pre><p>之后正常生成推送即可，更多设置可参考<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
